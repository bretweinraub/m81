


=pod

=head1 NAME - CSV::CSVDocument

A CSV Document

=head1 EXAMPLE



    my $CSVDocument = new CSV::CSVDocument(filename => $file, debug => $debug, mergeText => '\r\n');
    $CSVDocument->parseFields();
    $CSVDocument->parseLines();
    my @lines = @{$CSVDocument->getLines()};

				     

=cut

# This file was automatically generated from CSVDocument.pm.m80 by 
# bweinraub on li264-192 (Linux li264-192 2.6.35.4-x86_64-linode16 #1 SMP Mon Sep 20 16:03:34 UTC 2010 x86_64 GNU/Linux)
# DO NOT EDIT THIS FILE 


package CSV::CSVDocument;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use FileHandle;
use fields qw( headerLine filename dbType aggressive fieldSeparator fh maxVarCharLength fields DBFields DBDataTypes lines bigTextFields mergeText debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item CSV::CSVDocument->new()

initializes on object of type CSV::CSVDocument

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{headerLine} = {
          'name' => 'headerLine',
          'default' => 1,
          'description' => 'the line number that the document header appears on'
        }
;
$_allSetters{headerLine} = \&setHeaderLine;
$_allMemberAttributes{filename} = {
          'required' => 1,
          'name' => 'filename',
          'type' => 'string',
          'description' => 'Name of the document to parse'
        }
;
$_allSetters{filename} = \&setFilename;
$_allMemberAttributes{dbType} = {
          'required' => 't',
          'name' => 'dbType',
          'default' => 'm80',
          'description' => 'When generating database objects, use this to determine the right syntax'
        }
;
$_allSetters{dbType} = \&setDbType;
$_allMemberAttributes{aggressive} = {
          'name' => 'aggressive',
          'description' => 'aggressively shorten DB field names'
        }
;
$_allSetters{aggressive} = \&setAggressive;
$_allMemberAttributes{fieldSeparator} = {
          'required' => 1,
          'name' => 'fieldSeparator',
          'default' => ',',
          'type' => 'string',
          'description' => 'field separator character(s)'
        }
;
$_allSetters{fieldSeparator} = \&setFieldSeparator;
$_allMemberAttributes{fh} = {
          'name' => 'fh',
          'description' => 'Name of the document to parse'
        }
;
$_allSetters{fh} = \&setFh;
$_allMemberAttributes{maxVarCharLength} = {
          'name' => 'maxVarCharLength',
          'default' => 4000,
          'description' => 'maximum length of a variable length character string'
        }
;
$_allSetters{maxVarCharLength} = \&setMaxVarCharLength;
$_allMemberAttributes{fields} = {
          'name' => 'fields',
          'type' => 'ARRAY',
          'description' => 'array of field names'
        }
;
$_allSetters{fields} = \&setFields;
$_allMemberAttributes{DBFields} = {
          'name' => 'DBFields',
          'type' => 'HASH',
          'description' => 'array of field names converted to valid fields for a database'
        }
;
$_allSetters{DBFields} = \&setDBFields;
$_allMemberAttributes{DBDataTypes} = {
          'name' => 'DBDataTypes',
          'type' => 'HASH',
          'description' => 'array of db type names converted to valid fields for a database'
        }
;
$_allSetters{DBDataTypes} = \&setDBDataTypes;
$_allMemberAttributes{lines} = {
          'name' => 'lines',
          'type' => 'ARRAY',
          'description' => 'array of parsed lines'
        }
;
$_allSetters{lines} = \&setLines;
$_allMemberAttributes{bigTextFields} = {
          'name' => 'bigTextFields',
          'type' => 'ARRAY',
          'description' => 'array of all big text (CLOB maybe) fields'
        }
;
$_allSetters{bigTextFields} = \&setBigTextFields;
$_allMemberAttributes{mergeText} = {
          'name' => 'mergeText',
          'description' => 'data that if found at the end of line, the line is considered run on and will be merged with the next line'
        }
;
$_allSetters{mergeText} = \&setMergeText;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my CSV::CSVDocument $this = shift;

    print STDERR "in CSV::CSVDocument::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of CSV::CSVDocument" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object CSV::CSVDocument. typo ?\n";
        }
    }


    $this->{headerLine} = "1" unless defined $this->{headerLine};

    Confess "cannot initialize object of type CSV::CSVDocument without required member variable filename"
        unless exists $this->{filename};

    $this->{dbType} = "m80" unless defined $this->{dbType};

    Confess "cannot initialize object of type CSV::CSVDocument without required member variable dbType"
        unless exists $this->{dbType};

    $this->{fieldSeparator} = "," unless defined $this->{fieldSeparator};

    Confess "cannot initialize object of type CSV::CSVDocument without required member variable fieldSeparator"
        unless exists $this->{fieldSeparator};

    $this->{maxVarCharLength} = "4000" unless defined $this->{maxVarCharLength};


    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {CSV::CSVDocument::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?CSV::CSVDocument::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {CSV::CSVDocument::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?CSV::CSVDocument::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 headerLine => "any string" (default: "1")

the line number that the document header appears on

=cut

sub getHeaderLine {

=pod

=head3 $CSVDocument->getHeaderLine ()


getter for member headerLine

=cut

    my $this = shift;





    return $this->{headerLine};
}
sub setHeaderLine {

=pod

=head3 $CSVDocument->setHeaderLine (headerLine => "any string")

 - headerLine ("any string")		 : the line number that the document header appears on

setter for member headerLine

=cut

    my $this = shift;


    my $headerLine = shift;



    $this->{headerLine} = $headerLine;
    return $headerLine;
}



=pod

=head2 filename => "any string"*

Name of the document to parse

=cut

sub getFilename {

=pod

=head3 $CSVDocument->getFilename ()


getter for member filename

=cut

    my $this = shift;





    return $this->{filename};
}
sub setFilename {

=pod

=head3 $CSVDocument->setFilename (filename => "any string"*)

 - filename ("any string")		 : Name of the document to parse

setter for member filename

=cut

    my $this = shift;


    my $filename = shift;
    Confess "argument 'filename' is required for CSV::CSVDocument->setFilename()" unless defined $filename;



    $this->{filename} = $filename;
    return $filename;
}



=pod

=head2 dbType => "any string"* (default: "m80")

When generating database objects, use this to determine the right syntax

=cut

sub getDbType {

=pod

=head3 $CSVDocument->getDbType ()


getter for member dbType

=cut

    my $this = shift;





    return $this->{dbType};
}
sub setDbType {

=pod

=head3 $CSVDocument->setDbType (dbType => "any string"*)

 - dbType ("any string")		 : When generating database objects, use this to determine the right syntax

setter for member dbType

=cut

    my $this = shift;


    my $dbType = shift;
    Confess "argument 'dbType' is required for CSV::CSVDocument->setDbType()" unless defined $dbType;



    $this->{dbType} = $dbType;
    return $dbType;
}



=pod

=head2 aggressive => "any string"

aggressively shorten DB field names

=cut

sub getAggressive {

=pod

=head3 $CSVDocument->getAggressive ()


getter for member aggressive

=cut

    my $this = shift;





    return $this->{aggressive};
}
sub setAggressive {

=pod

=head3 $CSVDocument->setAggressive (aggressive => "any string")

 - aggressive ("any string")		 : aggressively shorten DB field names

setter for member aggressive

=cut

    my $this = shift;


    my $aggressive = shift;



    $this->{aggressive} = $aggressive;
    return $aggressive;
}



=pod

=head2 fieldSeparator => "any string"* (default: ",")

field separator character(s)

=cut

sub getFieldSeparator {

=pod

=head3 $CSVDocument->getFieldSeparator ()


getter for member fieldSeparator

=cut

    my $this = shift;





    return $this->{fieldSeparator};
}
sub setFieldSeparator {

=pod

=head3 $CSVDocument->setFieldSeparator (fieldSeparator => "any string"*)

 - fieldSeparator ("any string")		 : field separator character(s)

setter for member fieldSeparator

=cut

    my $this = shift;


    my $fieldSeparator = shift;
    Confess "argument 'fieldSeparator' is required for CSV::CSVDocument->setFieldSeparator()" unless defined $fieldSeparator;



    $this->{fieldSeparator} = $fieldSeparator;
    return $fieldSeparator;
}



=pod

=head2 fh => "any string"

Name of the document to parse

=cut

sub getFh {

=pod

=head3 $CSVDocument->getFh ()


getter for member fh

=cut

    my $this = shift;





    return $this->{fh};
}
sub setFh {

=pod

=head3 $CSVDocument->setFh (fh => "any string")

 - fh ("any string")		 : Name of the document to parse

setter for member fh

=cut

    my $this = shift;


    my $fh = shift;



    $this->{fh} = $fh;
    return $fh;
}



=pod

=head2 maxVarCharLength => "any string" (default: "4000")

maximum length of a variable length character string

=cut

sub getMaxVarCharLength {

=pod

=head3 $CSVDocument->getMaxVarCharLength ()


getter for member maxVarCharLength

=cut

    my $this = shift;





    return $this->{maxVarCharLength};
}
sub setMaxVarCharLength {

=pod

=head3 $CSVDocument->setMaxVarCharLength (maxVarCharLength => "any string")

 - maxVarCharLength ("any string")		 : maximum length of a variable length character string

setter for member maxVarCharLength

=cut

    my $this = shift;


    my $maxVarCharLength = shift;



    $this->{maxVarCharLength} = $maxVarCharLength;
    return $maxVarCharLength;
}



=pod

=head2 fields => "any string"

array of field names

=cut

sub getFields {

=pod

=head3 $CSVDocument->getFields ()


getter for member fields

=cut

    my $this = shift;





    return $this->{fields};
}
sub setFields {

=pod

=head3 $CSVDocument->setFields (fields => "any string")

 - fields ("any string")		 : array of field names

setter for member fields

=cut

    my $this = shift;


    my $fields = shift;



    $this->{fields} = $fields;
    return $fields;
}



=pod

=head2 DBFields => "any string"

array of field names converted to valid fields for a database

=cut

sub getDBFields {

=pod

=head3 $CSVDocument->getDBFields ()


getter for member DBFields

=cut

    my $this = shift;





    return $this->{DBFields};
}
sub setDBFields {

=pod

=head3 $CSVDocument->setDBFields (DBFields => "any string")

 - DBFields ("any string")		 : array of field names converted to valid fields for a database

setter for member DBFields

=cut

    my $this = shift;


    my $DBFields = shift;



    $this->{DBFields} = $DBFields;
    return $DBFields;
}



=pod

=head2 DBDataTypes => "any string"

array of db type names converted to valid fields for a database

=cut

sub getDBDataTypes {

=pod

=head3 $CSVDocument->getDBDataTypes ()


getter for member DBDataTypes

=cut

    my $this = shift;





    return $this->{DBDataTypes};
}
sub setDBDataTypes {

=pod

=head3 $CSVDocument->setDBDataTypes (DBDataTypes => "any string")

 - DBDataTypes ("any string")		 : array of db type names converted to valid fields for a database

setter for member DBDataTypes

=cut

    my $this = shift;


    my $DBDataTypes = shift;



    $this->{DBDataTypes} = $DBDataTypes;
    return $DBDataTypes;
}



=pod

=head2 lines => "any string"

array of parsed lines

=cut

sub getLines {

=pod

=head3 $CSVDocument->getLines ()


getter for member lines

=cut

    my $this = shift;





    return $this->{lines};
}
sub setLines {

=pod

=head3 $CSVDocument->setLines (lines => "any string")

 - lines ("any string")		 : array of parsed lines

setter for member lines

=cut

    my $this = shift;


    my $lines = shift;



    $this->{lines} = $lines;
    return $lines;
}



=pod

=head2 bigTextFields => "any string"

array of all big text (CLOB maybe) fields

=cut

sub getBigTextFields {

=pod

=head3 $CSVDocument->getBigTextFields ()


getter for member bigTextFields

=cut

    my $this = shift;





    return $this->{bigTextFields};
}
sub setBigTextFields {

=pod

=head3 $CSVDocument->setBigTextFields (bigTextFields => "any string")

 - bigTextFields ("any string")		 : array of all big text (CLOB maybe) fields

setter for member bigTextFields

=cut

    my $this = shift;


    my $bigTextFields = shift;



    $this->{bigTextFields} = $bigTextFields;
    return $bigTextFields;
}



=pod

=head2 mergeText => "any string"

data that if found at the end of line, the line is considered run on and will be merged with the next line

=cut

sub getMergeText {

=pod

=head3 $CSVDocument->getMergeText ()


getter for member mergeText

=cut

    my $this = shift;





    return $this->{mergeText};
}
sub setMergeText {

=pod

=head3 $CSVDocument->setMergeText (mergeText => "any string")

 - mergeText ("any string")		 : data that if found at the end of line, the line is considered run on and will be merged with the next line

setter for member mergeText

=cut

    my $this = shift;


    my $mergeText = shift;



    $this->{mergeText} = $mergeText;
    return $mergeText;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $CSVDocument->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $CSVDocument->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from CSVDocument.pm.m80 by 
bweinraub on li264-192 (Linux li264-192 2.6.35.4-x86_64-linode16 #1 SMP Mon Sep 20 16:03:34 UTC 2010 x86_64 GNU/Linux)


=head1 OBJECT METHODS

=cut



################################################################################

sub _new {

=pod

=head3 $CSVDocument->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	my $fh = new FileHandle;
	Confess "Failed to open " . $this->getFilename() 
	    unless $fh->open ("< " . $this->getFilename());
	$this->setFh($fh);
    };
}

################################################################################

sub nextLine {

=pod

=head3 $CSVDocument->nextLine (chomp => "any string", mergeText => "any string")

 - chomp ("any string")		 : chomp the next line
 - mergeText ("any string")		 : data that if found at the end of line, the line is considered run on and will be merged with the next line

return the next line from the file handle

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->nextLine requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $chomp = $args{chomp};
    my $mergeText = $args{mergeText};



    do {
	my $fh = $this->getFh();
	my $_finished;                                                          # set to 1 when we are done reading data
	my $fulline;                                                            # all the data read
	my $numDQs = 0;                                                         # track the number of double quoutes read
	while (not $_finished) {
	    my $line = <$fh>;
	    $fulline .= $line;
	    # look for run on lines due to open double quoutes;
	    my $dqtest = $line;
	    $dqtest =~ s/[^\"]//g;
	    $numDQs += length($dqtest);
	    $this->debugPrint(2, "found " . length($dqtest) . " \"\'s in line; total is $numDQs");
	    if (($numDQs % 2) > 0) {
		$this->debugPrint(2, "continuing to read input due to run-on line");
	    } elsif ($mergeText) {
		if ($line =~ /$mergeText$/) {
		    $this->debugPrint(2, "continuing to read input due to matched merge text");
		} else {
		    $_finished = 't';
		}
	    } else {
		$_finished = 't';
	    }
	}
	$this->debugPrint(2, "loaded line $fulline");	
	chomp($fulline) if $chomp;
	$fulline;						    
    };
}

################################################################################

sub _splitData {
   
=pod

=head3 $CSVDocument->_splitData (data => "any string"*)

 - data ("any string")		 : data to process

takes a line of data and splits it into array according to the defined field separator character

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->_splitData requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for CSV::CSVDocument->_splitData()" unless exists $args{data};



    do {

	my $fieldSeparator = $this->getFieldSeparator();

        ################################################################################
	#
	# Ignore commas between ",s - this is a pain in the ass.  Basically our strategy is move through the string one 
	# character at a time.  If we see a ",", then we convert this to another string (__damnit__).  Then after we split
	# the data along the separator character, we can convert the magic string back into the separator character.
	#
	################################################################################

	my @chars = unpack "(a)*", $data;                                       # unpack is strange - see the man page
	my $newstring;                                                          # build this as we move through the line
	my $foundDQ;                                                            # found double quoute

	my @commaFields;                                                        # keep track of every field that needs to be converted back
	my $ndx = 0;                                                            # increment every time we see a comma.

	foreach my $char (@chars) {
	    if ($foundDQ) {
		if ($char =~ /$fieldSeparator/) {
		    $newstring .= "__DAMNIT__";                                 # found the field sep. between double quoutes.
		    push (@commaFields, $ndx);                                  # keep track of the found field index
		} else {
		    if ($char =~ /\"/) {
			undef $foundDQ;
		    } else {
			$newstring .= $char;
		    }
		}
	    } else {
		if ($char =~ /\"/) {
		    $foundDQ = 1;
		} elsif ($char =~ /$fieldSeparator/) {
		    $ndx++;
		}
		$newstring .= $char unless $char =~ /\"/;
	    }
	}

	$newstring .= ",DUMMYTEXT";

	################################################################################
	#
	# Do the Splitting
	#
	################################################################################
	
	$this->debugPrint (3,"using field separator of $fieldSeparator to split string $newstring");

	my @fields = split (/$fieldSeparator/, $newstring);
	
	################################################################################
	#
	# Now that we've split the fields, we convert our magic string back to a comma
	#
	################################################################################

	map { $fields[$_] =~ s/__DAMNIT__/$fieldSeparator/g; } (@commaFields);

	$this->debugPrint (3,Dumper(@fields));
	$this->debugPrint (2,$#fields);

	\@fields;
    };						  
}

################################################################################

sub parseFields {

=pod

=head3 $CSVDocument->parseFields ()


parse the first line of a CSV document and build an array of field names

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->parseFields requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;


    my $headerLine = $this->getHeaderLine(); 


    do {
	$this->nextLine while --$headerLine > 0;

	my @fields = @{$this->_splitData(data => $this->nextLine(chomp => 't'))};

	$this->debugPrint(2, "Field names are " . Dumper(@fields));

	# Make sure field names are unique

	my %fieldNames = ();                                                    # unique hash of field names

	$this->debugPrint(1, "Number of fields is  " . ($#fields - 1));
	for (my $i = 0 ; $i < $#fields ; $i++) {
	    my $field = $fields[$i];
	    $this->debugPrint(2, "looking for duplicates of field $field");
	    if ($fieldNames{$field}) {                                          # duplicate -> generate a new field.
		$this->debugPrint(1, "looks like $field is duplicated");
		$fields[$i] .= "_" . ++$fieldNames{$field};
	    } else {
		$fieldNames{$field} = 1;
	    }
	}
	$this->setFields(\@fields);
    }
}

################################################################################

sub _parseLine {
    
=pod

=head3 $CSVDocument->_parseLine ()


read a line from the input.  Build a hash of the data based on the parsed fields.

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->_parseLine requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	my $line = $this->nextLine(mergeText => $this->getMergeText(), chomp => 't');
	$this->debugPrint(2, "parsing line $line");
	if ($line) {
	    my %hash = ();
	    my @fields = @{$this->getFields()};
	    my @data = @{$this->_splitData(data => $line)};
	    my $ndx = 0;                                                            # array index into the data 

	    $this->debugPrint(1, "found " . $#data . " fields out of " . $#fields);
	    foreach my $field (@fields) {
		$hash{$field} = $data[$ndx++]
		    unless $field =~ /DUMMYTEXT/;
	    }
	    $hash{___original_data___} = $line;
	    $hash{___internal_badata___} = "found " . $#data . " fields out of " . $#fields
		if ($#data != $#fields);                                        # mark this row bad since the number of fields read doesn't match
	    return \%hash;
	} 
	return;
    };
}

################################################################################

sub parseLines {
    
=pod

=head3 $CSVDocument->parseLines ()


read each line from the input.  Build a hash of the data based on the parsed fields for each line.

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->parseLines requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	my @parsedLines;
	
	while (my $parsedLine = $this->_parseLine()) {
	    push(@parsedLines,$parsedLine);
	}

	$this->setLines(\@parsedLines);
    };
}

################################################################################

sub initialize {
   
=pod

=head3 $CSVDocument->initialize ()


Loads the fields and lines from a CSV document if not done already.

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->initialize requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	$this->parseFields() unless $this->getFields();
	$this->parseLines() unless $this->getLines();
	$this->_buildDBFieldNames() unless $this->getDBFields();
    };
}

################################################################################

sub DBFieldName {
   
=pod

=head3 $CSVDocument->DBFieldName (field => "any string"*)

 - field ("any string")		 : field to convert

Convert a csv column name into a database field name

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->DBFieldName requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $field = $args{field};
    Confess "argument 'field' is required for CSV::CSVDocument->DBFieldName()" unless exists $args{field};



    do {
	my $save=$field;
	$field =~ s/\&/and/g;
	$field =~ s/[\s:\-\(\)\.\/]/_/g;
	$field =~ s/\#/no/g;
	$field =~ s/%/pct/g;
	$field =~ s/\'//g;
	$field =~ s/\;//g;
	$field =~ s/_+/_/g;
	$field =~ s/,/_/g;
	$field =~ s/^_//g;
	$field =~ s/\[//g;
	$field =~ s/\]//g;
	$field =~ s/^Number$/Number_/;
	if ($this->getAggressive()) {
	    $field =~ s/(address)_([12])/$1$2/gi;	    
	    $field =~ s/_\d+$//g;	    
	    $field =~ s/address/addr/gi;	    
	}
	$field = substr($field, 0, 30);
	$this->debugPrint(2, "$save converted to field name $field");
	$field;
    };
}


################################################################################

sub __DBdependentText {
   
=pod

=head3 $CSVDocument->__DBdependentText (type => "any string"*, modifier1 => "any string", modifier2 => "any string")

 - type ("any string")		 : the data type to convert to the db dependent data type
 - modifier1 ("any string")		 : modifier 1
 - modifier2 ("any string")		 : modifier 2

returns the correct data type for a specific database type based on the input

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->__DBdependentText requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $type = $args{type};
    Confess "argument 'type' is required for CSV::CSVDocument->__DBdependentText()" unless exists $args{type};
    my $modifier1 = $args{modifier1};
    my $modifier2 = $args{modifier2};



    do {

	my $dbType = $this->getDbType();
	
      SWITCH: {
	  $dbType =~ /m80/ && do {
	      if ($type =~ /date/i) {
		  return "DATE";
	      } elsif ($type =~ /^create/i) {
		  return "createM80StandardTable(" . $modifier1 . ", (\n";
	      } elsif ($type =~ /endcreate/i) {
		  return ",
                       ),
                       (),,
                       (INSTANTIATION_TABLE=true),
                      )m4_dnl;\n\n";
	      } elsif ($type =~ /^text/i) {
		  Confess "for text fields you must specify 'modifier1 =>' in the call to __DBdependentText" unless defined $modifier1;
		  return 'varcharType(' . $modifier1 . ')';
	      } elsif ($type =~ /bigtext/i) {
		  return 'CLOB';
	      } elsif ($type =~ /number/i) {
		  if (defined $modifier1) {
		      if (defined $modifier2) {
			  return 'number(' . $modifier1 . ','. $modifier2 .')';
		      } else {
			  return 'number(' . $modifier1 .')';
		      }
		  } else {
		      return 'number';
		  }
	      } else {
		  Confess "Unknown or implemented $type for db type $dbType";
	      }
	      last SWITCH;
	  };
	  Confess "database type of $dbType is not implemented :(";
      };
	
    };
}

################################################################################

sub deriveDataType {
   
=pod

=head3 $CSVDocument->deriveDataType (field => "any string"*, dateFormat => "any string")

 - field ("any string")		 : field name to investigate
 - dateFormat ("any string")		 : Date format as a perl regular expression to look for within the data (default: [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})

For a parsed document, takes a field name as an argument.  Then inspects the data for this field and derives the correct data type for the field.   Generates the data type based on the $this->getDBType() value

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->deriveDataType requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $field = $args{field};
    Confess "argument 'field' is required for CSV::CSVDocument->deriveDataType()" unless exists $args{field};
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}");



    do {
	my $ret;
	$this->debugPrint(2, "Processing field $field");
	my @lines = @{$this->getLines()};

	my ($ndx, $numDateStrings, $numNumerical, $numBlank, $maxLength) = (0,0,0,0,0);
	my $numericalRegex = '^([0-9]+(.[0-9]+|)$)';

	foreach my $line (@lines) {
	    $ndx++;
	    my $data = $line->{$field};
	    my $len = length($data);

	    $maxLength = (($len > $maxLength) ? $len : $maxLength);
	    
	    if ($data =~ /$dateFormat/)  {
		$numDateStrings++;
	    } elsif ($data =~ /$numericalRegex/) {
		$numNumerical++;
	    } elsif ($data =~ /^\s+$/) {
		$numBlank++;
	    }
	    $this->debugPrint (2, "field $field ($ndx,$numDateStrings,$numNumerical,$numBlank) is : " . $line->{$field});
	}
	my $type;
	if (($numDateStrings + $numBlank) == $ndx) {
	    $type = $this->__DBdependentText(type => 'date');
	} elsif (($numNumerical + $numBlank) == $ndx) {
	    $type = $this->__DBdependentText(type => 'number');
	} elsif ($maxLength > $this->getMaxVarCharLength()) { 
	    $type = $this->__DBdependentText(type => 'bigtext'),
	} else {
	    $type = $this->__DBdependentText(type => 'text',
					     modifier1 => ($maxLength < 1 ? 1 : $maxLength));
	}
	
	$ret .= "        " . $this->DBFieldName(field => $field);
	$ret .= "\t$type";
	$ret;
    };
}


################################################################################

sub __deriveDataType {
   
=pod

=head3 $CSVDocument->__deriveDataType (field => "any string"*, dateFormat => "any string")

 - field ("any string")		 : field name to investigate
 - dateFormat ("any string")		 : Date format as a perl regular expression to look for within the data (default: [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})

Derive the textual definition of the data type of a field

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->__deriveDataType requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $field = $args{field};
    Confess "argument 'field' is required for CSV::CSVDocument->__deriveDataType()" unless exists $args{field};
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}");



    do {
	$this->debugPrint(2, "Processing field $field");
	my @lines = @{$this->getLines()};
	my %DBDataTypes;
	my @bigTextFields;

	if ($this->getBigTextFields()) {
	    @bigTextFields = @{$this->getBigTextFields()};
	} else {
	    @bigTextFields = ();
	}

	if ($this->getDBDataTypes()) {
	    %DBDataTypes = %{$this->getDBDataTypes()};
	} else {
	    %DBDataTypes = ();
	}

	my ($ndx, $numDateStrings, $numNumerical, $numBlank, $maxLength) = (0,0,0,0,0);
	my $numericalRegex = '^([0-9]+(.[0-9]+|)$)';

	foreach my $line (@lines) {
	    $ndx++;
	    my $data = $line->{$field};
	    my $len = length($data);

	    $maxLength = (($len > $maxLength) ? $len : $maxLength);
	    
	    if ($data =~ /$dateFormat/)  {
		$numDateStrings++;
	    } elsif ($data =~ /$numericalRegex/) {
		$numNumerical++;
	    } elsif ($data =~ /^\s+$/) {
		$numBlank++;
	    }
	    $this->debugPrint (2, "field $field ($ndx,$numDateStrings,$numNumerical,$numBlank) is : " . $line->{$field});
	}
	my $type;
	if (($numDateStrings + $numBlank) == $ndx) {
	    $type = 'date';
	} elsif (($numNumerical + $numBlank) == $ndx) {
	    $type = 'number';
	} elsif ($maxLength > $this->getMaxVarCharLength()) { 
	    $type = 'bigtext';
	    push (@bigTextFields, $field);
	} else {
	    $type = 'text';
	}
	
	$DBDataTypes{$field} = $type;
	$this->setDBDataTypes(\%DBDataTypes);
	$this->setBigTextFields(\@bigTextFields);
    };
}


################################################################################

sub _deriveDataTypes {
   
=pod

=head3 $CSVDocument->_deriveDataTypes ()


Loops over the fields in the CSV document and derives the correct db data type.

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->_deriveDataTypes requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	$this->initialize();
	my @fields = @{$this->getFields()};

	foreach my $field (@fields) {
	    $this->__deriveDataType(field => $field)
		    unless $field =~ /DUMMYTEXT/;
	}
	$this->debugPrint(2, "datatype definitions are " . Dumper($this->getDBDataTypes()));
    };
}



################################################################################

sub _buildDBFieldNames {
   
=pod

=head3 $CSVDocument->_buildDBFieldNames ()


scans threw the parsed fields, and builds a DB safe field name.  Handles duplicates as well.

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->_buildDBFieldNames requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	my @fields = @{$this->getFields()};
	my %DBFields = ();

	foreach my $field (@fields) {
	    $DBFields{$field} = $this->DBFieldName(field => $field)
		unless $field =~ /DUMMYTEXT/;
	}

	$this->setDBFields(\%DBFields);
    };
}

################################################################################

sub generateSchema {
    
=pod

=head3 $CSVDocument->generateSchema (tableName => "any string"*, dateFormat => "any string")

 - tableName ("any string")		 : Name of table to generate
 - dateFormat ("any string")		 : Date format as a perl regular expression to look for within the data (default: [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})

Generate a schema definition based on the parsed data from a CSV file.

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->generateSchema requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $tableName = $args{tableName};
    Confess "argument 'tableName' is required for CSV::CSVDocument->generateSchema()" unless exists $args{tableName};
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}");



    do {
	$this->initialize();
	my @fields = @{$this->getFields()};

	$this->debugPrint(1, "table name is $tableName");
	my $ret = $this->__DBdependentText(type => 'create',
					   modifier1 => $tableName);
	my $fieldNum = 0;                                                       # track our field number

	foreach my $field (@fields) {
	    unless ($field =~ /DUMMYTEXT/) {
		$ret .= ",\n" if $fieldNum++;
		$ret .= $this->deriveDataType(field => $field, dateFormat => $dateFormat);
	    }
	}

	$ret .= $this->__DBdependentText(type => 'endcreate');
	print $ret;
    };
}


################################################################################

sub formatField {
   
=pod

=head3 $CSVDocument->formatField (field => "any string"*, dbType => "any string"*, line => "any string"*, bind => "any string")

 - field ("any string")		 : field name
 - dbType ("any string")		 : type of database being loaded (default: "oracle")
 - line ("any string")		 : line to process
 - bind ("any string")		 : if set, return a bind variable placeholder as opposed to the actual text

Format a field for database update that correctly manages nulls

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->formatField requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $field = $args{field};
    Confess "argument 'field' is required for CSV::CSVDocument->formatField()" unless exists $args{field};
    my $dbType = ($args{dbType} ? $args{dbType} : "oracle");
    Confess "argument 'dbType' is required for CSV::CSVDocument->formatField()" unless exists $args{dbType};
    my $line = $args{line};
    Confess "argument 'line' is required for CSV::CSVDocument->formatField()" unless exists $args{line};
    my $bind = $args{bind};



    do {
	my %DBDataTypes = %{$this->getDBDataTypes()};
	my $type = $DBDataTypes{$field};

	return "null" unless exists $line->{$field};
      SWITCH: {
	  $type =~ /date/ && do {
	      return "null" unless $line->{$field};
	      return "null" if $line->{$field} =~ '0000-00-00 00:00:00';
	      return "to_date('$line->{$field}','YYYY-MM-DD HH24:MI:SS')";
	      last SWITCH;
	  };

	  $type =~ /bigtext/ && do {
	      if ($bind) {
		  return '?';
	      } else {
		  return "null" unless $line->{$field};
		  my $tmp = $line->{$field};
		  $tmp =~ s/\'/\'\'/g;
		  return "'$tmp'";
	      }
	  };
	  $type =~ /text/ && do {
	      return "null" unless $line->{$field};
	      my $tmp = $line->{$field};
	      $tmp =~ s/\'/\'\'/g;
	      return "'$tmp'";
	      last SWITCH;
	  };
	  return $line->{$field};
      };
	
    };
}




################################################################################

sub loadDB {
   
=pod

=head3 $CSVDocument->loadDB (dbh => DBI::db*, tableName => "any string"*, purge => "any string", dbType => "any string"*)

 - dbh (DBI::db)		 : DBI handle for the database
 - tableName ("any string")		 : table name
 - purge ("any string")		 : purge the table before loading it
 - dbType ("any string")		 : database type for formating SQL strings

Load a database with the data from this CSV document.

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->loadDB requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $dbh = $args{dbh};
    Confess "argument 'dbh' is required for CSV::CSVDocument->loadDB()" unless exists $args{dbh};
    eval {my $dummy = $dbh->isa("DBI::db");};Confess "$@\n" . Dumper($dbh) if $@;
    if (defined $dbh) { Confess "argument 'dbh' of method CSV::CSVDocument->loadDB() is required to be of reference type DBI::db, but it looks to be of type " . ref ($dbh)  unless $dbh->isa("DBI::db");}
    my $tableName = $args{tableName};
    Confess "argument 'tableName' is required for CSV::CSVDocument->loadDB()" unless exists $args{tableName};
    my $purge = $args{purge};
    my $dbType = $args{dbType};
    Confess "argument 'dbType' is required for CSV::CSVDocument->loadDB()" unless exists $args{dbType};



    do {
	$this->initialize();
	$this->_deriveDataTypes() unless $this->getDBDataTypes();

	open (ERRORS, "> $tableName.err");

	if ($purge) {
	    $dbh->prepare("delete from $tableName")->execute()
		or Confess "ERROR: $DBI::errstr";
	}
	
	my @lines = @{$this->getLines()};	
	my @fields = @{$this->getFields()};
	my %DBFields = %{$this->getDBFields()};
	my %DBDataTypes = %{$this->getDBDataTypes()};
	my @bigTextFields = @{$this->getBigTextFields()};

	my $fieldText = "insert into $tableName (";
	my $ndx = 0;

	foreach my $field (@fields) {
	    $fieldText .= ($ndx++ ? "," : "") . "\n\t" . $DBFields{$field}
	    unless $field =~ /DUMMYTEXT/;
	}
	$fieldText .= "\n) values (";
	my $lineno =0;
	my $numloaded  = 0;
	my $numrejected = 0;

	foreach my $line (@lines) {
	    $this->debugPrint(3, Dumper($line));

	    if ($line->{___internal_badata___}) {
		$numrejected += 
		    $this->rejectLine(lineno => $lineno++,
				      data => $line,
				      error => $line->{___internal_badata___});
		next;
	    }

	    my $ret = $fieldText;
	    $ndx = 0;
	    foreach my $field (@fields) {
		$ret .= ($ndx++ ? "," : "") . "\n\t" . $this->formatField(field => $field, 
									  line => $line,
									  bind => 't',
									  dbType => $dbType)
		    unless $field =~ /DUMMYTEXT/;
	    }
	    $ret .= "\n)";
	    
	    $this->debugPrint(2, "$ret");
	    eval {
		my $stmt = $dbh->prepare($ret);

		my $bind_no = 1;
		foreach my $bigtextfield (@bigTextFields) {
		    my $val = $this->formatField(field => $bigtextfield,
						 line => $line,
						 dbType => $dbType);
		    $this->debugPrint (2, "binding field $bigtextfield with value $val");
		    $stmt->bind_param ($bind_no, $val);
		}

		$stmt->execute()
		    or Confess "ERROR: $DBI::errstr";
	    };
	    if ($@) {
		my $err=$@;
		$numrejected += 
		    $this->rejectLine(lineno => $lineno++,
				      data => $line,
				      sql => $ret,
				      error => $err);
	    } else {
		$this->debugPrint(1, "loaded line ". $lineno++);
		$numloaded++;
	    }

	}
	close (ERROR);
	$this->debugPrint(0, "loaded $numloaded lines, rejected $numrejected" . ($numrejected ? " ; see $tableName.err for details " : ""));
	return $numrejected;
    };
}


################################################################################

sub rejectLine {
   
=pod

=head3 $CSVDocument->rejectLine (lineno => "any string"*, data => "any string"*, sql => "any string", error => "any string"*)

 - lineno ("any string")		 : line number of failure
 - data ("any string")		 : failed data 
 - sql ("any string")		 : sql statement (if any)
 - error ("any string")		 : error text

reject the line specified

=cut

    my $this = shift;

    Confess "CSV::CSVDocument->rejectLine requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $lineno = $args{lineno};
    Confess "argument 'lineno' is required for CSV::CSVDocument->rejectLine()" unless exists $args{lineno};
    my $data = $args{data};
    Confess "argument 'data' is required for CSV::CSVDocument->rejectLine()" unless exists $args{data};
    my $sql = $args{sql};
    my $error = $args{error};
    Confess "argument 'error' is required for CSV::CSVDocument->rejectLine()" unless exists $args{error};



    do {
	$this->debugPrint(1, "rejected line ". $lineno);
	my @fields = @{$this->getFields()};
	print ERRORS "################################################################################\n";
	print ERRORS "Line Number: $lineno\n";
	print ERRORS "DATA: " . Dumper ($data) . "\n";
	print ERRORS "SQL: $sql\n";
	print ERRORS "ERROR: $error\n";
	print ERRORS "FIELDS:\n";
	foreach my $field (@fields) {
	    print ERRORS "$field => ". $data->{$field} . "\n";
	}
	1;
    };
}


