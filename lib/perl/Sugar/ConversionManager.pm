


=pod

=head1 NAME - Sugar::ConversionManager

Manages Sugar Conversions and migrations

=head1 EXAMPLE


    my $ConversionManager = $ConversionManager->new();   # stub example .... expand


=cut

# This file was automatically generated from ConversionManager.pm.m80 by 
# bweinraub on li264-192 (Linux li264-192 2.6.35.4-x86_64-linode16 #1 SMP Mon Sep 20 16:03:34 UTC 2010 x86_64 GNU/Linux)
# DO NOT EDIT THIS FILE 


package Sugar::ConversionManager;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use DB::Utils;
use Sugar::CustomField;
use fields qw( relations type sourceKey sourceTable sourceFields targetKey srcHandle targetHandle targetTable fieldMap sugarFields moduleKeys sugarModule customFields formattedFields maxFormattedRows debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item Sugar::ConversionManager->new()

initializes on object of type Sugar::ConversionManager

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{relations} = {
          'name' => 'relations',
          'description' => 'an array of relations'
        }
;
$_allSetters{relations} = \&setRelations;
$_allMemberAttributes{type} = {
          'required' => 1,
          'name' => 'type',
          'default' => 'InsideSales',
          'description' => 'Conversion type'
        }
;
$_allSetters{type} = \&setType;
$_allMemberAttributes{sourceKey} = {
          'name' => 'sourceKey',
          'description' => 'primarykey of source table'
        }
;
$_allSetters{sourceKey} = \&setSourceKey;
$_allMemberAttributes{sourceTable} = {
          'required' => 1,
          'name' => 'sourceTable',
          'description' => 'source table name'
        }
;
$_allSetters{sourceTable} = \&setSourceTable;
$_allMemberAttributes{sourceFields} = {
          'name' => 'sourceFields',
          'default' => '*',
          'description' => 'list of fields to process from the source table'
        }
;
$_allSetters{sourceFields} = \&setSourceFields;
$_allMemberAttributes{targetKey} = {
          'required' => 1,
          'name' => 'targetKey',
          'description' => 'primarykey of target table '
        }
;
$_allSetters{targetKey} = \&setTargetKey;
$_allMemberAttributes{srcHandle} = {
          'required' => 't',
          'name' => 'srcHandle',
          'description' => 'database handle for the source database'
        }
;
$_allSetters{srcHandle} = \&setSrcHandle;
$_allMemberAttributes{targetHandle} = {
          'required' => 't',
          'name' => 'targetHandle',
          'description' => 'database handle for the target database'
        }
;
$_allSetters{targetHandle} = \&setTargetHandle;
$_allMemberAttributes{targetTable} = {
          'required' => 1,
          'name' => 'targetTable',
          'description' => 'target table name'
        }
;
$_allSetters{targetTable} = \&setTargetTable;
$_allMemberAttributes{fieldMap} = {
          'required' => 1,
          'name' => 'fieldMap',
          'description' => 'map of field conversions'
        }
;
$_allSetters{fieldMap} = \&setFieldMap;
$_allMemberAttributes{sugarFields} = {
          'name' => 'sugarFields',
          'description' => 'special sugar field generation statements'
        }
;
$_allSetters{sugarFields} = \&setSugarFields;
$_allMemberAttributes{moduleKeys} = {
          'ref' => 'HASH',
          'name' => 'moduleKeys',
          'description' => 'module keys from the conversion template'
        }
;
$_allSetters{moduleKeys} = \&setModuleKeys;
$_allMemberAttributes{sugarModule} = {
          'required' => 1,
          'name' => 'sugarModule',
          'description' => 'name of sugar module for code generation'
        }
;
$_allSetters{sugarModule} = \&setSugarModule;
$_allMemberAttributes{customFields} = {
          'ref' => 'ARRAY',
          'name' => 'customFields',
          'description' => 'array of descriptors of custom fields metadata.'
        }
;
$_allSetters{customFields} = \&setCustomFields;
$_allMemberAttributes{formattedFields} = {
          'ref' => 'HASH',
          'name' => 'formattedFields',
          'description' => 'map of formatted fields by position'
        }
;
$_allSetters{formattedFields} = \&setFormattedFields;
$_allMemberAttributes{maxFormattedRows} = {
          'name' => 'maxFormattedRows',
          'description' => 'max row of formatted fields by position'
        }
;
$_allSetters{maxFormattedRows} = \&setMaxFormattedRows;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my Sugar::ConversionManager $this = shift;

    print STDERR "in Sugar::ConversionManager::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of Sugar::ConversionManager" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object Sugar::ConversionManager. typo ?\n";
        }
    }


    $this->{type} = "InsideSales" unless defined $this->{type};

    Confess "cannot initialize object of type Sugar::ConversionManager without required member variable type"
        unless exists $this->{type};

    Confess "cannot initialize object of type Sugar::ConversionManager without required member variable sourceTable"
        unless exists $this->{sourceTable};

    $this->{sourceFields} = "*" unless defined $this->{sourceFields};

    Confess "cannot initialize object of type Sugar::ConversionManager without required member variable targetKey"
        unless exists $this->{targetKey};

    Confess "cannot initialize object of type Sugar::ConversionManager without required member variable srcHandle"
        unless exists $this->{srcHandle};

    Confess "cannot initialize object of type Sugar::ConversionManager without required member variable targetHandle"
        unless exists $this->{targetHandle};

    Confess "cannot initialize object of type Sugar::ConversionManager without required member variable targetTable"
        unless exists $this->{targetTable};

    Confess "cannot initialize object of type Sugar::ConversionManager without required member variable fieldMap"
        unless exists $this->{fieldMap};

    Confess "cannot initialize object of type Sugar::ConversionManager without required member variable sugarModule"
        unless exists $this->{sugarModule};


    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {Sugar::ConversionManager::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Sugar::ConversionManager::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {Sugar::ConversionManager::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Sugar::ConversionManager::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 relations => "any string"

an array of relations

=cut

sub getRelations {

=pod

=head3 $ConversionManager->getRelations ()


getter for member relations

=cut

    my $this = shift;





    return $this->{relations};
}
sub setRelations {

=pod

=head3 $ConversionManager->setRelations (relations => "any string")

 - relations ("any string")		 : an array of relations

setter for member relations

=cut

    my $this = shift;


    my $relations = shift;



    $this->{relations} = $relations;
    return $relations;
}



=pod

=head2 type => "any string"* (default: "InsideSales")

Conversion type

=cut

sub getType {

=pod

=head3 $ConversionManager->getType ()


getter for member type

=cut

    my $this = shift;





    return $this->{type};
}
sub setType {

=pod

=head3 $ConversionManager->setType (type => "any string"*)

 - type ("any string")		 : Conversion type

setter for member type

=cut

    my $this = shift;


    my $type = shift;
    Confess "argument 'type' is required for Sugar::ConversionManager->setType()" unless defined $type;



    $this->{type} = $type;
    return $type;
}



=pod

=head2 sourceKey => "any string"

primarykey of source table

=cut

sub getSourceKey {

=pod

=head3 $ConversionManager->getSourceKey ()


getter for member sourceKey

=cut

    my $this = shift;





    return $this->{sourceKey};
}
sub setSourceKey {

=pod

=head3 $ConversionManager->setSourceKey (sourceKey => "any string")

 - sourceKey ("any string")		 : primarykey of source table

setter for member sourceKey

=cut

    my $this = shift;


    my $sourceKey = shift;



    $this->{sourceKey} = $sourceKey;
    return $sourceKey;
}



=pod

=head2 sourceTable => "any string"*

source table name

=cut

sub getSourceTable {

=pod

=head3 $ConversionManager->getSourceTable ()


getter for member sourceTable

=cut

    my $this = shift;





    return $this->{sourceTable};
}
sub setSourceTable {

=pod

=head3 $ConversionManager->setSourceTable (sourceTable => "any string"*)

 - sourceTable ("any string")		 : source table name

setter for member sourceTable

=cut

    my $this = shift;


    my $sourceTable = shift;
    Confess "argument 'sourceTable' is required for Sugar::ConversionManager->setSourceTable()" unless defined $sourceTable;



    $this->{sourceTable} = $sourceTable;
    return $sourceTable;
}



=pod

=head2 sourceFields => "any string" (default: "*")

list of fields to process from the source table

=cut

sub getSourceFields {

=pod

=head3 $ConversionManager->getSourceFields ()


getter for member sourceFields

=cut

    my $this = shift;





    return $this->{sourceFields};
}
sub setSourceFields {

=pod

=head3 $ConversionManager->setSourceFields (sourceFields => "any string")

 - sourceFields ("any string")		 : list of fields to process from the source table

setter for member sourceFields

=cut

    my $this = shift;


    my $sourceFields = shift;



    $this->{sourceFields} = $sourceFields;
    return $sourceFields;
}



=pod

=head2 targetKey => "any string"*

primarykey of target table 

=cut

sub getTargetKey {

=pod

=head3 $ConversionManager->getTargetKey ()


getter for member targetKey

=cut

    my $this = shift;





    return $this->{targetKey};
}
sub setTargetKey {

=pod

=head3 $ConversionManager->setTargetKey (targetKey => "any string"*)

 - targetKey ("any string")		 : primarykey of target table 

setter for member targetKey

=cut

    my $this = shift;


    my $targetKey = shift;
    Confess "argument 'targetKey' is required for Sugar::ConversionManager->setTargetKey()" unless defined $targetKey;



    $this->{targetKey} = $targetKey;
    return $targetKey;
}



=pod

=head2 srcHandle => "any string"*

database handle for the source database

=cut

sub getSrcHandle {

=pod

=head3 $ConversionManager->getSrcHandle ()


getter for member srcHandle

=cut

    my $this = shift;





    return $this->{srcHandle};
}
sub setSrcHandle {

=pod

=head3 $ConversionManager->setSrcHandle (srcHandle => "any string"*)

 - srcHandle ("any string")		 : database handle for the source database

setter for member srcHandle

=cut

    my $this = shift;


    my $srcHandle = shift;
    Confess "argument 'srcHandle' is required for Sugar::ConversionManager->setSrcHandle()" unless defined $srcHandle;



    $this->{srcHandle} = $srcHandle;
    return $srcHandle;
}



=pod

=head2 targetHandle => "any string"*

database handle for the target database

=cut

sub getTargetHandle {

=pod

=head3 $ConversionManager->getTargetHandle ()


getter for member targetHandle

=cut

    my $this = shift;





    return $this->{targetHandle};
}
sub setTargetHandle {

=pod

=head3 $ConversionManager->setTargetHandle (targetHandle => "any string"*)

 - targetHandle ("any string")		 : database handle for the target database

setter for member targetHandle

=cut

    my $this = shift;


    my $targetHandle = shift;
    Confess "argument 'targetHandle' is required for Sugar::ConversionManager->setTargetHandle()" unless defined $targetHandle;



    $this->{targetHandle} = $targetHandle;
    return $targetHandle;
}



=pod

=head2 targetTable => "any string"*

target table name

=cut

sub getTargetTable {

=pod

=head3 $ConversionManager->getTargetTable ()


getter for member targetTable

=cut

    my $this = shift;





    return $this->{targetTable};
}
sub setTargetTable {

=pod

=head3 $ConversionManager->setTargetTable (targetTable => "any string"*)

 - targetTable ("any string")		 : target table name

setter for member targetTable

=cut

    my $this = shift;


    my $targetTable = shift;
    Confess "argument 'targetTable' is required for Sugar::ConversionManager->setTargetTable()" unless defined $targetTable;



    $this->{targetTable} = $targetTable;
    return $targetTable;
}



=pod

=head2 fieldMap => "any string"*

map of field conversions

=cut

sub getFieldMap {

=pod

=head3 $ConversionManager->getFieldMap ()


getter for member fieldMap

=cut

    my $this = shift;





    return $this->{fieldMap};
}
sub setFieldMap {

=pod

=head3 $ConversionManager->setFieldMap (fieldMap => "any string"*)

 - fieldMap ("any string")		 : map of field conversions

setter for member fieldMap

=cut

    my $this = shift;


    my $fieldMap = shift;
    Confess "argument 'fieldMap' is required for Sugar::ConversionManager->setFieldMap()" unless defined $fieldMap;



    $this->{fieldMap} = $fieldMap;
    return $fieldMap;
}



=pod

=head2 sugarFields => "any string"

special sugar field generation statements

=cut

sub getSugarFields {

=pod

=head3 $ConversionManager->getSugarFields ()


getter for member sugarFields

=cut

    my $this = shift;





    return $this->{sugarFields};
}
sub setSugarFields {

=pod

=head3 $ConversionManager->setSugarFields (sugarFields => "any string")

 - sugarFields ("any string")		 : special sugar field generation statements

setter for member sugarFields

=cut

    my $this = shift;


    my $sugarFields = shift;



    $this->{sugarFields} = $sugarFields;
    return $sugarFields;
}



=pod

=head2 moduleKeys => HASH

module keys from the conversion template

=cut

sub getModuleKeys {

=pod

=head3 $ConversionManager->getModuleKeys ()


getter for member moduleKeys

=cut

    my $this = shift;





    return $this->{moduleKeys};
}
sub setModuleKeys {

=pod

=head3 $ConversionManager->setModuleKeys (moduleKeys => HASH)

 - moduleKeys (HASH)		 : module keys from the conversion template

setter for member moduleKeys

=cut

    my $this = shift;


    my $moduleKeys = shift;
        if (defined $moduleKeys) { Confess "argument 'moduleKeys' of method Sugar::ConversionManager->setModuleKeys() is required to be of reference type HASH " unless ref($moduleKeys) =~ /^HASH/;}



    $this->{moduleKeys} = $moduleKeys;
    return $moduleKeys;
}



=pod

=head2 sugarModule => "any string"*

name of sugar module for code generation

=cut

sub getSugarModule {

=pod

=head3 $ConversionManager->getSugarModule ()


getter for member sugarModule

=cut

    my $this = shift;





    return $this->{sugarModule};
}
sub setSugarModule {

=pod

=head3 $ConversionManager->setSugarModule (sugarModule => "any string"*)

 - sugarModule ("any string")		 : name of sugar module for code generation

setter for member sugarModule

=cut

    my $this = shift;


    my $sugarModule = shift;
    Confess "argument 'sugarModule' is required for Sugar::ConversionManager->setSugarModule()" unless defined $sugarModule;



    $this->{sugarModule} = $sugarModule;
    return $sugarModule;
}



=pod

=head2 customFields => ARRAY

array of descriptors of custom fields metadata.

=cut

sub getCustomFields {

=pod

=head3 $ConversionManager->getCustomFields ()


getter for member customFields

=cut

    my $this = shift;





    return $this->{customFields};
}
sub setCustomFields {

=pod

=head3 $ConversionManager->setCustomFields (customFields => ARRAY)

 - customFields (ARRAY)		 : array of descriptors of custom fields metadata.

setter for member customFields

=cut

    my $this = shift;


    my $customFields = shift;
        if (defined $customFields) { Confess "argument 'customFields' of method Sugar::ConversionManager->setCustomFields() is required to be of reference type ARRAY " unless ref($customFields) =~ /^ARRAY/;}



    $this->{customFields} = $customFields;
    return $customFields;
}



=pod

=head2 formattedFields => HASH

map of formatted fields by position

=cut

sub getFormattedFields {

=pod

=head3 $ConversionManager->getFormattedFields ()


getter for member formattedFields

=cut

    my $this = shift;





    return $this->{formattedFields};
}
sub setFormattedFields {

=pod

=head3 $ConversionManager->setFormattedFields (formattedFields => HASH)

 - formattedFields (HASH)		 : map of formatted fields by position

setter for member formattedFields

=cut

    my $this = shift;


    my $formattedFields = shift;
        if (defined $formattedFields) { Confess "argument 'formattedFields' of method Sugar::ConversionManager->setFormattedFields() is required to be of reference type HASH " unless ref($formattedFields) =~ /^HASH/;}



    $this->{formattedFields} = $formattedFields;
    return $formattedFields;
}



=pod

=head2 maxFormattedRows => "any string"

max row of formatted fields by position

=cut

sub getMaxFormattedRows {

=pod

=head3 $ConversionManager->getMaxFormattedRows ()


getter for member maxFormattedRows

=cut

    my $this = shift;





    return $this->{maxFormattedRows};
}
sub setMaxFormattedRows {

=pod

=head3 $ConversionManager->setMaxFormattedRows (maxFormattedRows => "any string")

 - maxFormattedRows ("any string")		 : max row of formatted fields by position

setter for member maxFormattedRows

=cut

    my $this = shift;


    my $maxFormattedRows = shift;



    $this->{maxFormattedRows} = $maxFormattedRows;
    return $maxFormattedRows;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $ConversionManager->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $ConversionManager->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from ConversionManager.pm.m80 by 
bweinraub on li264-192 (Linux li264-192 2.6.35.4-x86_64-linode16 #1 SMP Mon Sep 20 16:03:34 UTC 2010 x86_64 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $ConversionManager->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



}


################################################################################

sub getSelectFields {
   
=pod

=head3 $ConversionManager->getSelectFields ()


returns a list of fields for the select statement of the sourceTable

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->getSelectFields requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	my $ret;
	my %fieldMap = %{$this->getFieldMap()};
	foreach my $key (keys (%fieldMap)) {
	    my %mapDescriptor = %{$fieldMap{$key}};
	    my $_tmp;
	    next if $mapDescriptor{notes};
	    $_tmp = ($mapDescriptor{type} =~ /smalldate/ ? "$key" :
		     ($mapDescriptor{type} =~ /date/ ? "to_char($key, 'YYYY-MM-DD HH24:MI:SS')" : $key)) . " $key";
	    $ret .= ", " if $ret;
	    $ret .= $_tmp;
	}
	$ret;
    };
}

################################################################################

sub genUpdateString {
   
=pod

=head3 $ConversionManager->genUpdateString (data => "any string"*, custom => "any string")

 - data ("any string")		 : data to process
 - custom ("any string")		 : data to process

generates an update string for updating a target row with source data based on the targetKey

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->genUpdateString requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for Sugar::ConversionManager->genUpdateString()" unless exists $args{data};
    my $custom = $args{custom};



    do {
	my $targetTable = $this->getTargetTable() . ($custom ? "_cstm" : "");
	my $sql = "
update  $targetTable
set 
";
	my %fieldMap = %{$this->getFieldMap()};

	my $_sql;
	foreach my $key (keys (%fieldMap)) {
	    my %mapDescriptor = %{$fieldMap{$key}};
	    $this->debugPrint(2, "mapDescriptor is " . Dumper(%mapDescriptor));
	    next if $custom and ! $mapDescriptor{custom};
	    if ($mapDescriptor{notes}) {
		$this->debugPrint(2, "field $key skipped because " . $mapDescriptor{notes});
		next;
	    } 
	    if ($custom) {
		my $conversion = $this->equivalence(target => lc($key) . "_c",
						    data => $data->item($key),
						    map => \%mapDescriptor);
		if ($conversion) {
		    $_sql .= ",\n" if $_sql;
		    $_sql .= $conversion;
		}
	    } else {
		my $sugarField = $mapDescriptor{sugarField};
		if ($sugarField) {
		    if (! $mapDescriptor{primarykey}) {
			my $conversion = $this->equivalence(target => $sugarField,
							    data => $data->item($key),
							    map => \%mapDescriptor);
			if ($conversion) {
			    $_sql .= ",\n" if $_sql;
			    $_sql .= $conversion;
			}
		    }
		}
	    }
	}
	unless ($custom) {
	    if ($this->getSugarFields()) {
		my %sugarFields = %{$this->getSugarFields()};

		foreach my $key (keys (%sugarFields)) {
		    my $_evalstr;
		    my $__evalstr = '$_evalstr = ' . $sugarFields{$key}->{code};
		    eval $__evalstr;
		    Confess "$__evalstr died with $@" if $@;

		    $this->debugPrint(1, "evaled magic code for sugar field $key as $_evalstr");
		    if ($_evalstr) {
			$_sql .= ",\n" if $_sql;
			$_sql .= "\t$key = " . $_evalstr;
		    }
		}
	    }
	}
	$sql .= $_sql;
	my $sugarKey = $this->getSugarKey (data => $data->item(uc($this->getSourceKey())));
	$this->debugPrint (2, "sugar source key is $sugarKey");
	$sql .= "\nwhere\t" . $this->getTargetKey() . ($custom ? "_c" : "") . " = '" . $sugarKey. "'";

	$this->debugPrint(3, "EMAIL is " . $fieldMap{EMAIL});
	$this->debugPrint(2, "mapped fields are  " . keys %fieldMap);
	$this->debugPrint(2, "sql is $sql");
	$sql;
    };
}


################################################################################

sub equivalence {
   
=pod

=head3 $ConversionManager->equivalence (data => "any string"*, target => "any string"*, map => "any string"*)

 - data ("any string")		 : data to process
 - target ("any string")		 : target field name
 - map ("any string")		 : map description

generates an equivalence clause as part of an update statement based on metadata

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->equivalence requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for Sugar::ConversionManager->equivalence()" unless exists $args{data};
    my $target = $args{target};
    Confess "argument 'target' is required for Sugar::ConversionManager->equivalence()" unless exists $args{target};
    my $map = $args{map};
    Confess "argument 'map' is required for Sugar::ConversionManager->equivalence()" unless exists $args{map};



    do {
	my $ret;
	$this->debugPrint(2, "args are " . Dumper(%args));
	if ( ! $map->{type} or $map->{type} =~ /date/ or $map->{type} =~ /dropdown/i or $map->{type} =~ /text/ ) {
	    $ret = "\t$target = " . SQLStringify(data => $map->{prepend} . $data) ;
	} elsif ($map->{type} =~ /deleted/i) {
	    $ret = "\t$target = " . ($data =~ /yes/i ? 1 : 0);
	}
# 	} elsif ($map->{type} =~ /float/) {
# 	    $ret = "\t$target = $data" ;
# 	}
	$this->debugPrint (1, "skipping field $target as type $map->{type} is not implemented");
	$ret;
    };
}

sub firstWord {
    my $data = shift;
    $data =~ s/(.+?)\s.*/$1/;
    $data;
}

sub secondWord {
    my $data = shift;
    $data =~ s/.+?\s(.*)/$1/;
    $data;
}


################################################################################

sub sugarModuleFile {
   
=pod

=head3 $ConversionManager->sugarModuleFile (file => "any string"*, type => "any string"*)

 - file ("any string")		 : data to process
 - type ("any string")		 : location in the sugar tree (default: "modules")

returns the path to sugar file

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->sugarModuleFile requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $file = $args{file};
    Confess "argument 'file' is required for Sugar::ConversionManager->sugarModuleFile()" unless exists $args{file};
    my $type = ($args{type} ? $args{type} : "modules");
    Confess "argument 'type' is required for Sugar::ConversionManager->sugarModuleFile()" unless exists $args{type};



    do {
	if ($type =~ /modules/) {
	    return $ENV{SugarHtdocs_srcPath} . "/$type/" . $this->getSugarModule() . "/" . $file;
	} elsif ($type =~ /modlang/) {
	    return $ENV{SugarHtdocs_srcPath} . "/custom/modules/" . $this->getSugarModule() . "/language/" . $file;
	} elsif ($type =~ /custlang/) {
	    return $ENV{SugarHtdocs_srcPath} . "/custom/include/language/" . $file;
	} else {
	    Confess "unimplemented type $type";
	}
    };
}

use FileHandle;

################################################################################

sub generatedFileFH {
    my $file = shift;
    
    my $fh = new FileHandle;
    $fh->open("< $file");
    $fh;
}


################################################################################

sub deriveCustomFieldData {
   
=pod

=head3 $ConversionManager->deriveCustomFieldData (doFormatting => "any string")

 - doFormatting ("any string")		 : says to look for cell formatting statements in the conversion map

derive all the necessary data to generate sugar data

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->deriveCustomFieldData requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $doFormatting = $args{doFormatting};



    do {
	my @customFields = ();
	my %formattedFields = ();
	my $maxFormattedRows = 0;

	my %fieldMap = %{$this->getFieldMap()};
	my $targetTable = lc($this->getTargetTable());
	my $srcHandle = $this->getSrcHandle();
	my $targetHandle = $this->getTargetHandle();

	foreach my $sourceKey (keys (%fieldMap)) {
	    my %mapDescriptor = %{$fieldMap{$sourceKey}};
	    if ($mapDescriptor{custom}) {
		$this->debugPrint(1, "working with custom field $sourceKey");
		my $type = $mapDescriptor{type};

		my $_lckey = lc($sourceKey);
		my $sugarKey = $_lckey . "_c";

		if ($type =~ /text/ or $type =~ /dropdown/i or $type =~ /date/ or $type =~ /float/) {
		    my $alterTableName = $targetHandle->SQLAlterString (data => $this->getCustomTable());
		    my $alterColumnName = $targetHandle->SQLAlterString(data => lc($sugarKey));
		    

		    my $md = $srcHandle->tableMetaData(table => $this->getSourceTable(),
						       column => $sourceKey);
		    $this->debugPrint(2, "metadata: " . Dumper($md));

		    my $dataTypeFull; 
		    my $dataType;
		    my $precision;
		    my $fixedLength = $mapDescriptor{fixedLength};  # override defined length for this field

		    if ($md) {
			$dataTypeFull = $targetHandle->getTypeAsText(data => $md, 
								     full => 't',
								     fixedLength => $fixedLength);
			$dataType = $targetHandle->getTypeAsText(data => $md);
			$precision = $md->getPrecision();
		    } else {
			$dataTypeFull = $mapDescriptor{mysqlType};
			my $_dataType = $dataTypeFull;
			$_dataType =~ /(.+?)\((.+?)\)/;
			$dataType = $1;
			$precision = $2;

		    }
		    Confess "cannot derive data type of field $sourceKey" unless
			$dataTypeFull and $dataType;

		    my $targetKey = $targetTable . "_" . $sugarKey;
		    my $cf = Sugar::CustomField->new(sourceKey => $sourceKey,
						     mapDescriptor => \%mapDescriptor,
						     type => $type,
						     sugarKey => $sugarKey,
						     alterTableName => $alterTableName,
						     alterColumnName => $alterColumnName,
						     targetHandle => $targetHandle,
						     metaData => $md,
						     dataType => $dataType,
						     dataTypeFull => $dataTypeFull,
						     targetKey => $targetKey,
						     targetTable => $targetTable,
						     fixedLength  => $fixedLength,
						     precision => $precision);

		    if ($doFormatting) {
			if ($mapDescriptor{fmt}) {
			    my ($row, $col) = split (/,/,$mapDescriptor{fmt});
			    $this->debugPrint(1, "found formatting of $row,$col for field $sourceKey");
			    $formattedFields{$row}{$col} = $cf;
			    if ($mapDescriptor{genSeparator}) {
				$cf->setGenSeparator($mapDescriptor{genSeparator});
				$this->debugPrint(1, "setting gen separator for field $sourceKey");
			    }
			    $maxFormattedRows = ($row > $maxFormattedRows) ? $row : $maxFormattedRows;
			} else {
			    Warn "Invalid or missing formatting field for field $sourceKey " ;
			}
		    }
		    push (@customFields, $cf);
		} else {
		    Confess "skipping unknown custom type: $type, " . Dumper(%mapDescriptor);
		}
	    }
	    
	}
	$this->setCustomFields(\@customFields);
	if ($doFormatting) {
	    $this->setFormattedFields(\%formattedFields);
	    $this->setMaxFormattedRows($maxFormattedRows);
	}
    };
}

################################################################################

sub generateSchema {
   
=pod

=head3 $ConversionManager->generateSchema ()


generate schema updates for custom fields

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->generateSchema requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	my @customFields= @{$this->getCustomFields()};
	$this->debugPrint(3, "custom fields are " . Dumper(@customFields));

	my $sugarModule = $this->getSugarModule();
	my $fileOpen;
	my $fh = new FileHandle;
	my $_createStmt = 0;
	foreach my $cf (@customFields) {
	    my %mapDescriptor = %{$cf->getMapDescriptor()};
	    my $targetTable = $cf->getTargetTable();
	    my $sourceKey = $cf->getSourceKey();
	    my $type = $cf->getType();
	    my $sugarKey = $cf->getSugarKey();
	    my $alterTableName = $cf->getAlterTableName();
	    my $alterColumnName = $cf->getAlterColumnName();
	    my $md = $cf->getMetaData();
	    my $targetKey = $cf->getTargetKey();
	    my $dataType = $cf->getDataType(); 
	    my $precision = $cf->getPrecision();
	    my $fixedLength = $cf->getFixedLength();

	    my $columnLength = $fixedLength ? $fixedLength : $precision;

	    $this->debugPrint(1, "working with custom field $targetKey");

	    $fh->open (" > " . $targetTable . "_schema.sql")
		unless ($fileOpen++);
	    $this->debugPrint(1, "working with custom field $sourceKey");
	    my $alter = ($_createStmt++ ? "" : "create table $alterTableName ( id_c char(36) );\n");     
#	    $alter .= "alter table $alterTableName drop $alterColumnName ;\n";
	    $alter .= "alter table $alterTableName  add $alterColumnName";
  	    $alter .= " " . $cf->getDataTypeFull() . ";\n";

	    $alter .= "alter table $alterTableName  modify $alterColumnName";
	    $alter .= " " . $cf->getDataTypeFull() . ";\n";

	    $alter .= "  delete from fields_meta_data
  where id = '$targetKey'
  and   custom_module = '$sugarModule';

  insert into fields_meta_data 
  (
  	id, 
  	name, 
  	label, 
  	help, 
  	custom_module, 
  	data_type, 
  	max_size, 
        ext1,
  	date_modified, 
  	deleted, 
  	mass_update
  ) values (
  	'$targetKey',
  	'$sugarKey',
  	'$sugarKey',
  	'',
  	'$sugarModule',
";
	    if ($type =~ /text/) {
		$alter .= "  	'varchar',
  	$columnLength,
        null,
";
            } elsif ($type =~ /dropdown/i) {
		$alter .= "  	'enum',
  	null,
        'dropdown_$sugarKey',
";
            } elsif ($type =~ /date/) {
		$alter .= "  	'date',
        null,
        null,
";
            } elsif ($type =~ /float/) {
		$alter .= "  	'float',
        null,
        null,
";

            } else {
		Confess "unknown custom type $type, ". Dumper(%mapDescriptor);
            }
	    $alter .= "  	now(),
  	0,
  	1
  );
";
	    $this->debugPrint(1, "$alter");
	    print $fh $alter;
        }
 	eval {close ($fh);};
    };
}


################################################################################

sub generateSugarCode {
   
=pod

=head3 $ConversionManager->generateSugarCode (doFormatting => "any string", file => "any string"*, useModule => "any string", fileType => "any string"*)

 - doFormatting ("any string")		 : says to look for cell formatting statements in the conversion map
 - file ("any string")		 : sugar file to generate
 - useModule ("any string")		 : look for the module name in the generated code lines
 - fileType ("any string")		 : type of sugar file to generate

generates the sugar code for a particular sugar file

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->generateSugarCode requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $doFormatting = $args{doFormatting};
    my $file = $args{file};
    Confess "argument 'file' is required for Sugar::ConversionManager->generateSugarCode()" unless exists $args{file};
    my $useModule = $args{useModule};
    my $fileType = $args{fileType};
    Confess "argument 'fileType' is required for Sugar::ConversionManager->generateSugarCode()" unless exists $args{fileType};



    do {
	my @customFields= @{$this->getCustomFields()};

 	my $filename = $this->sugarModuleFile(file => $file, type=> $fileType);
	my @lines = `cat $filename`;
	my @preGenLines = ();
	my @postGenLines = ();
	my $state = 0;

	my $startText = "BEGIN " . ($useModule ? $this->getSugarModule() . " "  : "" ) . "GENERATED CODE";
	my $endText = "END " . ($useModule ? $this->getSugarModule() . " " : "" ) . "GENERATED CODE";
	$this->debugPrint(1, "startText is $startText");
	$this->debugPrint(1, "endText is $endText");

	foreach my $line (@lines) {
	    if ($line =~ /$startText/) {
		$state++;
		push (@preGenLines, $line);
		next;
	    } elsif ($line =~ /$endText/) {
		push (@postGenLines, $line);
		$state++;
		next;
	    } else {
		if ($state > 1) {
		    push (@postGenLines, $line);
		} elsif ($state == 0) {
		    push (@preGenLines, $line);
		}
	    }
	}

	Confess "Failed to find generated code line anywhere in $file of $fileType ($filename)"
	    unless $state > 0;
		    
########### end parse #######


	
	my @genLines = ();
	my @javaScriptLines = ();

	my $moduleKeys = $this->getModuleKeys();
	my $ndx = $moduleKeys->{sugarCustomInfo}->{startRows}->{$file};

	my %formattedFields;
	my $maxRow = 0;
	if ($doFormatting and ($file =~ /Edit/ or $file =~ /Detail/)) {
	    my %formattedFields = %{$this->getFormattedFields};
	    for (my $i = 1 ; $i <= $this->getMaxFormattedRows(); $i++) {
		my $col = 1;

		push (@genLines, "	  <tr>\n") if ($col eq 1);
		my $cf;
		while (exists $formattedFields{$i}{$col}) {
		    $cf = $formattedFields{$i}{$col++};
		    
#### BEGIN MACRO suckDataFromDollarCF
        	    my %mapDescriptor = %{$cf->getMapDescriptor()};
        	    my $targetTable = $cf->getTargetTable();
        	    my $sourceKey = $cf->getSourceKey();
        	    my $type = $cf->getType();
        	    my $sugarKey = $cf->getSugarKey();
        	    my $alterTableName = $cf->getAlterTableName();
        	    my $alterColumnName = $cf->getAlterColumnName();
        	    my $md = $cf->getMetaData();
        	    my $targetKey = $cf->getTargetKey();
        	    my $dataType = $cf->getDataType(); 
        	    my $precision = $cf->getPrecision();
#### END MACRO suckDataFromDollarCF


		    dumpHtml ( ndx => $ndx++,
			       file => $file,
			       precision => $precision,
			       sugarKey => $sugarKey,
			       genLines => \@genLines,
			       javaScriptLines =>  \@javaScriptLines,
			       mapDescriptor => \%mapDescriptor,
			       type => $type );
		}
		push (@genLines, "	  </tr>\n");
		
		if (defined $cf) {
#		    $this->debugPrint(1, "looking for separator definition on key " . $cf->getSourceKey());
		    if ($cf->getGenSeparator()) {
			push (@genLines, '  <tr><td bgcolor="#000000"  colspan="6"></td></tr>'."\n");
			$this->debugPrint(1, "generated a separotor after key " . $cf->getSourceKey());
		    }
		}
	    }
	} else {
	    foreach my $cf (@customFields) {
		
#### BEGIN MACRO suckDataFromDollarCF
        	    my %mapDescriptor = %{$cf->getMapDescriptor()};
        	    my $targetTable = $cf->getTargetTable();
        	    my $sourceKey = $cf->getSourceKey();
        	    my $type = $cf->getType();
        	    my $sugarKey = $cf->getSugarKey();
        	    my $alterTableName = $cf->getAlterTableName();
        	    my $alterColumnName = $cf->getAlterColumnName();
        	    my $md = $cf->getMetaData();
        	    my $targetKey = $cf->getTargetKey();
        	    my $dataType = $cf->getDataType(); 
        	    my $precision = $cf->getPrecision();
#### END MACRO suckDataFromDollarCF

		if ($file =~ /Edit/ or $file =~ /Detail/) {
		    push (@genLines, "	  <tr>\n") if ($ndx % 2);
		    dumpHtml ( ndx => $ndx,
			       file => $file,
			       javaScriptLines =>  \@javaScriptLines,
			       sugarKey => $sugarKey,
			       precision => $precision,
			       mapDescriptor => \%mapDescriptor,
			       genLines => \@genLines,
			       type => $type );
		    push (@genLines, "	  </tr>\n") unless ($ndx++ % 2);
		} elsif ($file =~ /en_us.lang/) {
		    # come up w/ a label.
		    if ($fileType =~ /modlang/) {
			my $label = $mapDescriptor{label};
			$label =~ s/_/ /g;
			push (@genLines, "\$mod_strings['$sugarKey']='$label';\n");
		    } elsif ($fileType =~ /custlang/) {
			if ($type =~ /dropdown/i) {
			    my $dropdown = $mapDescriptor{dropdown};
			    push (@genLines, "\$app_list_strings['dropdown_$sugarKey']=array (\n");

			    unless ($dropdown) {
			    
				my $rs = $this->getSrcHandle()->newRowSet(sql => "select distinct $sourceKey from " . $this->getSourceTable() . " order by $sourceKey",
									  verbose => $main::debug);
				while ($rs->next()){
				    my $val = $rs->item(uc($sourceKey));
				    push (@genLines, "'$val' => '$val',\n");
				}
			    } else {
				$this->debugPrint (1, "loading dropdown list $dropdown for  field $sugarKey ");

				my $filename = dirname($0) .  "/dropdowns/$dropdown.php";
				open DROPDOWN,  "< $filename"
				    or Confess "failed  to open $filename";
				while (<DROPDOWN>) {
				    push (@genLines, $_);
				}
				close DROPDOWN;
			    }
			    push (@genLines, ");\n");
			}
		    }
		}
	    }
	    push (@genLines, "	  </tr>\n")
		if ($ndx and not ($ndx % 2));
	}

	my $fh = new FileHandle;
	$fh->open ( "> $filename.generated");

	foreach my $line (@preGenLines,@genLines,@javaScriptLines,@postGenLines) {
	    print $fh "$line";
	}
	close ($fh);
	$this->debugPrint(1, "finished writing $filename.generated");
    };
}

################################################################################

sub getCustomTable {
   
=pod

=head3 $ConversionManager->getCustomTable ()


returns the custom table name for this module

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->getCustomTable requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	$this->getTargetTable() . "_cstm";
    };
}


################################################################################

sub generateSugarCustomizations {
   
=pod

=head3 $ConversionManager->generateSugarCustomizations (doFormatting => "any string")

 - doFormatting ("any string")		 : says to look for cell formatting statements in the conversion map

uses the conversion map metadata and the source data to generate all the required sugar customization code

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->generateSugarCustomizations requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $doFormatting = $args{doFormatting};



    do {
	$this->deriveCustomFieldData(doFormatting => $doFormatting);
	$this->generateSchema();
	$this->generateSugarCode(file => "EditView.html", fileType=> "modules", doFormatting => $doFormatting);
	$this->generateSugarCode(file => "DetailView.html", fileType=> "modules", doFormatting => $doFormatting);
	$this->generateSugarCode(file => "en_us.lang.php", fileType=> "modlang", doFormatting => $doFormatting);
	$this->generateSugarCode(file => "en_us.lang.php", fileType=> "custlang", doFormatting => $doFormatting, useModule => 1);
    };
}


################################################################################

sub manageRelations {
   
=pod

=head3 $ConversionManager->manageRelations (data => "any string"*)

 - data ("any string")		 : data to process

manage many to many relationships

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->manageRelations requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for Sugar::ConversionManager->manageRelations()" unless exists $args{data};



    do {
	my %fieldMap = %{$this->getFieldMap()};
	my @relations;
	@relations = @{$this->getRelations()} if $this->getRelations();
	unless (@relations) {
# 	my $targetTable = lc($this->getTargetTable());
# 	my $srcHandle = $this->getSrcHandle();
# 	my $targetHandle = $this->getTargetHandle();

	    @relations = ();
	    foreach my $sourceKey (keys (%fieldMap)) {
		my %mapDescriptor = %{$fieldMap{$sourceKey}};
		push (@relations, $sourceKey)
		    if $mapDescriptor{type} =~ /relation/;
	    }
	    $this->setRelations(\@relations);
	}
	foreach my $key (@relations) {
	    my %mapDescriptor = %{$fieldMap{$key}};

	    my $sourceID = $this->getSugarKey(data=>$data->item(uc($this->getSourceKey())));
	    my $targetID = $mapDescriptor{prepend} . $data->item(uc($key));
	    my $newID = $sourceID . "_" . $targetID;
	    
	    my $sql = "
  insert into $mapDescriptor{tableName}
  (
    id,
    $mapDescriptor{sourceKey},
    $mapDescriptor{targetKey}
  ) values (
    '$newID',
    '$sourceID',
    '$targetID'
  );";
            my $dbhandle = $this->getTargetHandle();
	    $dbhandle->execute(sql => "  delete from $mapDescriptor{tableName} where id = '$newID'",
			       verbose => $main::debug);

	    eval {
		$dbhandle->execute(sql => $sql,
				   verbose => $main::debug);
	    };
	    Confess "sql threw $@" if $@;
	}

    };
}


################################################################################

sub getSugarKey {
   
=pod

=head3 $ConversionManager->getSugarKey (data => "any string"*)

 - data ("any string")		 : data to process

The mangled key is the moduleName + the original source key

=cut

    my $this = shift;

    Confess "Sugar::ConversionManager->getSugarKey requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for Sugar::ConversionManager->getSugarKey()" unless exists $args{data};



    do {
	return $this->getSugarModule() . "_$data";
    };
}


################################################################################

sub sugarNoteData {
   
=pod

=head3 $ConversionManager->sugarNoteData (data => "any string"*, type => "any string"*)

 - data ("any string")		 : data to process
 - type ("any string")		 : type of data to return

derives mapping from Inside Sales to Sugar Notes

=cut

    Confess "Sugar::ConversionManager::sugarNoteData requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for Sugar::ConversionManager::sugarNoteData()" unless defined $data;
    my $type = $args{type};
    Confess "argument 'type' is required for Sugar::ConversionManager::sugarNoteData()" unless defined $type;



    do {
	my $account_id = $data->item("ACCOUNT_ID");
	my $contact_id = $data->item("CONTACT_ID");
	my $deal_id = $data->item("DEAL_ID");
	my $lead_id = $data->item("LEAD_ID");

	debugPrint_s (2, "account_id: $account_id ; contact_id: $contact_id ; deal_id: $deal_id ; lead_id: $lead_id");

	if ($type =~ /parent_id/) {
	    if ($deal_id) {
		return "Cases_" . $deal_id;
	    } elsif ($account_id) {
		return "Accounts_" . $account_id;
	    } elsif ($contact_id) {
		return "Contacts_" . $contact_id;
	    } elsif ($lead_id) {
		return "Leads_" . $lead_id;
	    } else {
		debugPrint_s(1, "Failed to determine parent key for note " . $data->item("NOTE_ID"));
	    }
	} elsif ($type =~ /parent_type/) {
	    if ($deal_id) {
		return "Cases";
	    } elsif ($account_id) {
		return "Accounts";
	    } elsif ($contact_id) {
		return "Contacts";
	    } elsif ($lead_id) {
		return "Leads";
	    } 
	} else {
	    Confess "illegal type $type passed as argument";
	}
    };
}


################################################################################

sub setNoteMimeType {
   
=pod

=head3 $ConversionManager->setNoteMimeType (data => "any string"*)

 - data ("any string")		 : data to process

for sugar notes, sets the mime type

=cut

    Confess "Sugar::ConversionManager::setNoteMimeType requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for Sugar::ConversionManager::setNoteMimeType()" unless defined $data;



    do {
	return ($data and not $data =~ /N\/A/ ? "application/x-zip-compressed" : undef);
    };
}


################################################################################

sub setNoteFilename {
   
=pod

=head3 $ConversionManager->setNoteFilename (data => "any string"*)

 - data ("any string")		 : data to process

for sugar notes ... munge the is filename

=cut

    Confess "Sugar::ConversionManager::setNoteFilename requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for Sugar::ConversionManager::setNoteFilename()" unless defined $data;



    do {
	if (not $data =~ /N\/A/) {
	    $data =~ s/file_[0-9]+_//g;
	    return $data;
	} 
    };
}


################################################################################

sub dumpHtml {
   
=pod

=head3 $ConversionManager->dumpHtml (ndx => "any string"*, sugarKey => "any string"*, genLines => ARRAY*, javaScriptLines => ARRAY*, type => "any string"*, file => "any string"*, precision => "any string"*, mapDescriptor => "any string"*)

 - ndx ("any string")		 : HTML slot index
 - sugarKey ("any string")		 : sugar bean key reference
 - genLines (ARRAY)		 : reference to the generated lines array.  Data is pushed onto this reference
 - javaScriptLines (ARRAY)		 : reference to java  script code to be dumped at the end of the file
 - type ("any string")		 : type of field (text,dropdown,date,etc)
 - file ("any string")		 : sugar file that is being generated (edit, detail, etc).
 - precision ("any string")		 : precision derived for this field
 - mapDescriptor ("any string")		 : descriptor map from the conversion map file

generate HTML block for the Sugar Detail or Edit view html file

=cut

    Confess "Sugar::ConversionManager::dumpHtml requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $ndx = $args{ndx};
    Confess "argument 'ndx' is required for Sugar::ConversionManager::dumpHtml()" unless defined $ndx;
    my $sugarKey = $args{sugarKey};
    Confess "argument 'sugarKey' is required for Sugar::ConversionManager::dumpHtml()" unless defined $sugarKey;
    my $genLines = $args{genLines};
    Confess "argument 'genLines' is required for Sugar::ConversionManager::dumpHtml()" unless defined $genLines;
        if (defined $genLines) { Confess "argument 'genLines' of method Sugar::ConversionManager::dumpHtml() is required to be of reference type ARRAY " unless ref($genLines) =~ /^ARRAY/;}
    my $javaScriptLines = $args{javaScriptLines};
    Confess "argument 'javaScriptLines' is required for Sugar::ConversionManager::dumpHtml()" unless defined $javaScriptLines;
        if (defined $javaScriptLines) { Confess "argument 'javaScriptLines' of method Sugar::ConversionManager::dumpHtml() is required to be of reference type ARRAY " unless ref($javaScriptLines) =~ /^ARRAY/;}
    my $type = $args{type};
    Confess "argument 'type' is required for Sugar::ConversionManager::dumpHtml()" unless defined $type;
    my $file = $args{file};
    Confess "argument 'file' is required for Sugar::ConversionManager::dumpHtml()" unless defined $file;
    my $precision = $args{precision};
    Confess "argument 'precision' is required for Sugar::ConversionManager::dumpHtml()" unless defined $precision;
    my $mapDescriptor = $args{mapDescriptor};
    Confess "argument 'mapDescriptor' is required for Sugar::ConversionManager::dumpHtml()" unless defined $mapDescriptor;



    do {
	debugPrint_s(2, "genLines: " . Dumper($genLines));
	if ($file =~ /Edit/) {
	    push (@{$genLines}, '	    <td class="dataLabel" colspan="1"><span sugar=\'slot' . $ndx . '\'>{MOD.' . $sugarKey . '}</span sugar=\'slot\'></td>' . "\n");
	    
	    if ($type =~ /text/) {
		my $columnLength = $mapDescriptor->{fixedLength} ? $mapDescriptor->{fixedLength} : $precision;
		push (@{$genLines}, "	    <td class=\"dataField\" colspan=\"1\"><span sugar='slot" . $ndx . "b'><input name=\"$sugarKey\" type=\"text\" tabindex='1' size='" . ($columnLength > 30 ? 30 : $columnLength) . "' maxlength='$columnLength' value=\"{" . uc ($sugarKey) . "}\"></span sugar='slot'></td>\n");
	    } elsif ($type =~ /dropdown/i) {
		push (@{$genLines}, "	    <td  class=\"dataField\" colspan=\"1\"><span sugar='slot" . $ndx . "b'><select name=\"$sugarKey\" title=\"{".uc($sugarKey)."_HELP}\">{OPTIONS_".uc($sugarKey)."}</select></span sugar='slot'></td>\n");
	    } elsif  ($type =~ /date/i) {
		push (@{$genLines}, "       <td class=\"dataField\"><span sugar='slot" . $ndx . "b'> <input name='" . lc($sugarKey) . "' id='" . lc($sugarKey) . "' onblur=\"parseDate(this, '{CALENDAR_DATEFORMAT}');\" tabindex='1' maxlength='10' size='11' {READONLY} type=\"text\" value=\"{" . uc($sugarKey) . "}\"> <img src=\"themes/{THEME}/images/jscalendar.gif\" alt=\"{APP.LBL_ENTER_DATE}\"  id=\"" . lc($sugarKey) . "_trigger\" align=\"absmiddle\"> <span class=\"dateFormat\">{USER_DATEFORMAT}</span></span sugar='slot'></td>\n");

		# generate java script calendar for date fields.
		push (@{$javaScriptLines}, "
<script type=\"text/javascript\">
Calendar.setup ({
	inputField : \"" . lc($sugarKey) . "\", ifFormat : \"{CALENDAR_DATEFORMAT}\", showsTime : false, button : \"" . lc($sugarKey) . "_trigger\", singleClick : true, step : 1
});
</script>
<script type=\"text/javascript\">
	
function set_" . lc($sugarKey) . "_values(form) {
	if (form." . lc($sugarKey) . "_flag.checked) {
		form." . lc($sugarKey) . "_flag.value='on';
		form." . lc($sugarKey) . ".value=\"\";
		form.time_start.value=\"\";
		form." . lc($sugarKey) . ".readOnly=true;
		form.time_start.readOnly=true;
		if(typeof(form.start_meridiem) != 'undefined') form.start_meridiem.disabled=true;
		document.images." . lc($sugarKey) . "_trigger.width = 18;
		document.images." . lc($sugarKey) . "_trigger.height = 18;
	}
	else {
		form." . lc($sugarKey) . "_flag.value='off';
		form." . lc($sugarKey) . ".readOnly=false;
		form.time_start.readOnly=false;
		if(typeof(form.start_meridiem) != 'undefined') form.start_meridiem.disabled=false;
		document.images." . lc($sugarKey) . "_trigger.width = 18;
		document.images." . lc($sugarKey) . "_trigger.height = 18;
	}
}

set_" . lc($sugarKey) . "_values(document.EditView);
</script>
");
		
	    } else  {
		Confess "unknown type $type";
	    }
	} elsif ($file =~ /Detail/) {
	    
	    push (@{$genLines}, "  <td  valign=\"top\" valign=\"top\" class=\"tabDetailViewDL\" colspan=\"1\"><span sugar='slot" . $ndx . "'>{MOD.$sugarKey}</span sugar='slot'></td>\n");
	    push (@{$genLines}, "  <td  class=\"tabDetailViewDF\" colspan=\"1\"><span sugar='slot" . $ndx . "b'>{" . uc($sugarKey). "}</span sugar='slot'></td>\n");
	} else {
	    Confess "Unknown file type $file";
	}
	
	debugPrint_s(2, "genLines (after): " . Dumper($genLines));
    };
}

