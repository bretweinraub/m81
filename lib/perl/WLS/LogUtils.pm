


=pod

=head1 NAME - WLS::LogUtils

Utilites for working with "wlogs" and "tlogs" files.  These tools are really designed to run in the
task context of the test you are working with, although you can set things like M80_BDF and master_task_id in the object constructor.  But at the very
least you must be on the box which the logs are hosted.



=head1 EXAMPLE



  #
  # Accessing the logs for a managed server:
  #

  my $dbhandle = DB::OracleHandle->new(namespace => "CONTROLLER");   # You need a DB handle to derive a serverName from the task mapper.

  my $WLSLogManager = new WLS::LogUtils;                                        

  $WLSLogManager->deriveServerNameFromMapper (dbhandle => $dbhandle, # derives WLS server name from this task_id - useful for clusters
					      task_id => $task_id);

  my $FileHandle = $WLSLogManager->openServerOutLog(logNumber => 1); # opens the STDOUT file for this server.

  # 
  # You can also open any relative path with in the tlogs or wlogs:
  #

  my $LRReportFH = $WLSLogManager->openWlogFile(relativePath => "LRLogs/results/Perf_Report1.html");
  
  #
  # The Filehandle objects returned can be used like any <FILEHANDLE>
  #

  while ($line = <$LRReportFH>) {
      print $line;
  }



=cut

# This file was automatically generated from LogUtils.pm.m80 by 
# bweinraub on li264-192 (Linux li264-192 2.6.35.4-x86_64-linode16 #1 SMP Mon Sep 20 16:03:34 UTC 2010 x86_64 GNU/Linux)
# DO NOT EDIT THIS FILE 


package WLS::LogUtils;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use DB::RowSet;
use FileHandle;
use fields qw( master_task_id serverName logRoot M80_BDF wlogDirectory tlogDirectory debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item WLS::LogUtils->new()

initializes on object of type WLS::LogUtils

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{master_task_id} = {
          'name' => 'master_task_id',
          'default' => '$ENV{master_task_id}',
          'description' => 'master_task_id of this test - can be overriden for extreme debugging situations'
        }
;
$_allSetters{master_task_id} = \&setMaster_task_id;
$_allMemberAttributes{serverName} = {
          'name' => 'serverName',
          'type' => 'string',
          'description' => 'Name of this WLS server - can be derived from a task mapper using deriveServerNameFromMapper() - see the documentation for that method'
        }
;
$_allSetters{serverName} = \&setServerName;
$_allMemberAttributes{logRoot} = {
          'name' => 'logRoot',
          'default' => '/var/www/html',
          'description' => 'Root directory for all logs'
        }
;
$_allSetters{logRoot} = \&setLogRoot;
$_allMemberAttributes{M80_BDF} = {
          'name' => 'M80_BDF',
          'default' => '$ENV{M80_BDF}',
          'description' => 'M80 BDF (Build Descriptor File) descriptor for the environment that generated these logs'
        }
;
$_allSetters{M80_BDF} = \&setM80_BDF;
$_allMemberAttributes{wlogDirectory} = {
          'name' => 'wlogDirectory',
          'description' => 'the path to the wlogs directory'
        }
;
$_allSetters{wlogDirectory} = \&setWlogDirectory;
$_allMemberAttributes{tlogDirectory} = {
          'name' => 'tlogDirectory',
          'description' => 'the path to the tlogs directory'
        }
;
$_allSetters{tlogDirectory} = \&setTlogDirectory;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my WLS::LogUtils $this = shift;

    print STDERR "in WLS::LogUtils::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of WLS::LogUtils" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object WLS::LogUtils. typo ?\n";
        }
    }


    $this->{master_task_id} = $ENV{master_task_id} unless defined $this->{master_task_id};

    $this->{logRoot} = "/var/www/html" unless defined $this->{logRoot};

    $this->{M80_BDF} = $ENV{M80_BDF} unless defined $this->{M80_BDF};


    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {WLS::LogUtils::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?WLS::LogUtils::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {WLS::LogUtils::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?WLS::LogUtils::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 master_task_id => "any string" (default: $ENV{master_task_id})

master_task_id of this test - can be overriden for extreme debugging situations

=cut

sub getMaster_task_id {

=pod

=head3 $LogUtils->getMaster_task_id ()


getter for member master_task_id

=cut

    my $this = shift;





    return $this->{master_task_id};
}
sub setMaster_task_id {

=pod

=head3 $LogUtils->setMaster_task_id (master_task_id => "any string")

 - master_task_id ("any string")		 : master_task_id of this test - can be overriden for extreme debugging situations

setter for member master_task_id

=cut

    my $this = shift;


    my $master_task_id = shift;



    $this->{master_task_id} = $master_task_id;
    return $master_task_id;
}



=pod

=head2 serverName => "any string"

Name of this WLS server - can be derived from a task mapper using deriveServerNameFromMapper() - see the documentation for that method

=cut

sub getServerName {

=pod

=head3 $LogUtils->getServerName ()


getter for member serverName

=cut

    my $this = shift;





    return $this->{serverName};
}
sub setServerName {

=pod

=head3 $LogUtils->setServerName (serverName => "any string")

 - serverName ("any string")		 : Name of this WLS server - can be derived from a task mapper using deriveServerNameFromMapper() - see the documentation for that method

setter for member serverName

=cut

    my $this = shift;


    my $serverName = shift;



    $this->{serverName} = $serverName;
    return $serverName;
}



=pod

=head2 logRoot => "any string" (default: "/var/www/html")

Root directory for all logs

=cut

sub getLogRoot {

=pod

=head3 $LogUtils->getLogRoot ()


getter for member logRoot

=cut

    my $this = shift;





    return $this->{logRoot};
}
sub setLogRoot {

=pod

=head3 $LogUtils->setLogRoot (logRoot => "any string")

 - logRoot ("any string")		 : Root directory for all logs

setter for member logRoot

=cut

    my $this = shift;


    my $logRoot = shift;



    $this->{logRoot} = $logRoot;
    return $logRoot;
}



=pod

=head2 M80_BDF => "any string" (default: $ENV{M80_BDF})

M80 BDF (Build Descriptor File) descriptor for the environment that generated these logs

=cut

sub getM80_BDF {

=pod

=head3 $LogUtils->getM80_BDF ()


getter for member M80_BDF

=cut

    my $this = shift;





    return $this->{M80_BDF};
}
sub setM80_BDF {

=pod

=head3 $LogUtils->setM80_BDF (M80_BDF => "any string")

 - M80_BDF ("any string")		 : M80 BDF (Build Descriptor File) descriptor for the environment that generated these logs

setter for member M80_BDF

=cut

    my $this = shift;


    my $M80_BDF = shift;



    $this->{M80_BDF} = $M80_BDF;
    return $M80_BDF;
}



=pod

=head2 wlogDirectory => "any string"

the path to the wlogs directory

=cut

sub getWlogDirectory {

=pod

=head3 $LogUtils->getWlogDirectory ()


getter for member wlogDirectory

=cut

    my $this = shift;





    return $this->{wlogDirectory};
}
sub setWlogDirectory {

=pod

=head3 $LogUtils->setWlogDirectory (wlogDirectory => "any string")

 - wlogDirectory ("any string")		 : the path to the wlogs directory

setter for member wlogDirectory

=cut

    my $this = shift;


    my $wlogDirectory = shift;



    $this->{wlogDirectory} = $wlogDirectory;
    return $wlogDirectory;
}



=pod

=head2 tlogDirectory => "any string"

the path to the tlogs directory

=cut

sub getTlogDirectory {

=pod

=head3 $LogUtils->getTlogDirectory ()


getter for member tlogDirectory

=cut

    my $this = shift;





    return $this->{tlogDirectory};
}
sub setTlogDirectory {

=pod

=head3 $LogUtils->setTlogDirectory (tlogDirectory => "any string")

 - tlogDirectory ("any string")		 : the path to the tlogs directory

setter for member tlogDirectory

=cut

    my $this = shift;


    my $tlogDirectory = shift;



    $this->{tlogDirectory} = $tlogDirectory;
    return $tlogDirectory;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $LogUtils->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $LogUtils->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from LogUtils.pm.m80 by 
bweinraub on li264-192 (Linux li264-192 2.6.35.4-x86_64-linode16 #1 SMP Mon Sep 20 16:03:34 UTC 2010 x86_64 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $LogUtils->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "WLS::LogUtils->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    $this->setMaster_task_id( $ENV{wsrp_master_task_id} ) if $ENV{wsrp_master_task_id};
    $this->setWlogDirectory($this->getLogRoot() . "/" . $this->getM80_BDF() . "/wlogs/" . $this->getMaster_task_id());
    $this->setTlogDirectory($this->getLogRoot() . "/" . $this->getM80_BDF() . "/tlogs/" . $this->getMaster_task_id());
    Confess "cannot call WLS::LogUtils constructor without master_task_id defined"
	unless $this->getMaster_task_id();
}

sub deriveServerNameFromMapper {
   
=pod

=head3 $LogUtils->deriveServerNameFromMapper (dbhandle => "any string"*, task_id => "any string"*, verbose => "any string")

 - dbhandle ("any string")		 : DB::Handle to your db
 - task_id ("any string")		 : task_id - required
 - verbose ("any string")		 : set verbose SQL statements

convert a task mapper to the server name and then set the internal serverName field to the derived value.  Returns the derived value as well.

=cut

    my $this = shift;

    Confess "WLS::LogUtils->deriveServerNameFromMapper requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $dbhandle = $args{dbhandle};
    Confess "argument 'dbhandle' is required for WLS::LogUtils->deriveServerNameFromMapper()" unless exists $args{dbhandle};
    my $task_id = $args{task_id};
    Confess "argument 'task_id' is required for WLS::LogUtils->deriveServerNameFromMapper()" unless exists $args{task_id};
    my $verbose = $args{verbose};




   do {
       printmsg "(LogUtils::deriveServerNameFromMapper) deriving server name from your task mapper based on -mapper command line argument";
       Confess "cannot use -mapper unless \$task_id is set" unless $task_id;
       my %results = %{(DB::RowSet->new(dbh => $dbhandle->getDbh(),
					verbose => $verbose,
					sql => "select mapper from task where task_id = $task_id"))->getResults()};

       my ($mapper, $serverName);
       $mapper = $serverName = $results{MAPPER}[0];
       $serverName =~ s/(^[a-z])|(\/)|([^0-9A-Za-z])//g;                           # takes something like s/managedServer2_// and converts to managedServer2
       printmsg "(LogUtils::deriveServerNameFromMapper) derived server name of $serverName from $mapper";
       printmsg "(LogUtils::deriveServerNameFromMapper) WARNING: no server name could be derived from mapper" unless $serverName;
       return $this->setServerName($serverName);
   }
}

sub _openFileHandle {
    
=pod

=head3 $LogUtils->_openFileHandle (file2open => "any string"*)

 - file2open ("any string")		 : the file to open

generalized routine that returns a filehandle opened on a file, or throws a stack trace if the file cannot be opened

=cut

    my $this = shift;

    Confess "WLS::LogUtils->_openFileHandle requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $file2open = $args{file2open};
    Confess "argument 'file2open' is required for WLS::LogUtils->_openFileHandle()" unless exists $args{file2open};



 
  do {
      my $fh = 	  my $fh = new FileHandle;
      $fh->open ("< $file2open")
	  or Confess "cannot open $file2open: $@";
      printmsg "WLS::LogUtils successfully opened $file2open";
      return $fh;
  }								
}

sub openServerOutLog {
    
=pod

=head3 $LogUtils->openServerOutLog (logNumber => "any string"*)

 - logNumber ("any string")		 : 1 or 2

returns a filehandle to the server log

=cut

    my $this = shift;

    Confess "WLS::LogUtils->openServerOutLog requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $logNumber = $args{logNumber};
    Confess "argument 'logNumber' is required for WLS::LogUtils->openServerOutLog()" unless exists $args{logNumber};




    my ($wlogsDir, $serverName, $log2open);
    $wlogsDir = $this->getWlogDirectory()
	or Confess "Logic error ... no wlogDirectory was derived";

    $serverName = $this->getServerName() or
	Confess "openServerLog() cannot run without serverName member variable set.  Use deriveServerNameFromMapper() or setServerName() to set this variable";

    $log2open = $this->getWlogDirectory() . "/$serverName/$serverName.$logNumber";

    my $fh = $this->_openFileHandle(file2open => $log2open);
    return $fh;
}

sub openWlogFile {
    
=pod

=head3 $LogUtils->openWlogFile (relativePath => "any string"*)

 - relativePath ("any string")		 : relative path underneath the wlogs directory

returns a filehandle opened against any generic Wlog file

=cut

    my $this = shift;

    Confess "WLS::LogUtils->openWlogFile requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $relativePath = $args{relativePath};
    Confess "argument 'relativePath' is required for WLS::LogUtils->openWlogFile()" unless exists $args{relativePath};



    do {
	return $this->_openFileHandle(file2open => $this->getWlogDirectory() . "/" . $relativePath);
    }
}
