

=pod

=head1 NAME - Metadata::Object::ETLDescriptor

ETLDescriptor description; stub description please expand

=head1 EXAMPLE


    my $ETLDescriptor = $ETLDescriptor->new();   # stub example .... expand


=cut

# This file was automatically generated from ETLDescriptor.pm.m80 by 
# bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package Metadata::Object::ETLDescriptor;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}


use base qw(Metadata::Object);

=pod

=head1 INHERITANCE

Metadata::Object::ETLDescriptor extends class Metadata::Object ; refer to the documentation for that object for member variables and methods.

=cut

use fields qw( sourceRD columnNameTranslators targetRD transformation window crawlConfig typeTwoColumns debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item Metadata::Object::ETLDescriptor->new()

initializes on object of type Metadata::Object::ETLDescriptor

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{sourceRD} = {
          'required' => 1,
          'ref' => 'Metadata::Object::ETLResource',
          'name' => 'sourceRD',
          'description' => 'ETLResource for source resource'
        }
;
$_allSetters{sourceRD} = \&setSourceRD;
$_allMemberAttributes{columnNameTranslators} = {
          'ref' => 'ARRAY',
          'name' => 'columnNameTranslators',
          'description' => 'array of Metadata::Object::ColumnNameTranslator objects'
        }
;
$_allSetters{columnNameTranslators} = \&setColumnNameTranslators;
$_allMemberAttributes{targetRD} = {
          'required' => 1,
          'ref' => 'Metadata::Object::ETLResource',
          'name' => 'targetRD',
          'description' => 'ETLResource for target resource'
        }
;
$_allSetters{targetRD} = \&setTargetRD;
$_allMemberAttributes{transformation} = {
          'required' => 't',
          'name' => 'transformation',
          'description' => 'transformation type'
        }
;
$_allSetters{transformation} = \&setTransformation;
$_allMemberAttributes{window} = {
          'name' => 'window',
          'description' => 'window description'
        }
;
$_allSetters{window} = \&setWindow;
$_allMemberAttributes{crawlConfig} = {
          'name' => 'crawlConfig',
          'description' => 'crawler config'
        }
;
$_allSetters{crawlConfig} = \&setCrawlConfig;
$_allMemberAttributes{typeTwoColumns} = {
          'name' => 'typeTwoColumns',
          'description' => 'An list of names of columns from the source table that should be managed as type 2 changes'
        }
;
$_allSetters{typeTwoColumns} = \&setTypeTwoColumns;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my Metadata::Object::ETLDescriptor $this = shift;

    print STDERR "in Metadata::Object::ETLDescriptor::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of Metadata::Object::ETLDescriptor" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object Metadata::Object::ETLDescriptor. typo ?\n";
        }
    }


    Confess "cannot initialize object of type Metadata::Object::ETLDescriptor without required member variable sourceRD"
        unless exists $this->{sourceRD};

    Confess "cannot initialize object of type Metadata::Object::ETLDescriptor without required member variable targetRD"
        unless exists $this->{targetRD};

    Confess "cannot initialize object of type Metadata::Object::ETLDescriptor without required member variable transformation"
        unless exists $this->{transformation};


    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {Metadata::Object::ETLDescriptor::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Metadata::Object::ETLDescriptor::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {Metadata::Object::ETLDescriptor::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Metadata::Object::ETLDescriptor::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 sourceRD => Metadata::Object::ETLResource*

ETLResource for source resource

=cut

sub getSourceRD {

=pod

=head3 $Object::ETLDescriptor->getSourceRD ()


getter for member sourceRD

=cut

    my $this = shift;





    return $this->{sourceRD};
}
sub setSourceRD {

=pod

=head3 $Object::ETLDescriptor->setSourceRD (sourceRD => Metadata::Object::ETLResource*)

 - sourceRD (Metadata::Object::ETLResource)		 : ETLResource for source resource

setter for member sourceRD

=cut

    my $this = shift;


    my $sourceRD = shift;
    Confess "argument 'sourceRD' is required for Metadata::Object::ETLDescriptor->setSourceRD()" unless defined $sourceRD;
    eval {my $dummy = $sourceRD->isa("Metadata::Object::ETLResource");};Confess "$@\n" . Dumper($sourceRD) if $@;
    if (defined $sourceRD) { Confess "argument 'sourceRD' of method Metadata::Object::ETLDescriptor->setSourceRD() is required to be of reference type Metadata::Object::ETLResource, but it looks to be of type " . ref ($sourceRD)  unless $sourceRD->isa("Metadata::Object::ETLResource");}



    $this->{sourceRD} = $sourceRD;
    return $sourceRD;
}



=pod

=head2 columnNameTranslators => ARRAY

array of Metadata::Object::ColumnNameTranslator objects

=cut

sub getColumnNameTranslators {

=pod

=head3 $Object::ETLDescriptor->getColumnNameTranslators ()


getter for member columnNameTranslators

=cut

    my $this = shift;





    return $this->{columnNameTranslators};
}
sub setColumnNameTranslators {

=pod

=head3 $Object::ETLDescriptor->setColumnNameTranslators (columnNameTranslators => ARRAY)

 - columnNameTranslators (ARRAY)		 : array of Metadata::Object::ColumnNameTranslator objects

setter for member columnNameTranslators

=cut

    my $this = shift;


    my $columnNameTranslators = shift;
        if (defined $columnNameTranslators) { Confess "argument 'columnNameTranslators' of method Metadata::Object::ETLDescriptor->setColumnNameTranslators() is required to be of reference type ARRAY " unless ref($columnNameTranslators) =~ /^ARRAY/;}



    $this->{columnNameTranslators} = $columnNameTranslators;
    return $columnNameTranslators;
}



=pod

=head2 targetRD => Metadata::Object::ETLResource*

ETLResource for target resource

=cut

sub getTargetRD {

=pod

=head3 $Object::ETLDescriptor->getTargetRD ()


getter for member targetRD

=cut

    my $this = shift;





    return $this->{targetRD};
}
sub setTargetRD {

=pod

=head3 $Object::ETLDescriptor->setTargetRD (targetRD => Metadata::Object::ETLResource*)

 - targetRD (Metadata::Object::ETLResource)		 : ETLResource for target resource

setter for member targetRD

=cut

    my $this = shift;


    my $targetRD = shift;
    Confess "argument 'targetRD' is required for Metadata::Object::ETLDescriptor->setTargetRD()" unless defined $targetRD;
    eval {my $dummy = $targetRD->isa("Metadata::Object::ETLResource");};Confess "$@\n" . Dumper($targetRD) if $@;
    if (defined $targetRD) { Confess "argument 'targetRD' of method Metadata::Object::ETLDescriptor->setTargetRD() is required to be of reference type Metadata::Object::ETLResource, but it looks to be of type " . ref ($targetRD)  unless $targetRD->isa("Metadata::Object::ETLResource");}



    $this->{targetRD} = $targetRD;
    return $targetRD;
}



=pod

=head2 transformation => "any string"*

transformation type

=cut

sub getTransformation {

=pod

=head3 $Object::ETLDescriptor->getTransformation ()


getter for member transformation

=cut

    my $this = shift;





    return $this->{transformation};
}
sub setTransformation {

=pod

=head3 $Object::ETLDescriptor->setTransformation (transformation => "any string"*)

 - transformation ("any string")		 : transformation type

setter for member transformation

=cut

    my $this = shift;


    my $transformation = shift;
    Confess "argument 'transformation' is required for Metadata::Object::ETLDescriptor->setTransformation()" unless defined $transformation;



    $this->{transformation} = $transformation;
    return $transformation;
}



=pod

=head2 window => "any string"

window description

=cut

sub getWindow {

=pod

=head3 $Object::ETLDescriptor->getWindow ()


getter for member window

=cut

    my $this = shift;





    return $this->{window};
}
sub setWindow {

=pod

=head3 $Object::ETLDescriptor->setWindow (window => "any string")

 - window ("any string")		 : window description

setter for member window

=cut

    my $this = shift;


    my $window = shift;



    $this->{window} = $window;
    return $window;
}



=pod

=head2 crawlConfig => "any string"

crawler config

=cut

sub getCrawlConfig {

=pod

=head3 $Object::ETLDescriptor->getCrawlConfig ()


getter for member crawlConfig

=cut

    my $this = shift;





    return $this->{crawlConfig};
}
sub setCrawlConfig {

=pod

=head3 $Object::ETLDescriptor->setCrawlConfig (crawlConfig => "any string")

 - crawlConfig ("any string")		 : crawler config

setter for member crawlConfig

=cut

    my $this = shift;


    my $crawlConfig = shift;



    $this->{crawlConfig} = $crawlConfig;
    return $crawlConfig;
}



=pod

=head2 typeTwoColumns => "any string"

An list of names of columns from the source table that should be managed as type 2 changes

=cut

sub getTypeTwoColumns {

=pod

=head3 $Object::ETLDescriptor->getTypeTwoColumns ()


getter for member typeTwoColumns

=cut

    my $this = shift;





    return $this->{typeTwoColumns};
}
sub setTypeTwoColumns {

=pod

=head3 $Object::ETLDescriptor->setTypeTwoColumns (typeTwoColumns => "any string")

 - typeTwoColumns ("any string")		 : An list of names of columns from the source table that should be managed as type 2 changes

setter for member typeTwoColumns

=cut

    my $this = shift;


    my $typeTwoColumns = shift;



    $this->{typeTwoColumns} = $typeTwoColumns;
    return $typeTwoColumns;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $Object::ETLDescriptor->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $Object::ETLDescriptor->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from ETLDescriptor.pm.m80 by 
bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $Object::ETLDescriptor->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "Metadata::Object::ETLDescriptor->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	my $sourceRD = $this->getSourceRD();

	Confess "natural key must be defined when using the replicate or dimensional transformation"
	    if ($this->getTransformation() =~ /(replicate|dimensional)/i)
	    and not $sourceRD->getNaturalKey();

	Warn "typeTwoColumns only of interest for transformation type of dimensional"
	    if $this->getTransformation !~ /dimensional/i
	    and $this->getTypeTwoColumns();
    };
}
