


=pod

=head1 NAME - SetFrameworkPaths

A metadata filter that will correctly set variables like bea_home, domain_home, etc.

=head1 EXAMPLE



  use Metadata::Filters::SetFrameworkPaths;


  my $pga = new PropertyGroupAggregate;

  $pga->add (SetFrameworkPaths->new(name => "SetFrameworkPaths" ));


  # Stand-Alone Usage

  my $SetFrameworkPaths = $SetFrameworkPaths->new();   # stub example .... expand


  $SetFrameworkPaths->buildPath (object => $obj,
			  root => $test_root,
			  tag => "alihome",
			  value => "ali/foundation6");



=cut

# This file was automatically generated from SetFrameworkPaths.pm.m80 by 
# bweinraub on li264-192 (Linux li264-192 2.6.35.4-x86_64-linode16 #1 SMP Mon Sep 20 16:03:34 UTC 2010 x86_64 GNU/Linux)
# DO NOT EDIT THIS FILE 


package SetFrameworkPaths;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use Utils::FunctionalProgramming;

use base qw(MetadataFilter);

=pod

=head1 INHERITANCE

SetFrameworkPaths extends class MetadataFilter ; refer to the documentation for that object for member variables and methods.

=cut

use fields qw( debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item SetFrameworkPaths->new()

initializes on object of type SetFrameworkPaths

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my SetFrameworkPaths $this = shift;

    print STDERR "in SetFrameworkPaths::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of SetFrameworkPaths" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object SetFrameworkPaths. typo ?\n";
        }
    }



    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {SetFrameworkPaths::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?SetFrameworkPaths::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {SetFrameworkPaths::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?SetFrameworkPaths::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $SetFrameworkPaths->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $SetFrameworkPaths->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from SetFrameworkPaths.pm.m80 by 
bweinraub on li264-192 (Linux li264-192 2.6.35.4-x86_64-linode16 #1 SMP Mon Sep 20 16:03:34 UTC 2010 x86_64 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub __new {
    
=pod

=head3 $SetFrameworkPaths->__new ()


internal preconstructor to used to satisfy parent consructors data requirements (as in description)

=cut

    my $this = shift;

    Confess "SetFrameworkPaths->__new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    $this->setDescription("Recurses over all WLS objects and setups automation metadata like bea_home, domain_home, etc.");
}

sub _new {

=pod

=head3 $SetFrameworkPaths->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "SetFrameworkPaths->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    $this->setDescription("Recurses over all WLS objects and setups automation metadata like bea_home, domain_home, etc.");
}

sub execute {
    
=pod

=head3 $SetFrameworkPaths->execute (allObjects => ARRAY*)

 - allObjects (ARRAY)		 : array pointer to the complete metadata hierarchy passed to this filter

applies this filter to the metadata hierarchy in argument allObjects

=cut

    my $this = shift;

    Confess "SetFrameworkPaths->execute requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $allObjects = $args{allObjects};
    Confess "argument 'allObjects' is required for SetFrameworkPaths->execute()" unless exists $args{allObjects};
        if (defined $allObjects) { Confess "argument 'allObjects' of method SetFrameworkPaths->execute() is required to be of reference type ARRAY " unless ref($allObjects) =~ /^ARRAY/;}




						   
   my $wlversion;
   my @allObjects = @{$allObjects};

    my $wlversion = getObjects('WLVersion', @allObjects);
    my $portalperftest = getObjects('PortalPerfTest', @allObjects);

   foreach my $obj (@allObjects) {
       print STDERR ref($obj) . "\n";
       $_ = ref($obj); ## BAD! - this should look back through the @ISA
     SWITCH: {
	 /^ALIFoundationServer$/ && do {
	     my $test_root = $obj->{appServer}->{host}->{test_root};
	     my $osflavor = $obj->{appServer}->{host}->{osflavor};
	     my $object = $obj->{appServer}->{host};
	     printmsg "Found ALITestRoot as $test_root";

	     $this->buildPath (object => $object,
			       root => $test_root,
			       osflavor => $osflavor,
			       tag => "alihome",
			       value => "ali/foundation6");

	     $this->buildPath (object => $object,
			       root => $test_root,
			       osflavor => $osflavor,
			       tag => "ali_testhome",
			       value => "ali");

	     $this->buildPath (object => $object,
			       root => $test_root,
			       osflavor => $osflavor,
			       tag => "ali_installerhome",
			       value => "ali/installer");
	     last SWITCH;
	 };

	 /^(WLS8|)(Admin|Managed)Server$/ && do {
	     my $test_root = $obj->{host}->{test_root};
	     my $automation_root = $obj->{host}->{automation_root};
	     my $osflavor = $obj->{host}->{osflavor};
	     my $object = $obj->{host};

	     Confess "No such field host" unless $obj->{host};
             Confess "Cannot find WLVersion object" unless $wlversion;

	     
	     $this->buildPath (object => $object,
			       root => $test_root,
			       osflavor => $osflavor,
			       tag => "test_root",
			       value => "");

             if ($portalperftest) {
                 $test_root .= '/' . $portalperftest->{wl_installer_version};
             } else {
                 $test_root .= '/' . $wlversion->{wl_platform_version};
             }

	     
	     $this->buildPath (object => $object,
			       root => $test_root,
			       osflavor => $osflavor,
			       tag => "beahome",
			       value => "bea");

	     $this->buildPath (object => $object,
			       root => $test_root,
			       osflavor => $osflavor,
			       tag => "wlhome",
			       value => "bea/" . $wlversion->{wlhomeLabel} . $wlversion->{wl_platform_version});

	     $this->buildPath (object => $object,
			       root => $test_root,
			       osflavor => $osflavor,
			       tag => "testhome",
			       value => "");

	     if ($wlversion->{build_or_install} eq 'install') {
		 $this->buildPath(root =>$test_root, 
				  object => $object, 
				  osflavor => $osflavor,
				  tag => "installerhome", 
				  value => "installer");

		 $this->buildPath(root => $test_root, 
				  object => $object, 
				  osflavor => $osflavor,
				  tag => "devbranch", 
				  value => "dev/" . $wlversion->{beadev_branch_name});

		 $this->buildPath(root => $automation_root, 
				  object => $object, 
				  osflavor => $osflavor,
				  tag => "automation_root", 
				  value => "");

	     } else {
		 $this->buildPath(root => $automation_root, 
				  object => $object, 
				  osflavor => $osflavor,
				  tag => "devbranch", 
				  value => "dev/" . $wlversion->{beadev_branch_name});
	     }
	     
	     #
	     # domainhome - this still needs to be set on the fly as this isn't known until runtime.
	     # 

	     last SWITCH;
	     
	 }
	 
	 
     }
   }
################################################################################
#
# TODO: integrate the old "genPlatformSpecificPaths code. 
#
# Here is the block from loadAndAlterCollections.pl:
#
# rmapcar( sub { 
#     my ($obj) = @_;
#     return unless grep { /^host$/ } @{_isa(ref($obj))};

#     for my $tag (split /\s+/, $obj->{directoryTags}) {
#         my $value = $obj->{$tag};
#         if ($obj->{osflavor} eq 'windows') {
#             my ($winpath)  = mixedpath($value); # `$SSHCOMMAND $user@$host 'cygpath -m $value'`;
#             my ($unixpath) = unixpath($value);  # `$SSHCOMMAND $user@$host 'cygpath -u $value'`;
#             $obj->{$tag . '_windows'} = $winpath; # bypass mdo docs
#             $obj->{$tag . '_unix'   } = $unixpath; # bypass mdo docs
#         } else {
#             $obj->{$tag . '_unix'   } = $value; # bypass mdo docs
#         }

#         print STDERR "processing $tag - associated value is $value.\n", Dumper($obj), "\n";

#     }
# }, @allObjects );
#
################################################################################

    print BLUE . BOLD . "In MetadataFilter SetFrameworkPaths" . RESET . "\n";
}

