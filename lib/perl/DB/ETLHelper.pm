


=pod

=head1 NAME - DB::ETLHelper

ETLHelper description; stub description please expand

=head1 EXAMPLE


    my $ETLHelper = $ETLHelper->new();   # stub example .... expand


=cut

# This file was automatically generated from ETLHelper.pm.m80 by 
# bweinraub on li298-104 (Linux li298-104 2.6.38-linode31 #1 SMP Mon Mar 21 21:22:33 UTC 2011 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package DB::ETLHelper;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use DB::Table;
use DB::DBHandleFactory;
use DB::Utils;
use DB::DBHandle;
use fields qw( allObjects sourceNamespace sourceTableName sourcePrimaryKey sourceHandle sourceTable targetNamespace targetHandle targetTableName stageTableName targetTable stageTable columnNameTranslators noCreate sourceHandleUnneeded debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item DB::ETLHelper->new()

initializes on object of type DB::ETLHelper

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{allObjects} = {
          'name' => 'allObjects',
          'description' => 'ETLHelper derives  from the environment'
        }
;
$_allSetters{allObjects} = \&setAllObjects;
$_allMemberAttributes{sourceNamespace} = {
          'name' => 'sourceNamespace',
          'description' => 'Source namespace for ETL source descriptor'
        }
;
$_allSetters{sourceNamespace} = \&setSourceNamespace;
$_allMemberAttributes{sourceTableName} = {
          'name' => 'sourceTableName',
          'description' => 'table name in the sourceNamespace for this ETL'
        }
;
$_allSetters{sourceTableName} = \&setSourceTableName;
$_allMemberAttributes{sourcePrimaryKey} = {
          'name' => 'sourcePrimaryKey',
          'description' => 'primary key name in the sourceNamespace for this ETL'
        }
;
$_allSetters{sourcePrimaryKey} = \&setSourcePrimaryKey;
$_allMemberAttributes{sourceHandle} = {
          'ref' => 'DB::DBHandle',
          'name' => 'sourceHandle',
          'description' => 'DBHandle for the ETL source'
        }
;
$_allSetters{sourceHandle} = \&setSourceHandle;
$_allMemberAttributes{sourceTable} = {
          'ref' => 'DB::Table',
          'name' => 'sourceTable',
          'description' => 'metadata for the source ETL table'
        }
;
$_allSetters{sourceTable} = \&setSourceTable;
$_allMemberAttributes{targetNamespace} = {
          'name' => 'targetNamespace',
          'description' => 'target namespace for this ETL '
        }
;
$_allSetters{targetNamespace} = \&setTargetNamespace;
$_allMemberAttributes{targetHandle} = {
          'ref' => 'DB::DBHandle',
          'name' => 'targetHandle',
          'description' => 'stub description of targetHandle; please update'
        }
;
$_allSetters{targetHandle} = \&setTargetHandle;
$_allMemberAttributes{targetTableName} = {
          'name' => 'targetTableName',
          'description' => 'stub description of targetTableName; please update'
        }
;
$_allSetters{targetTableName} = \&setTargetTableName;
$_allMemberAttributes{stageTableName} = {
          'name' => 'stageTableName',
          'description' => 'stub description of stageTableName; please update'
        }
;
$_allSetters{stageTableName} = \&setStageTableName;
$_allMemberAttributes{targetTable} = {
          'name' => 'targetTable',
          'description' => 'stub description of targetTable; please update'
        }
;
$_allSetters{targetTable} = \&setTargetTable;
$_allMemberAttributes{stageTable} = {
          'ref' => 'DB::Table',
          'name' => 'stageTable',
          'description' => 'stub description of stageTable; please update'
        }
;
$_allSetters{stageTable} = \&setStageTable;
$_allMemberAttributes{columnNameTranslators} = {
          'name' => 'columnNameTranslators',
          'description' => 'any column name translators specified in the metadata'
        }
;
$_allSetters{columnNameTranslators} = \&setColumnNameTranslators;
$_allMemberAttributes{noCreate} = {
          'name' => 'noCreate',
          'description' => 'don\'t create table for this ETL'
        }
;
$_allSetters{noCreate} = \&setNoCreate;
$_allMemberAttributes{sourceHandleUnneeded} = {
          'name' => 'sourceHandleUnneeded',
          'description' => 'if set, don\'t bother connecting the source handle.  At a certain point ETL processes no longer need this connection, so this allows us to aviod needlessly connected to the source database.'
        }
;
$_allSetters{sourceHandleUnneeded} = \&setSourceHandleUnneeded;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my DB::ETLHelper $this = shift;

    print STDERR "in DB::ETLHelper::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of DB::ETLHelper" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object DB::ETLHelper. typo ?\n";
        }
    }



    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {DB::ETLHelper::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::ETLHelper::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {DB::ETLHelper::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::ETLHelper::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 allObjects => "any string"

ETLHelper derives  from the environment

=cut

sub getAllObjects {

=pod

=head3 $ETLHelper->getAllObjects ()


getter for member allObjects

=cut

    my $this = shift;





    return $this->{allObjects};
}
sub setAllObjects {

=pod

=head3 $ETLHelper->setAllObjects (allObjects => "any string")

 - allObjects ("any string")		 : ETLHelper derives  from the environment

setter for member allObjects

=cut

    my $this = shift;


    my $allObjects = shift;



    $this->{allObjects} = $allObjects;
    return $allObjects;
}



=pod

=head2 sourceNamespace => "any string"

Source namespace for ETL source descriptor

=cut

sub getSourceNamespace {

=pod

=head3 $ETLHelper->getSourceNamespace ()


getter for member sourceNamespace

=cut

    my $this = shift;





    return $this->{sourceNamespace};
}
sub setSourceNamespace {

=pod

=head3 $ETLHelper->setSourceNamespace (sourceNamespace => "any string")

 - sourceNamespace ("any string")		 : Source namespace for ETL source descriptor

setter for member sourceNamespace

=cut

    my $this = shift;


    my $sourceNamespace = shift;



    $this->{sourceNamespace} = $sourceNamespace;
    return $sourceNamespace;
}



=pod

=head2 sourceTableName => "any string"

table name in the sourceNamespace for this ETL

=cut

sub getSourceTableName {

=pod

=head3 $ETLHelper->getSourceTableName ()


getter for member sourceTableName

=cut

    my $this = shift;





    return $this->{sourceTableName};
}
sub setSourceTableName {

=pod

=head3 $ETLHelper->setSourceTableName (sourceTableName => "any string")

 - sourceTableName ("any string")		 : table name in the sourceNamespace for this ETL

setter for member sourceTableName

=cut

    my $this = shift;


    my $sourceTableName = shift;



    $this->{sourceTableName} = $sourceTableName;
    return $sourceTableName;
}



=pod

=head2 sourcePrimaryKey => "any string"

primary key name in the sourceNamespace for this ETL

=cut

sub getSourcePrimaryKey {

=pod

=head3 $ETLHelper->getSourcePrimaryKey ()


getter for member sourcePrimaryKey

=cut

    my $this = shift;





    return $this->{sourcePrimaryKey};
}
sub setSourcePrimaryKey {

=pod

=head3 $ETLHelper->setSourcePrimaryKey (sourcePrimaryKey => "any string")

 - sourcePrimaryKey ("any string")		 : primary key name in the sourceNamespace for this ETL

setter for member sourcePrimaryKey

=cut

    my $this = shift;


    my $sourcePrimaryKey = shift;



    $this->{sourcePrimaryKey} = $sourcePrimaryKey;
    return $sourcePrimaryKey;
}



=pod

=head2 sourceHandle => DB::DBHandle

DBHandle for the ETL source

=cut

sub getSourceHandle {

=pod

=head3 $ETLHelper->getSourceHandle ()


getter for member sourceHandle

=cut

    my $this = shift;





    return $this->{sourceHandle};
}
sub setSourceHandle {

=pod

=head3 $ETLHelper->setSourceHandle (sourceHandle => DB::DBHandle)

 - sourceHandle (DB::DBHandle)		 : DBHandle for the ETL source

setter for member sourceHandle

=cut

    my $this = shift;


    my $sourceHandle = shift;
    eval {my $dummy = $sourceHandle->isa("DB::DBHandle");};Confess "$@\n" . Dumper($sourceHandle) if $@;
    if (defined $sourceHandle) { Confess "argument 'sourceHandle' of method DB::ETLHelper->setSourceHandle() is required to be of reference type DB::DBHandle, but it looks to be of type " . ref ($sourceHandle)  unless $sourceHandle->isa("DB::DBHandle");}



    $this->{sourceHandle} = $sourceHandle;
    return $sourceHandle;
}



=pod

=head2 sourceTable => DB::Table

metadata for the source ETL table

=cut

sub getSourceTable {

=pod

=head3 $ETLHelper->getSourceTable ()


getter for member sourceTable

=cut

    my $this = shift;





    return $this->{sourceTable};
}
sub setSourceTable {

=pod

=head3 $ETLHelper->setSourceTable (sourceTable => DB::Table)

 - sourceTable (DB::Table)		 : metadata for the source ETL table

setter for member sourceTable

=cut

    my $this = shift;


    my $sourceTable = shift;
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::ETLHelper->setSourceTable() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}



    $this->{sourceTable} = $sourceTable;
    return $sourceTable;
}



=pod

=head2 targetNamespace => "any string"

target namespace for this ETL 

=cut

sub getTargetNamespace {

=pod

=head3 $ETLHelper->getTargetNamespace ()


getter for member targetNamespace

=cut

    my $this = shift;





    return $this->{targetNamespace};
}
sub setTargetNamespace {

=pod

=head3 $ETLHelper->setTargetNamespace (targetNamespace => "any string")

 - targetNamespace ("any string")		 : target namespace for this ETL 

setter for member targetNamespace

=cut

    my $this = shift;


    my $targetNamespace = shift;



    $this->{targetNamespace} = $targetNamespace;
    return $targetNamespace;
}



=pod

=head2 targetHandle => DB::DBHandle

stub description of targetHandle; please update

=cut

sub getTargetHandle {

=pod

=head3 $ETLHelper->getTargetHandle ()


getter for member targetHandle

=cut

    my $this = shift;





    return $this->{targetHandle};
}
sub setTargetHandle {

=pod

=head3 $ETLHelper->setTargetHandle (targetHandle => DB::DBHandle)

 - targetHandle (DB::DBHandle)		 : stub description of targetHandle; please update

setter for member targetHandle

=cut

    my $this = shift;


    my $targetHandle = shift;
    eval {my $dummy = $targetHandle->isa("DB::DBHandle");};Confess "$@\n" . Dumper($targetHandle) if $@;
    if (defined $targetHandle) { Confess "argument 'targetHandle' of method DB::ETLHelper->setTargetHandle() is required to be of reference type DB::DBHandle, but it looks to be of type " . ref ($targetHandle)  unless $targetHandle->isa("DB::DBHandle");}



    $this->{targetHandle} = $targetHandle;
    return $targetHandle;
}



=pod

=head2 targetTableName => "any string"

stub description of targetTableName; please update

=cut

sub getTargetTableName {

=pod

=head3 $ETLHelper->getTargetTableName ()


getter for member targetTableName

=cut

    my $this = shift;





    return $this->{targetTableName};
}
sub setTargetTableName {

=pod

=head3 $ETLHelper->setTargetTableName (targetTableName => "any string")

 - targetTableName ("any string")		 : stub description of targetTableName; please update

setter for member targetTableName

=cut

    my $this = shift;


    my $targetTableName = shift;



    $this->{targetTableName} = $targetTableName;
    return $targetTableName;
}



=pod

=head2 stageTableName => "any string"

stub description of stageTableName; please update

=cut

sub getStageTableName {

=pod

=head3 $ETLHelper->getStageTableName ()


getter for member stageTableName

=cut

    my $this = shift;





    return $this->{stageTableName};
}
sub setStageTableName {

=pod

=head3 $ETLHelper->setStageTableName (stageTableName => "any string")

 - stageTableName ("any string")		 : stub description of stageTableName; please update

setter for member stageTableName

=cut

    my $this = shift;


    my $stageTableName = shift;



    $this->{stageTableName} = $stageTableName;
    return $stageTableName;
}



=pod

=head2 targetTable => "any string"

stub description of targetTable; please update

=cut

sub getTargetTable {

=pod

=head3 $ETLHelper->getTargetTable ()


getter for member targetTable

=cut

    my $this = shift;





    return $this->{targetTable};
}
sub setTargetTable {

=pod

=head3 $ETLHelper->setTargetTable (targetTable => "any string")

 - targetTable ("any string")		 : stub description of targetTable; please update

setter for member targetTable

=cut

    my $this = shift;


    my $targetTable = shift;



    $this->{targetTable} = $targetTable;
    return $targetTable;
}



=pod

=head2 stageTable => DB::Table

stub description of stageTable; please update

=cut

sub getStageTable {

=pod

=head3 $ETLHelper->getStageTable ()


getter for member stageTable

=cut

    my $this = shift;





    return $this->{stageTable};
}
sub setStageTable {

=pod

=head3 $ETLHelper->setStageTable (stageTable => DB::Table)

 - stageTable (DB::Table)		 : stub description of stageTable; please update

setter for member stageTable

=cut

    my $this = shift;


    my $stageTable = shift;
    eval {my $dummy = $stageTable->isa("DB::Table");};Confess "$@\n" . Dumper($stageTable) if $@;
    if (defined $stageTable) { Confess "argument 'stageTable' of method DB::ETLHelper->setStageTable() is required to be of reference type DB::Table, but it looks to be of type " . ref ($stageTable)  unless $stageTable->isa("DB::Table");}



    $this->{stageTable} = $stageTable;
    return $stageTable;
}



=pod

=head2 columnNameTranslators => "any string"

any column name translators specified in the metadata

=cut

sub getColumnNameTranslators {

=pod

=head3 $ETLHelper->getColumnNameTranslators ()


getter for member columnNameTranslators

=cut

    my $this = shift;





    return $this->{columnNameTranslators};
}
sub setColumnNameTranslators {

=pod

=head3 $ETLHelper->setColumnNameTranslators (columnNameTranslators => "any string")

 - columnNameTranslators ("any string")		 : any column name translators specified in the metadata

setter for member columnNameTranslators

=cut

    my $this = shift;


    my $columnNameTranslators = shift;



    $this->{columnNameTranslators} = $columnNameTranslators;
    return $columnNameTranslators;
}



=pod

=head2 noCreate => "any string"

don't create table for this ETL

=cut

sub getNoCreate {

=pod

=head3 $ETLHelper->getNoCreate ()


getter for member noCreate

=cut

    my $this = shift;





    return $this->{noCreate};
}
sub setNoCreate {

=pod

=head3 $ETLHelper->setNoCreate (noCreate => "any string")

 - noCreate ("any string")		 : don't create table for this ETL

setter for member noCreate

=cut

    my $this = shift;


    my $noCreate = shift;



    $this->{noCreate} = $noCreate;
    return $noCreate;
}



=pod

=head2 sourceHandleUnneeded => "any string"

if set, don't bother connecting the source handle.  At a certain point ETL processes no longer need this connection, so this allows us to aviod needlessly connected to the source database.

=cut

sub getSourceHandleUnneeded {

=pod

=head3 $ETLHelper->getSourceHandleUnneeded ()


getter for member sourceHandleUnneeded

=cut

    my $this = shift;





    return $this->{sourceHandleUnneeded};
}
sub setSourceHandleUnneeded {

=pod

=head3 $ETLHelper->setSourceHandleUnneeded (sourceHandleUnneeded => "any string")

 - sourceHandleUnneeded ("any string")		 : if set, don't bother connecting the source handle.  At a certain point ETL processes no longer need this connection, so this allows us to aviod needlessly connected to the source database.

setter for member sourceHandleUnneeded

=cut

    my $this = shift;


    my $sourceHandleUnneeded = shift;



    $this->{sourceHandleUnneeded} = $sourceHandleUnneeded;
    return $sourceHandleUnneeded;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $ETLHelper->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $ETLHelper->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from ETLHelper.pm.m80 by 
bweinraub on li298-104 (Linux li298-104 2.6.38-linode31 #1 SMP Mon Mar 21 21:22:33 UTC 2011 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $ETLHelper->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "DB::ETLHelper->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do { 
	our @allObjects;

	my $_x=$main::debug;
	require "Metadata/LoadCollections.pl";
	$main::debug=$_x;                                                                # LoadCollections.pl can mess with $main::debug ;

	use strict;

	my $sourceNamespace=$ENV{$ENV{sourceDB} . "_m80namespace"};
	$this->setSourceNamespace($sourceNamespace);
	Confess "failed to derive sourceNamespace"
	    unless $sourceNamespace;

	my $sourceTableName=$ENV{$ENV{sourceRD} . "_tableName"};
	$this->setSourceTableName($sourceTableName);
	Confess "failed to derive sourceTableName"
	    unless $sourceTableName;

	my $sourcePrimaryKey = $ENV{$ENV{sourceRD} . "_naturalKey"};
	$this->setSourcePrimaryKey($sourcePrimaryKey);

	my $sourceTable ;

	unless ($this->getSourceHandleUnneeded()) {
	    my $sourceHandle = DB::DBHandleFactory::newDBHandle(namespace => $sourceNamespace);
	    $this->setSourceHandle($sourceHandle);
	    Confess "failed to derive sourceHandle"
		unless $sourceHandle;

	    if ($sourcePrimaryKey) {
		$sourceTable = $sourceHandle->newTable(name => $sourceTableName,
						       primaryKeyName => $sourcePrimaryKey);
	    } else {
		$sourceTable = $sourceHandle->newTable(name => $sourceTableName);
	    }
	    
	    $this->setSourceTable($sourceTable);
	    Confess "failed to derive sourceTable"
		unless $sourceTable;
	}

	my $targetNamespace=$ENV{$ENV{targetDB} . "_m80namespace"};
	$this->setTargetNamespace($targetNamespace);
	Confess "failed to derive targetNamespace"
	    unless $targetNamespace;

	my $targetHandle = DB::DBHandleFactory::newDBHandle(namespace => $targetNamespace);
	$this->setTargetHandle($targetHandle);
	Confess "failed to derive targetHandle"
	    unless $targetHandle;

	my $targetTableName=$ENV{$ENV{targetRD} . "_tableName"};
	$this->setTargetTableName($targetTableName);
	Confess "failed to derive targetTableName"
	    unless $targetTableName;

	my $stageTableName = $targetTableName . "_stg";
	$this->setStageTableName($stageTableName);
	Confess "failed to derive stageTableName"
	    unless $stageTableName;

	my $columnNameTranslators = $ENV{"columnNameTranslators"};
	$this->setColumnNameTranslators($columnNameTranslators);	

	$this->createETLTables()
	    unless $this->getSourceHandleUnneeded();

	my $targetTable = $targetHandle->newTable(name => $targetTableName);
	$this->setTargetTable($targetTable);
	Confess "failed to derive targetTable"
	    unless $targetTable;

	my $stageTable = $targetHandle->newTable(name => $stageTableName);
	$this->setStageTable($stageTable);
	Confess "failed to derive stageTable"
	    unless $stageTable;

	rectifySchemas(sourceTable => $sourceTable, targetTable => $stageTable);
	rectifySchemas(sourceTable => $sourceTable, targetTable => $targetTable);
    };
}

################################################################################

sub createETLTables {
   
=pod

=head3 $ETLHelper->createETLTables ()


creates the required staging and destination tables

=cut

    my $this = shift;

    Confess "DB::ETLHelper->createETLTables requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	createTables(dbhandle => $this->getTargetHandle(), 
		     sourceTable => $this->getSourceTable(), 
		     columnNameTranslators => $this->getColumnNameTranslators(),
		     targetTableNames => [$this->getTargetTableName(), $this->getStageTableName()]) unless $this->getNoCreate();

    };
}

