



=pod

=head1 NAME - DB::OracleHandle

Wrapper for an Oracle DBIDatabase Handle.

=head1 EXAMPLE

No example(s) have been documented for this object.

=cut

# This file was automatically generated from OracleHandle.pm.m80 by 
# bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package DB::OracleHandle;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use DBI;
use Metadata::Object::ColumnNameTranslator;
use Utils::PerlTools;

use base qw(DB::DBHandle);

=pod

=head1 INHERITANCE

DB::OracleHandle extends class DB::DBHandle ; refer to the documentation for that object for member variables and methods.

=cut

use fields qw( SID port debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item DB::OracleHandle->new()

initializes on object of type DB::OracleHandle

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{SID} = {
          'name' => 'SID',
          'description' => 'SID for the oracle instance to connect to'
        }
;
$_allSetters{SID} = \&setSID;
$_allMemberAttributes{port} = {
          'format' => '\\d+',
          'name' => 'port',
          'description' => 'port for the oracle instance to connect to'
        }
;
$_allSetters{port} = \&setPort;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my DB::OracleHandle $this = shift;

    print STDERR "in DB::OracleHandle::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of DB::OracleHandle" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object DB::OracleHandle. typo ?\n";
        }
    }



    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {DB::OracleHandle::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::OracleHandle::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {DB::OracleHandle::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::OracleHandle::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 SID => "any string"

SID for the oracle instance to connect to

=cut

sub getSID {

=pod

=head3 $OracleHandle->getSID ()


getter for member SID

=cut

    my $this = shift;





    return $this->{SID};
}
sub setSID {

=pod

=head3 $OracleHandle->setSID (SID => "any string")

 - SID ("any string")		 : SID for the oracle instance to connect to

setter for member SID

=cut

    my $this = shift;


    my $SID = shift;



    $this->{SID} = $SID;
    return $SID;
}



=pod

=head2 port => "\d+"

port for the oracle instance to connect to

=cut

sub getPort {

=pod

=head3 $OracleHandle->getPort ()


getter for member port

=cut

    my $this = shift;





    return $this->{port};
}
sub setPort {

=pod

=head3 $OracleHandle->setPort (port => "\d+")

 - port ("\d+")		 : port for the oracle instance to connect to

setter for member port

=cut

    my $this = shift;


    my $port = shift;
        if (defined $port) { Confess "argument 'port' of method DB::OracleHandle->setPort() failed format validation of '\d+'" unless $port =~ /\d+/;}



    $this->{port} = $port;
    return $port;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $OracleHandle->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $OracleHandle->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from OracleHandle.pm.m80 by 
bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {
    
=pod

=head3 $OracleHandle->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "DB::OracleHandle->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    Confess "required member variable SID not set" unless $this->getSID();
    $this->setConnectString("dbi:Oracle:host=" . $this->getHost() . ";sid=" . $this->getSID() . ";port=" . $this->getPort() );
    $this->connect();
}

################################################################################
#
# for Oracle you can use the same handle
#
################################################################################

sub getMDHandle {
   
=pod

=head3 $OracleHandle->getMDHandle ()


spins off a new DB handle for a different database or schema

=cut

    my $this = shift;

    Confess "DB::OracleHandle->getMDHandle requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	$this;
    };
}


################################################################################

sub cloneUnlessExists {
   
=pod

=head3 $OracleHandle->cloneUnlessExists (sourceTable => DB::Table*, name => "any string"*, suppressM80 => "any string")

 - sourceTable (DB::Table)		 : table to clone
 - name ("any string")		 : name of table to create
 - suppressM80 ("any string")		 : don't add in the m80 magic columns

clone this table unless the destination table already exists.  This method also initializes a DB::Table object and returns it.

=cut

    my $this = shift;

    Confess "DB::OracleHandle->cloneUnlessExists requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $sourceTable = $args{sourceTable};
    Confess "argument 'sourceTable' is required for DB::OracleHandle->cloneUnlessExists()" unless exists $args{sourceTable};
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::OracleHandle->cloneUnlessExists() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}
    my $name = $args{name};
    Confess "argument 'name' is required for DB::OracleHandle->cloneUnlessExists()" unless exists $args{name};
    my $suppressM80 = $args{suppressM80};



    do {
# TODO: we should really be rectifying schema differences at this point.
	$this->clone(sourceTable => $sourceTable,
		     suppressM80 => $suppressM80,
		     name => $name)
	    unless $this->tableExists(name => "$name");

	$this->newTable (name => $name);
    };
}

################################################################################
#
# TODO:
# 1. We should be generated the following for these tables:
# 1a.  Primary Key
# 1b.  Primary Key sequence
# 1c.  Insert and updated date triggers       
# 1d.  Inserted and updated data field.


################################################################################

sub createTable {
    
=pod

=head3 $OracleHandle->createTable (name => "any string"*, columns => HASH*, columnNameTranslators => "any string", prefixDateColumns => "any string", instantiationTable => "any string", noexec => "any string", drop => "any string", suppressM80 => "any string")

 - name ("any string")		 : table name to create
 - columns (HASH)		 : hash of column records for the generated table
 - columnNameTranslators ("any string")		 : translation description for column names that need to be converted
 - prefixDateColumns ("any string")		 : text to prefix to generated data columns
 - instantiationTable ("any string")		 : do not generate alternate key .... AKA 'instantiation' of an object
 - noexec ("any string")		 : print but do not execute
 - drop ("any string")		 : attempt to drop existing objects
 - suppressM80 ("any string")		 : don't add in the m80 magic columns

generates a database table, maybe with m80 extensions

=cut

    my $this = shift;

    Confess "DB::OracleHandle->createTable requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $name = $args{name};
    Confess "argument 'name' is required for DB::OracleHandle->createTable()" unless exists $args{name};
    my $columns = $args{columns};
    Confess "argument 'columns' is required for DB::OracleHandle->createTable()" unless exists $args{columns};
        if (defined $columns) { Confess "argument 'columns' of method DB::OracleHandle->createTable() is required to be of reference type HASH " unless ref($columns) =~ /^HASH/;}
    my $columnNameTranslators = $args{columnNameTranslators};
    my $prefixDateColumns = $args{prefixDateColumns};
    my $instantiationTable = $args{instantiationTable};
    my $noexec = $args{noexec};
    my $drop = $args{drop};
    my $suppressM80 = $args{suppressM80};



    do {
	my $sql = "create table $name (\n";

	$this->debugPrint (1, "creating " . ($suppressM80 ? "non" : "" ) . " m80 table $name");

	# add primary key 

	my $numColumns = 0;
	
	unless ($suppressM80) {
	    $sql .= "\t$name" . "_id number(10) not null";
	    $numColumns++;
	}

	my %columns = %{$columns};

	foreach my $columnName (keys(%columns)) {
	    $this->debugPrint (2, "processing column name $columnName");
	    my $newColumn = $this->getTypeAsText(data => $columns{$columnName},
						 full => 't');
	    $this->debugPrint (2, "found $columnName: $newColumn");
	    $sql .= ($numColumns++ ? ",\n" : "") . 
		$this->validColumnName(data => $columnName, 
				       columnNameTranslators => $columnNameTranslators) . "\t\t\t$newColumn";
	}
	
	unless ($suppressM80) {
	    $sql .= ",\n";
	    $sql .= $prefixDateColumns . "INSERTED_DT date not null,\n";
	    $sql .= $prefixDateColumns . "UPDATED_DT date ,\n";
	    $sql .= "constraint $name" . "_pk primary key ($name" .  "_id)";
	}

	$sql .= ")";

	$this->debugPrint (0, "preparing to create table $name");
	$this->debugPrint (2, " sql statement is $sql");

	return if $noexec;

	$this->dropTable(name => "$name") if $drop;

	$this->execute(sql => $sql);

	unless ($suppressM80) {
	    $this->PLSQLBlock (sql => "drop sequence $name" . "_s",
			       ignore => ArrayRef(-2289)) if $drop;
	    $this->PLSQLBlock (sql => "create sequence $name" . "_S increment by 5 start with 1",
			       ignore => ArrayRef(-955));
	    $this->createM80Triggers(name => $name,
				     prefixDateColumns => $prefixDateColumns);
	}
	$this->debugPrint (0, "created table $name");

    };
}

################################################################################

sub createM80Triggers {
   
=pod

=head3 $OracleHandle->createM80Triggers (name => "any string"*, prefixDateColumns => "any string")

 - name ("any string")		 : table name to create
 - prefixDateColumns ("any string")		 : text to prefix to generated data columns

create standard m80 triggers

=cut

    my $this = shift;

    Confess "DB::OracleHandle->createM80Triggers requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $name = $args{name};
    Confess "argument 'name' is required for DB::OracleHandle->createM80Triggers()" unless exists $args{name};
    my $prefixDateColumns = $args{prefixDateColumns};




#
# TODO: There is one fundamental problem here.  For long running transaction, there could be a delay between
# the inserted  or updated date and the  actual time the row appears to parallel transactions (like data warehouse-esque)
# row scraping.  
#
# One option would be to use an after trigger, but that has its own challenges.  Specifically an after trigger
# cannot alter the :new or :old values in the trigger:
#
# http://blogs.ittoolbox.com/oracle/jochenvdv/archives/after-triggers-the-truth-is-out-there-17415
#
# A better alternative would to create an audit table which would be updated based on an after trigger.
#
# AUDIT ( sourceTable varchar,
#         sourceKey varchar,
#         sourceUser varchar,
#         inserted_dt date,
#         updated_dt data )
#

    do {
	$this->execute(sql => "
create or replace trigger " . $name . "_I
before insert on " . $name . "
for each row
declare
begin
   if DBMS_REPUTIL.FROM_REMOTE = FALSE THEN

     IF :new." . $name . "_id IS NULL THEN
         SELECT " . $name . "_S.NEXTVAL INTO :new." . $name . "_id FROM DUAL; 
     END IF;
     :new." . $prefixDateColumns . "inserted_dt := SYSDATE;
   end if;
end;");
	$this->execute(sql => "
create or replace trigger " . $name . "_U
before update on " . $name . "
for each row
declare
begin
   if DBMS_REPUTIL.FROM_REMOTE = FALSE THEN
     :new." . $prefixDateColumns . "updated_dt := SYSDATE;
   end if;
end;
");

    };
}

################################################################################

sub dropTable {
    
=pod

=head3 $OracleHandle->dropTable (name => "any string"*)

 - name ("any string")		 : table to drop

drop a table

=cut

    my $this = shift;

    Confess "DB::OracleHandle->dropTable requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $name = $args{name};
    Confess "argument 'name' is required for DB::OracleHandle->dropTable()" unless exists $args{name};



    do {
	$this->PLSQLBlock(sql => "drop table $name",
			  ignore => ArrayRef(-942));	
    };
}

################################################################################

sub PLSQLBlock {
   
=pod

=head3 $OracleHandle->PLSQLBlock (sql => "any string"*, ignore => ARRAY)

 - sql ("any string")		 : sql to execute inside a sql block
 - ignore (ARRAY)		 : ignore these exceptions

execute a PLSQL block with ignored exceptions

=cut

    my $this = shift;

    Confess "DB::OracleHandle->PLSQLBlock requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $sql = $args{sql};
    Confess "argument 'sql' is required for DB::OracleHandle->PLSQLBlock()" unless exists $args{sql};
    my $ignore = $args{ignore};
        if (defined $ignore) { Confess "argument 'ignore' of method DB::OracleHandle->PLSQLBlock() is required to be of reference type ARRAY " unless ref($ignore) =~ /^ARRAY/;}



    do {
	$this->execute(sql => _PLSQLBlock(@_));
    };
}
    
################################################################################

sub _PLSQLBlock {
   
=pod

=head3 $OracleHandle->_PLSQLBlock (sql => "any string"*, ignore => ARRAY)

 - sql ("any string")		 : sql to execute inside a sql block
 - ignore (ARRAY)		 : ignore these exceptions

returns the code for a PLSQL block

=cut

    Confess "DB::OracleHandle::_PLSQLBlock requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $sql = $args{sql};
    Confess "argument 'sql' is required for DB::OracleHandle::_PLSQLBlock()" unless defined $sql;
    my $ignore = $args{ignore};
        if (defined $ignore) { Confess "argument 'ignore' of method DB::OracleHandle::_PLSQLBlock() is required to be of reference type ARRAY " unless ref($ignore) =~ /^ARRAY/;}



    do {
	my $ret;
	my @ignore = @{$ignore};
	if ($ignore) {
	    $ret .= "DECLARE\n";
	    for (my $i = 0 ; $i < $#ignore + 1; $i++) {
		$ret.= "   ignored_exception$i exception;\n";
		$ret .= "   PRAGMA EXCEPTION_INIT(ignored_exception$i, $ignore[$i]);\n";
	    }
	}
	$ret .= "BEGIN\n";
	$ret .= "   execute immediate '$sql';\n";
	$ret .= "EXCEPTION\n";
	for (my $i = 0 ; $i < $#ignore + 1; $i++) {
	    $ret .= "   WHEN ignored_exception$i THEN\n";
	    $ret .= "     NULL;\n";
	}
	$ret .= "END;\n";

	$ret;
    };
}

################################################################################

# useful: http://www.indiana.edu/~dss/Services/DataWarehouse/Oracle/Sybase/conversion.html

sub getTypeAsText {
    
=pod

=head3 $OracleHandle->getTypeAsText (data => DB::FieldMetaData*, full => "any string", fixedLength => "any string")

 - data (DB::FieldMetaData)		 : data to process
 - full ("any string")		 : return a full SQL create statement worthy string
 - fixedLength ("any string")		 : force column length based on this argument

return the type variable as a text field

=cut

    my $this = shift;

    Confess "DB::OracleHandle->getTypeAsText requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->getTypeAsText()" unless exists $args{data};
    eval {my $dummy = $data->isa("DB::FieldMetaData");};Confess "$@\n" . Dumper($data) if $@;
    if (defined $data) { Confess "argument 'data' of method DB::OracleHandle->getTypeAsText() is required to be of reference type DB::FieldMetaData, but it looks to be of type " . ref ($data)  unless $data->isa("DB::FieldMetaData");}
    my $full = $args{full};
    my $fixedLength = $args{fixedLength};



    do {
	my $type = $data->getType();
	my $length = $fixedLength ? $fixedLength : $data->getPrecision();
	$this->debugPrint (1, $data->getName() . " type " . $data->getType() . " precision " . $length . " scale " . $data->getScale());
	my $ret;

	if ($type == 1) {
	    $ret = "CHAR". ($full ? "(" . $length . ")" : "") ;
	} elsif ($type eq -4 or $type eq 40 or $type == -1) {
	    $ret = "CLOB";
	} elsif ($type == 12) {
	    $ret = "VARCHAR2". ($full ? "(" . $length . ")" : "") ;
	} elsif ($type == 8 or $type == 6) { # type 6 is a MSSql/Sybase float
	    $ret = "FLOAT";
	} elsif ($type == 11 or $type == 93 or $type == 9 or $type == 91) {
	    $ret = "DATE";
	} elsif ($type eq -6 or $type == 3 or $type == 7 or $type == 4 or $type == 5) {
	    my $dataHandle = $data->getHandle();
	    if ($dataHandle->can("DBIPrecisionToGenericPrecision")) {
		eval {
		    $ret = "NUMBER" . ($full ? "(" . $dataHandle->DBIPrecisionToGenericPrecision(data => $length) . ")" : "");
		};
		Confess "$@" if $@;

	    } else { # not sure why we get here .... but on ProvideX data sources we do :(  Maybe because we can't create the object
		# because there's no DBD::ODBC on this box?  That's my guess.....
		$ret = "NUMBER" . ($full ? "(" . $length . ")" : "");
	    }
	} elsif ($type eq -5) { # mysql BigINT
	    $ret = "NUMBER(20)";
	} elsif ($type eq -7) {
	    $ret = "CHAR(1)";
	} else {
	    Confess "field type $type not implemented for column " . $data->getName();
	}
	return $ret;
    };
}

################################################################################

sub bindParam {
   
=pod

=head3 $OracleHandle->bindParam (data => DB::FieldMetaData*, sourceTable => DB::Table, dateFormat => "any string")

 - data (DB::FieldMetaData)		 : data to process
 - sourceTable (DB::Table)		 : truncate this table if set
 - dateFormat ("any string")		 : can be used to specify the date format used in the input (default: "YYYY-MM-DD HH24:MI:SS")

returns the appropriate bind param syntax for a type

=cut

    my $this = shift;

    Confess "DB::OracleHandle->bindParam requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->bindParam()" unless exists $args{data};
    eval {my $dummy = $data->isa("DB::FieldMetaData");};Confess "$@\n" . Dumper($data) if $@;
    if (defined $data) { Confess "argument 'data' of method DB::OracleHandle->bindParam() is required to be of reference type DB::FieldMetaData, but it looks to be of type " . ref ($data)  unless $data->isa("DB::FieldMetaData");}
    my $sourceTable = $args{sourceTable};
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::OracleHandle->bindParam() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "YYYY-MM-DD HH24:MI:SS");



    do {
	$this->debugPrint (2, "examining " . $data->getName() . " : " . $this->getTypeAsText(data => $data));

	if ( $this->getTypeAsText(data => $data) =~ /DATE/i) {
	    
	    my $sourceField = $sourceTable ? $sourceTable->getColumns()->{$data->getName()} : undef;
	    my $_dateFormat = $sourceField 
		? ($sourceField->getDateFormat() 
		   ? $sourceField->getDateFormat()
		   : $dateFormat) 
		: $dateFormat;
	    
	    $this->debugPrint (1, "found DATE " . $data->getName() . " : " . $_dateFormat );

	    return "to_date (? , '" . ($_dateFormat) . "')";
	}
	return "?";
    };
}

################################################################################

sub selectParam {
   
=pod

=head3 $OracleHandle->selectParam (data => DB::FieldMetaData*, dateFormat => "any string")

 - data (DB::FieldMetaData)		 : data to process
 - dateFormat ("any string")		 : can be used to specify the date format used in the input (default: "YYYY-MM-DD HH24:MI:SS")

returns the appropriate select param syntax for a type

=cut

    my $this = shift;

    Confess "DB::OracleHandle->selectParam requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->selectParam()" unless exists $args{data};
    eval {my $dummy = $data->isa("DB::FieldMetaData");};Confess "$@\n" . Dumper($data) if $@;
    if (defined $data) { Confess "argument 'data' of method DB::OracleHandle->selectParam() is required to be of reference type DB::FieldMetaData, but it looks to be of type " . ref ($data)  unless $data->isa("DB::FieldMetaData");}
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "YYYY-MM-DD HH24:MI:SS");



    do {
	my $name=$data->getName();
	$this->debugPrint (3, "examining " . $name . " : " . $this->getTypeAsText(data => $data));

	return "to_char (" . $name . " , '$dateFormat') " . $name
	    if $this->getTypeAsText(data => $data) =~ /DATE/i;
	return $name;
    };
}

################################################################################

sub maxColumnLength {
   
=pod

=head3 $OracleHandle->maxColumnLength ()


returns the maximum column length for this DBHandle

=cut

    my $this = shift;

    Confess "DB::OracleHandle->maxColumnLength requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    30;
}


################################################################################

sub getDefaultDateFormat {
    
=pod

=head3 $OracleHandle->getDefaultDateFormat ()


returns the default date format for this RDBMS

=cut

    my $this = shift;

    Confess "DB::OracleHandle->getDefaultDateFormat requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	'YYYY-MM-DD HH24:MI:SS';
    };
}

################################################################################

sub scrubBindData {
   
=pod

=head3 $OracleHandle->scrubBindData (data => "any string"*, field => "any string")

 - data ("any string")		 : data to process
 - field ("any string")		 : field metadata for the data

when binding data to an insert or update statement, this routine is called to pre-scrub the data.  Handles simple migration issues between RDBM(s)

=cut

    my $this = shift;

    Confess "DB::OracleHandle->scrubBindData requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->scrubBindData()" unless exists $args{data};
    my $field = $args{field};



    do {
	return $data unless $field;

	$this->debugPrint (2, "scrubbing data $data for " . $field->getName() . "; type is " . $field->getType());

	my $type = $field->getType();
	if ($type == 9 or $type == 11) {
	    return undef if $data =~ /0000-00-00/;                              # this is a not very pleasant mysql-ism
	} 
	return $data;
    };
}

################################################################################

sub getDateData {
   
=pod

=head3 $OracleHandle->getDateData (table => "any string"*, field => "any string"*, function => "any string"*, fmt => "any string"*)

 - table ("any string")		 : table to process
 - field ("any string")		 : field to process
 - function ("any string")		 : function to process
 - fmt ("any string")		 : how to format results

localizes date data from a table based on a format string

=cut

    my $this = shift;

    Confess "DB::OracleHandle->getDateData requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $table = $args{table};
    Confess "argument 'table' is required for DB::OracleHandle->getDateData()" unless exists $args{table};
    my $field = $args{field};
    Confess "argument 'field' is required for DB::OracleHandle->getDateData()" unless exists $args{field};
    my $function = $args{function};
    Confess "argument 'function' is required for DB::OracleHandle->getDateData()" unless exists $args{function};
    my $fmt = $args{fmt};
    Confess "argument 'fmt' is required for DB::OracleHandle->getDateData()" unless exists $args{fmt};



    do {
	return $this->getData (sql => "select to_char ($function($field), '$fmt') $field from $table");
    };
}

################################################################################

sub getPrimaryKeyName {
   
=pod

=head3 $OracleHandle->getPrimaryKeyName (tableName => "any string"*)

 - tableName ("any string")		 : table name to fetch primary key for

returns the name of this tables primary key

=cut

    my $this = shift;

    Confess "DB::OracleHandle->getPrimaryKeyName requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $tableName = $args{tableName};
    Confess "argument 'tableName' is required for DB::OracleHandle->getPrimaryKeyName()" unless exists $args{tableName};



    do {
	Confess "not implemented";
    };
}

################################################################################

sub validColumnName {
   
=pod

=head3 $OracleHandle->validColumnName (columnNameTranslators => "any string", data => "any string"*)

 - columnNameTranslators ("any string")		 : translation description for column names that need to be converted
 - data ("any string")		 : data to process

returns a column name that is valid for Oracle

=cut

    my $this = shift;

    Confess "DB::OracleHandle->validColumnName requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $columnNameTranslators = $args{columnNameTranslators};
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->validColumnName()" unless exists $args{data};



    do {
	my @cnts = split(/[,\s]+/,$columnNameTranslators);
	if ($data =~ /^(comment|date)$/i) {
	    $data = "$1_"; 
	} 
	foreach my $cnt (@cnts) {
	    my $regex = $ENV{$cnt . "_regex"};
	    my $_pre = $data;
	    eval '$data =~ ' . "$regex ;";
	    $this->debugPrint (0, "converted $_pre to $data")
		if ($_pre != $data);
	}
	substr($data,0,$this->maxColumnLength());
    };
}

################################################################################

sub validTableName {
   
=pod

=head3 $OracleHandle->validTableName (data => "any string"*)

 - data ("any string")		 : data to process

returns a valid table name for this RDBMS

=cut

    my $this = shift;

    Confess "DB::OracleHandle->validTableName requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->validTableName()" unless exists $args{data};



    do {
	substr($data,0,27);
    };
}

################################################################################

sub fetchPrimaryKeyName {
   
=pod

=head3 $OracleHandle->fetchPrimaryKeyName (name => "any string"*, required => "any string")

 - name ("any string")		 : table name to derive
 - required ("any string")		 : require a result ... throw an error if the primary key can't be derived

attempts to derive the primary key of this table based on DB metadata

=cut

    my $this = shift;

    Confess "DB::OracleHandle->fetchPrimaryKeyName requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $name = $args{name};
    Confess "argument 'name' is required for DB::OracleHandle->fetchPrimaryKeyName()" unless exists $args{name};
    my $required = $args{required};



    do {
	my %results = %{$this->getData (sql => "
select 	ucc.column_name
from 	user_constraints uc,
	user_cons_columns ucc
where 	upper(uc.table_name) = upper('" . $name . "') 
and 	uc.constraint_type = 'P'
and	uc.table_name = ucc.table_name
and	uc.constraint_name =  ucc.constraint_name")};

	Confess "multiple column primary keys not supported" . Dumper(%results)
	    if $results{rows} > 1;

	Confess "no primary key derived"
	    if $required and $results{rows} < 1;

	$this->debugPrint(1, "primary key derived as " .  $results{COLUMN_NAME}[0]);

	$results{COLUMN_NAME}[0];
    };
}

################################################################################

sub inlineViewModifier {
   
=pod

=head3 $OracleHandle->inlineViewModifier ()


when creating an inline view and naming, it can be required by some RDBMS(like mysql) to use an "as"

=cut

    my $this = shift;

    Confess "DB::OracleHandle->inlineViewModifier requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	"";
    };
}


################################################################################

sub dateSelector {
   
=pod

=head3 $OracleHandle->dateSelector (data => "any string"*)

 - data ("any string")		 : data to process

When selecting a date from this database, produces an  approriate formatting string.

=cut

    my $this = shift;

    Confess "DB::OracleHandle->dateSelector requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->dateSelector()" unless exists $args{data};



    do {
	"to_char ($data, 'YYYY-MM-DD HH24:MI:SS')";
    };
}


################################################################################

sub dateCreator {
   
=pod

=head3 $OracleHandle->dateCreator (data => "any string"*)

 - data ("any string")		 : data to process

Useful for converting string representation of dates into actual Oracle date formats

=cut

    my $this = shift;

    Confess "DB::OracleHandle->dateCreator requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->dateCreator()" unless exists $args{data};



    do {
	"to_date ('$data', 'YYYY-MM-DD HH24:MI:SS')";
    };
}


################################################################################

sub setPrecision {
   
=pod

=head3 $OracleHandle->setPrecision (columnName => "any string"*, precision => "any string"*, name => "any string"*)

 - columnName ("any string")		 : name of the column to alter
 - precision ("any string")		 : new precision
 - name ("any string")		 : name of the table to alter

modify the precision of a column

=cut

    my $this = shift;

    Confess "DB::OracleHandle->setPrecision requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $columnName = $args{columnName};
    Confess "argument 'columnName' is required for DB::OracleHandle->setPrecision()" unless exists $args{columnName};
    my $precision = $args{precision};
    Confess "argument 'precision' is required for DB::OracleHandle->setPrecision()" unless exists $args{precision};
    my $name = $args{name};
    Confess "argument 'name' is required for DB::OracleHandle->setPrecision()" unless exists $args{name};



    do {
	my $sql = "alter table $name modify $columnName varchar2 ($precision)";
	$this->debugPrint(0, $sql);
	$this->execute(sql => $sql);
    };
}


################################################################################

sub getReferers {
   
=pod

=head3 $OracleHandle->getReferers (tableName => "any string"*)

 - tableName ("any string")		 : table name to derive references for

fetches foreign key metadata

=cut

    my $this = shift;

    Confess "DB::OracleHandle->getReferers requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $tableName = $args{tableName};
    Confess "argument 'tableName' is required for DB::OracleHandle->getReferers()" unless exists $args{tableName};



    do {
	$this->newRowSet(sql => "select	A.table_name referring_table,
	lower(A.column_name) referring_column, 
	lower(B.column_name) referred_column
from    (
		select	table_name,
			column_name,
			constraint_name
		from	user_cons_columns
		where	lower(table_name) = lower('$tableName')
	) B,
	(
		select	user_constraints.constraint_name, 
			user_constraints.r_constraint_name,
			user_cons_columns.column_name,
			user_constraints.table_name
		from	user_constraints, 
			user_cons_columns
 		where 	
			constraint_type = 'R'
		and	user_constraints.constraint_name = user_cons_columns.constraint_name
	) A
where	A.r_constraint_name = B.constraint_name");
    };
}

################################################################################

sub stringToDate {
   
=pod

=head3 $OracleHandle->stringToDate (data => "any string"*)

 - data ("any string")		 : data to process

convert a date string into SQL ready date format

=cut

    my $this = shift;

    Confess "DB::OracleHandle->stringToDate requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::OracleHandle->stringToDate()" unless exists $args{data};



    do {
	$data =~ /0000/ && do {
	    $data  = "01-01-1900 00:00:00";
	};
	return "to_date(\'" . $data . "\', 'MM-DD-YYYY HH24:MI:SS')"
    };
}



################################################################################

sub getReferrals {
   
=pod

=head3 $OracleHandle->getReferrals (tableName => "any string"*)

 - tableName ("any string")		 : table name to derive references from

fetches foreign key metadata -> tables referenced from the argument

=cut

    my $this = shift;

    Confess "DB::OracleHandle->getReferrals requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $tableName = $args{tableName};
    Confess "argument 'tableName' is required for DB::OracleHandle->getReferrals()" unless exists $args{tableName};



    do {
	$this->newRowSet(sql => "select	A.table_name referring_table,
	lower(A.column_name) referring_column, 
	lower(B.table_name) referred_table,
	lower(B.column_name) referred_column
from    (
		select	table_name,
			column_name,
			constraint_name
		from	user_cons_columns
	) B,
	(
		select	user_constraints.constraint_name, 
			user_constraints.r_constraint_name,
			user_cons_columns.column_name,
			user_constraints.table_name
		from	user_constraints, 
			user_cons_columns
 		where 	
			(
 				lower(user_constraints.table_name) = lower('$tableName')
 			)
		and	
			constraint_type = 'R'
		and	user_constraints.constraint_name = user_cons_columns.constraint_name
	) A
where	A.r_constraint_name = B.constraint_name");
    };
}


__DATA__

select	A.table_name,
	lower(A.column_name), 
	lower(B.table_name), 
	lower(B.column_name)
from    (
		select	table_name,
			column_name,
			constraint_name
		from	user_cons_columns
		where	table_name = 'EMPLOYEE'
	) B,
	(
		select	user_constraints.constraint_name, 
			user_constraints.r_constraint_name,
			user_cons_columns.column_name,
			user_constraints.table_name
		from	user_constraints, 
			user_cons_columns
 		where 	
--			(
-- 				user_constraints.table_name = 'WORKLIST_EMPLOYEE' 
-- 			)
--		and	
			constraint_type = 'R'
		and	user_constraints.constraint_name = user_cons_columns.constraint_name
	) A
where	A.r_constraint_name = B.constraint_name
/



