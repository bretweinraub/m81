


=pod

=head1 NAME - DB::Utils

Database Utilities

=head1 EXAMPLE


# using DB::Utils just imports routines into your namespace.

use DB::Utils;



=cut

# This file was automatically generated from Utils.pm.m80 by 
# bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package DB::Utils;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use Time::HiRes qw( usleep ualarm gettimeofday tv_interval );
use fields qw( debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item DB::Utils->new()

initializes on object of type DB::Utils

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my DB::Utils $this = shift;

    print STDERR "in DB::Utils::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of DB::Utils" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object DB::Utils. typo ?\n";
        }
    }



    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {DB::Utils::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::Utils::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {DB::Utils::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::Utils::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $Utils->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $Utils->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from Utils.pm.m80 by 
bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $Utils->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "DB::Utils->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



}

no strict ;
@ISA = qw(Exporter);
@EXPORT = qw(DBString SQLStringify createTables TV_INTERVAL rectifySchemas);
use strict ;


################################################################################

sub TV_INTERVAL {
   
=pod

=head3 $Utils->TV_INTERVAL (start => "any string"*, end => "any string"*)

 - start ("any string")		 : Start time of the interval
 - end ("any string")		 : End time of the interval

Generates a string representation of the difference between two timestamps

=cut

    Confess "DB::Utils::TV_INTERVAL requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $start = $args{start};
    Confess "argument 'start' is required for DB::Utils::TV_INTERVAL()" unless defined $start;
    my $end = $args{end};
    Confess "argument 'end' is required for DB::Utils::TV_INTERVAL()" unless defined $end;



    do {
	tv_interval($start,$end) . " secs";
    };
}

################################################################################

sub createTables {
   
=pod

=head3 $Utils->createTables (columnNameTranslators => "any string", dbhandle => DB::DBHandle*, sourceTable => DB::Table*, truncate => "any string", targetTableNames => "any string"*, prefixDateColumns => "any string", suppressM80 => "any string")

 - columnNameTranslators ("any string")		 : translation description for column names that need to be converted
 - dbhandle (DB::DBHandle)		 : the DBHandle in which the new tables will be created.
 - sourceTable (DB::Table)		 : metadata describing the source table
 - truncate ("any string")		 : truncate the destination tables.  This is *EXTREMELY* dangerous should only used if you know what you are doing
 - targetTableNames ("any string")		 : either the target table name, or an array reference to a list of target table names
 - prefixDateColumns ("any string")		 : prefix for data columns  (default: "local_")
 - suppressM80 ("any string")		 : don't add in the m80 magic columns

takes a dbhandle, a DB::Table description and a list of destination tables and clones the tables.

=cut

    Confess "DB::Utils::createTables requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $columnNameTranslators = $args{columnNameTranslators};
    my $dbhandle = $args{dbhandle};
    Confess "argument 'dbhandle' is required for DB::Utils::createTables()" unless defined $dbhandle;
    eval {my $dummy = $dbhandle->isa("DB::DBHandle");};Confess "$@\n" . Dumper($dbhandle) if $@;
    if (defined $dbhandle) { Confess "argument 'dbhandle' of method DB::Utils::createTables() is required to be of reference type DB::DBHandle, but it looks to be of type " . ref ($dbhandle)  unless $dbhandle->isa("DB::DBHandle");}
    my $sourceTable = $args{sourceTable};
    Confess "argument 'sourceTable' is required for DB::Utils::createTables()" unless defined $sourceTable;
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::Utils::createTables() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}
    my $truncate = $args{truncate};
    my $targetTableNames = $args{targetTableNames};
    Confess "argument 'targetTableNames' is required for DB::Utils::createTables()" unless defined $targetTableNames;
    my $prefixDateColumns = ($args{prefixDateColumns} ? $args{prefixDateColumns} : "local_");
    my $suppressM80 = $args{suppressM80};



    do {
	# TODO: schema differences should be rectified here

	my $ttns = ((ref ($targetTableNames) =~ /ARRAY/) ? $targetTableNames
		    : [$targetTableNames]);# target tables names;

	foreach my $targetTableName (@{$ttns}) {
	    if (not $dbhandle->tableExists(name => $targetTableName)) {
		eval {
		    $dbhandle->clone(sourceTable => $sourceTable,
				     prefixDateColumns => $prefixDateColumns,
				     columnNameTranslators => $columnNameTranslators,
				     suppressM80 => $suppressM80,
				     name => $targetTableName);
		};
		Confess "$@" if $@;
	    } else {
		debugPrint_s (0, "skipped table create of $targetTableName since it already exists");
	    }
	    $dbhandle->truncateTable(name => $targetTableName) 
		if $truncate;
	}
    };
}



################################################################################

sub DBString {
   
=pod

=head3 $Utils->DBString (data => "any string"*)

 - data ("any string")		 : data to process

Convert a string variable into a SQL query read variable, 

=cut

    Confess "DB::Utils::DBString requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::Utils::DBString()" unless defined $data;



    do {
	$data =~ s/\'/\'\'/g;
	debugPrint_s(2, "returning $data");
	$data;
    };
}


################################################################################

sub SQLStringify {
   
=pod

=head3 $Utils->SQLStringify (data => "any string"*)

 - data ("any string")		 : data to process

Converts text to a SQL read version ... while handling nulls

=cut

#    confess "DB::Utils::SQLStringify requires named arguments" if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::Utils::SQLStringify()" unless exists $args{data};

    do {
	if ($data)  {
	    return "'" . DBString (data => $data) . "'";
	}
	else {
	    return "null";
	}
    };
}


################################################################################

sub rectifySchemas {
   
=pod

=head3 $Utils->rectifySchemas (sourceTable => DB::Table, targetTable => DB::Table)

 - sourceTable (DB::Table)		 : source table reference
 - targetTable (DB::Table)		 : target table reference

takes two table definitions and attempts to alter one table to match the other.

=cut

    Confess "DB::Utils::rectifySchemas requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $sourceTable = $args{sourceTable};
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::Utils::rectifySchemas() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}
    my $targetTable = $args{targetTable};
    eval {my $dummy = $targetTable->isa("DB::Table");};Confess "$@\n" . Dumper($targetTable) if $@;
    if (defined $targetTable) { Confess "argument 'targetTable' of method DB::Utils::rectifySchemas() is required to be of reference type DB::Table, but it looks to be of type " . ref ($targetTable)  unless $targetTable->isa("DB::Table");}



    do {
	my %sourceColumns =  %{$sourceTable->getColumns()};
	my %targetColumns =  %{$targetTable->getColumns()};

	foreach my $key (keys(%sourceColumns)) {
	    my $sourceColumn = $sourceColumns{$key};
	    my $targetColumn = $targetColumns{$key};

	    debugPrint_s(1, "$sourceColumn->{name} ; source: $sourceColumn->{type} $sourceColumn->{precision} $sourceColumn->{scale} ; target: $targetColumn->{type} $targetColumn->{precision} $targetColumn->{scale}");

	    if ($sourceColumn->{type} eq 12 and $targetColumn->{type} eq 12
		and ($sourceColumn->{precision} > $targetColumn->{precision})) {
		debugPrint_s(0, "$sourceColumn->{name} ; source: $sourceColumn->{type} $sourceColumn->{precision} $sourceColumn->{scale} ; target: $targetColumn->{type} $targetColumn->{precision} $targetColumn->{scale}");
		debugPrint_s(0, "found expanded size of $sourceColumn->{name}");
		$targetTable->modifyPrecision(columnName => $key,
					      precision => $sourceColumn->{precision});
	    }
	}
    };
}

