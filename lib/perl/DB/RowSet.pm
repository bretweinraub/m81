



=pod

=head1 NAME - DB::RowSet

A row set returned by a SQL query.

=head1 EXAMPLE


   use DB::OracleHandle;
   use DB::RowSet;
   
   my $dbhandle = DB::OracleHandle->new(user => "$ENV{CONTROLLER_USER}",
   				     password => "$ENV{CONTROLLER_PASSWD}",
   				     SID => "$ENV{CONTROLLER_SID}",
   				     host => "$ENV{CONTROLLER_HOST}",
   				     port => "$ENV{CONTROLLER_PORT}");
   
   
   my $rowset = DB::RowSet->new(dbh => $dbhandle->getDbh(),
      			        sql => $this->getSql());
   
   my %results = %{$rowset->getResults()};

   #
   # Or all as one.....
   #

   my %results = %{(DB::RowSet->new(dbh => $dbhandle->getDbh(),
   			            sql => $this->getSql()))->getResults()};


   #
   # Or use the ADO interface

   my $routerData = $dbhandle->newRowSet(sql => "select * from aTable", lc => 't'); #use lower case columns

   while ($rowset->next) {
       $data1 = $rowset->item(0);
       $data2 = $rowset->item('jazz');
   }


                                   

=cut

# This file was automatically generated from RowSet.pm.m80 by 
# bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package DB::RowSet;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use DBI;
use fields qw( results rows fields dbh sql lc verbose _i _nextCalledOnce debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item DB::RowSet->new()

initializes on object of type DB::RowSet

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{results} = {
          'ref' => 'HASH',
          'name' => 'results',
          'description' => 'results returned by the SQL query'
        }
;
$_allSetters{results} = \&setResults;
$_allMemberAttributes{rows} = {
          'format' => '\\d+',
          'name' => 'rows',
          'description' => 'number of the rows in the rowset'
        }
;
$_allSetters{rows} = \&setRows;
$_allMemberAttributes{fields} = {
          'ref' => 'ARRAY',
          'name' => 'fields',
          'description' => 'An array of field names returned by the SQL query'
        }
;
$_allSetters{fields} = \&setFields;
$_allMemberAttributes{dbh} = {
          'ref' => 'DBI::db',
          'name' => 'dbh',
          'description' => 'the DBI handle for the database'
        }
;
$_allSetters{dbh} = \&setDbh;
$_allMemberAttributes{sql} = {
          'name' => 'sql',
          'description' => 'sql string for this rowset'
        }
;
$_allSetters{sql} = \&setSql;
$_allMemberAttributes{lc} = {
          'name' => 'lc',
          'description' => 'apply lowercase function to all field names when storing data'
        }
;
$_allSetters{lc} = \&setLc;
$_allMemberAttributes{verbose} = {
          'name' => 'verbose',
          'description' => 'verbose STDOUT logging of sql queries'
        }
;
$_allSetters{verbose} = \&setVerbose;
$_allMemberAttributes{_i} = {
          'name' => '_i',
          'description' => 'Internal variable for storing the current row that is pointed to in the RowSet'
        }
;
$_allSetters{_i} = \&set_i;
$_allMemberAttributes{_nextCalledOnce} = {
          'name' => '_nextCalledOnce',
          'description' => 'Internal variable for storing the fact that the next function has set the iterator - support for different call syntax based on 1 row in the result set and many rows in the result set.'
        }
;
$_allSetters{_nextCalledOnce} = \&set_nextCalledOnce;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my DB::RowSet $this = shift;

    print STDERR "in DB::RowSet::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of DB::RowSet" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object DB::RowSet. typo ?\n";
        }
    }



    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {DB::RowSet::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::RowSet::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {DB::RowSet::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::RowSet::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 results => HASH

results returned by the SQL query

=cut

sub getResults {

=pod

=head3 $RowSet->getResults ()


getter for member results

=cut

    my $this = shift;





    return $this->{results};
}
sub setResults {

=pod

=head3 $RowSet->setResults (results => HASH)

 - results (HASH)		 : results returned by the SQL query

setter for member results

=cut

    my $this = shift;


    my $results = shift;
        if (defined $results) { Confess "argument 'results' of method DB::RowSet->setResults() is required to be of reference type HASH " unless ref($results) =~ /^HASH/;}



    $this->{results} = $results;
    return $results;
}



=pod

=head2 rows => "\d+"

number of the rows in the rowset

=cut

sub getRows {

=pod

=head3 $RowSet->getRows ()


getter for member rows

=cut

    my $this = shift;





    return $this->{rows};
}
sub setRows {

=pod

=head3 $RowSet->setRows (rows => "\d+")

 - rows ("\d+")		 : number of the rows in the rowset

setter for member rows

=cut

    my $this = shift;


    my $rows = shift;
        if (defined $rows) { Confess "argument 'rows' of method DB::RowSet->setRows() failed format validation of '\d+'" unless $rows =~ /\d+/;}



    $this->{rows} = $rows;
    return $rows;
}



=pod

=head2 fields => ARRAY

An array of field names returned by the SQL query

=cut

sub getFields {

=pod

=head3 $RowSet->getFields ()


getter for member fields

=cut

    my $this = shift;





    return $this->{fields};
}
sub setFields {

=pod

=head3 $RowSet->setFields (fields => ARRAY)

 - fields (ARRAY)		 : An array of field names returned by the SQL query

setter for member fields

=cut

    my $this = shift;


    my $fields = shift;
        if (defined $fields) { Confess "argument 'fields' of method DB::RowSet->setFields() is required to be of reference type ARRAY " unless ref($fields) =~ /^ARRAY/;}



    $this->{fields} = $fields;
    return $fields;
}



=pod

=head2 dbh => DBI::db

the DBI handle for the database

=cut

sub getDbh {

=pod

=head3 $RowSet->getDbh ()


getter for member dbh

=cut

    my $this = shift;





    return $this->{dbh};
}
sub setDbh {

=pod

=head3 $RowSet->setDbh (dbh => DBI::db)

 - dbh (DBI::db)		 : the DBI handle for the database

setter for member dbh

=cut

    my $this = shift;


    my $dbh = shift;
    eval {my $dummy = $dbh->isa("DBI::db");};Confess "$@\n" . Dumper($dbh) if $@;
    if (defined $dbh) { Confess "argument 'dbh' of method DB::RowSet->setDbh() is required to be of reference type DBI::db, but it looks to be of type " . ref ($dbh)  unless $dbh->isa("DBI::db");}



    $this->{dbh} = $dbh;
    return $dbh;
}



=pod

=head2 sql => "any string"

sql string for this rowset

=cut

sub getSql {

=pod

=head3 $RowSet->getSql ()


getter for member sql

=cut

    my $this = shift;





    return $this->{sql};
}
sub setSql {

=pod

=head3 $RowSet->setSql (sql => "any string")

 - sql ("any string")		 : sql string for this rowset

setter for member sql

=cut

    my $this = shift;


    my $sql = shift;



    $this->{sql} = $sql;
    return $sql;
}



=pod

=head2 lc => "any string"

apply lowercase function to all field names when storing data

=cut

sub getLc {

=pod

=head3 $RowSet->getLc ()


getter for member lc

=cut

    my $this = shift;





    return $this->{lc};
}
sub setLc {

=pod

=head3 $RowSet->setLc (lc => "any string")

 - lc ("any string")		 : apply lowercase function to all field names when storing data

setter for member lc

=cut

    my $this = shift;


    my $lc = shift;



    $this->{lc} = $lc;
    return $lc;
}



=pod

=head2 verbose => "any string"

verbose STDOUT logging of sql queries

=cut

sub getVerbose {

=pod

=head3 $RowSet->getVerbose ()


getter for member verbose

=cut

    my $this = shift;





    return $this->{verbose};
}
sub setVerbose {

=pod

=head3 $RowSet->setVerbose (verbose => "any string")

 - verbose ("any string")		 : verbose STDOUT logging of sql queries

setter for member verbose

=cut

    my $this = shift;


    my $verbose = shift;



    $this->{verbose} = $verbose;
    return $verbose;
}



=pod

=head2 _i => "any string"

Internal variable for storing the current row that is pointed to in the RowSet

=cut

sub get_i {

=pod

=head3 $RowSet->get_i ()


getter for member _i

=cut

    my $this = shift;





    return $this->{_i};
}
sub set_i {

=pod

=head3 $RowSet->set_i (_i => "any string")

 - _i ("any string")		 : Internal variable for storing the current row that is pointed to in the RowSet

setter for member _i

=cut

    my $this = shift;


    my $_i = shift;



    $this->{_i} = $_i;
    return $_i;
}



=pod

=head2 _nextCalledOnce => "any string"

Internal variable for storing the fact that the next function has set the iterator - support for different call syntax based on 1 row in the result set and many rows in the result set.

=cut

sub get_nextCalledOnce {

=pod

=head3 $RowSet->get_nextCalledOnce ()


getter for member _nextCalledOnce

=cut

    my $this = shift;





    return $this->{_nextCalledOnce};
}
sub set_nextCalledOnce {

=pod

=head3 $RowSet->set_nextCalledOnce (_nextCalledOnce => "any string")

 - _nextCalledOnce ("any string")		 : Internal variable for storing the fact that the next function has set the iterator - support for different call syntax based on 1 row in the result set and many rows in the result set.

setter for member _nextCalledOnce

=cut

    my $this = shift;


    my $_nextCalledOnce = shift;



    $this->{_nextCalledOnce} = $_nextCalledOnce;
    return $_nextCalledOnce;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $RowSet->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $RowSet->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from RowSet.pm.m80 by 
bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $RowSet->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "DB::RowSet->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
        $this->execute();
        $this->reset();
    };
}

sub execute {
    
=pod

=head3 $RowSet->execute ()


execute the sql query as returned by getSql()

=cut

    my $this = shift;

    Confess "DB::RowSet->execute requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    my $results = {};
    my $verbose = $this->getVerbose();

    my $dbh = $this->getDbh();
    
    my $stmt; 

    $this->debugPrint (1, $this->getSql());

    eval {
	$stmt = $dbh->prepare($this->getSql());
    };
    Confess "$@" if $@;

    eval {
	$stmt->execute
	    or Confess "ERROR: $DBI::errstr";
    };
    Confess $this->getSql() . "\nthrew $@" if $@;

    my @row;
    
    $results->{rows} = 0;
    my $lc = $this->getLc();

    my $numOfFields = $stmt->{NUM_OF_FIELDS};

    for (my $i = 0; $i < $numOfFields; $i++) {
	my $fieldName = $stmt->{NAME}->[$i];
	$fieldName = lc($fieldName) if $lc;
	push (@{$results->{_fields}},$fieldName);
	$this->debugPrint (3, "processing field named $fieldName");
    }
    print STDERR  "\n" if $verbose;
    eval {
	while (@row = $stmt->fetchrow_array()) {
	    $results->{rows}++;
	    for (my $i = 0; $i < $numOfFields ; $i++) {
		push (@{$results->{($lc ? lc($stmt->{NAME}->[$i]) : $stmt->{NAME}->[$i])}},
		      $row[$i]);
		print STDERR  $row[$i] . "\t" if $verbose;
	    }
	    print STDERR  "\n" if $verbose;
	}
    }; 
    Confess "$@" if $@;
    $stmt->finish();

    $this->setRows($results->{rows});
    $this->setFields($results->{_fields});

    $this->setResults($results);

}


sub reset {
    
=pod

=head3 $RowSet->reset ()


Start at the beginning of the RowSet

=cut

    my $this = shift;

    Confess "DB::RowSet->reset requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    do { # emacs quoting
        $this->{_i} = -1;
         $this->{_nextCalledOnce} = 0;
    };
}


sub next {
    
=pod

=head3 $RowSet->next ()


get the next row in the RowSet

=cut

    my $this = shift;

    Confess "DB::RowSet->next requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    do { # emacs quoting
        $this->{_nextCalledOnce} = 1;
        $this->{_i}++;
        
        if ($this->{_i} >= $this->getRows) {
            return 0;
        } else {
            return 1;
        }
    };
}

sub item {
    
=pod

=head3 $RowSet->item ()


Get the data given a field name or a field index

=cut

    my $this = shift;






    do { # emacs quoting
        $this->{_i} = 0 unless $this->{_nextCalledOnce};
        my $fieldName = shift;
        if ($fieldName =~ /^\d+$/) { # if it is a digit, lookup the field name
            $fieldName = ( @{ $this->getFields } )[$fieldName];
            $this->debugPrint(1, "Derived '$fieldName' from its index in the field list");
        }
        $this->debugPrint(2, "getting value for $fieldName: " , $this->{results}->{$fieldName}->[$this->{_i}]);
        return $this->{results}->{$fieldName}->[$this->{_i}];
    };        
}

sub fields {
    
=pod

=head3 $RowSet->fields ()


Get the list of fields

=cut

    my $this = shift;

    Confess "DB::RowSet->fields requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
        return @{ $this->getFields };
    };
}
