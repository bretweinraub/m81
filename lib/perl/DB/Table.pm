

=pod

=head1 NAME - DB::Table

DB::Table description; stub description please expand

=head1 EXAMPLE


  my $DBTable = $DB::Table->new();   # stub example .... expand

  # for results that mirror the target table, use the Import() function
  
  $DBTable->Import (data => \%results,
		    sourceTable => $etlhelper->getSourceTable(),
		    truncate => 1);  # optional ; truncates the destination if set.



=cut

# This file was automatically generated from Table.pm.m80 by 
# bweinraub on li298-104 (Linux li298-104 2.6.38-linode31 #1 SMP Mon Mar 21 21:22:33 UTC 2011 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package DB::Table;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use DBI;
use DB::Utils;
use Time::HiRes qw( gettimeofday tv_interval );
use Utils::ContextInsensitiveHash;
use fields qw( handle name _field_cache _field_cache_stmt primaryKeyName insertedDateColumnName updatedDateColumnName prefixDateColumns m80table columns debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item DB::Table->new()

initializes on object of type DB::Table

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{handle} = {
          'required' => 1,
          'ref' => 'DB::DBHandle',
          'name' => 'handle',
          'description' => 'Handle that created this table object'
        }
;
$_allSetters{handle} = \&setHandle;
$_allMemberAttributes{name} = {
          'required' => 1,
          'name' => 'name',
          'description' => 'The name of this table'
        }
;
$_allSetters{name} = \&setName;
$_allMemberAttributes{_field_cache} = {
          'ref' => 'ARRAY',
          'name' => '_field_cache',
          'description' => 'internal variable used to cache metadata for import statements'
        }
;
$_allSetters{_field_cache} = \&set_field_cache;
$_allMemberAttributes{_field_cache_stmt} = {
          'ref' => 'DBI::st',
          'name' => '_field_cache_stmt',
          'description' => 'internal variable used to cache metadata for import statements'
        }
;
$_allSetters{_field_cache_stmt} = \&set_field_cache_stmt;
$_allMemberAttributes{primaryKeyName} = {
          'name' => 'primaryKeyName',
          'description' => 'name of this tables primary key name'
        }
;
$_allSetters{primaryKeyName} = \&setPrimaryKeyName;
$_allMemberAttributes{insertedDateColumnName} = {
          'name' => 'insertedDateColumnName',
          'description' => 'name of the trigger driven column name for inserts'
        }
;
$_allSetters{insertedDateColumnName} = \&setInsertedDateColumnName;
$_allMemberAttributes{updatedDateColumnName} = {
          'name' => 'updatedDateColumnName',
          'description' => 'name of the trigger driven column name for updates'
        }
;
$_allSetters{updatedDateColumnName} = \&setUpdatedDateColumnName;
$_allMemberAttributes{prefixDateColumns} = {
          'name' => 'prefixDateColumns',
          'default' => 'local_',
          'description' => 'use this prefix where deriving column names'
        }
;
$_allSetters{prefixDateColumns} = \&setPrefixDateColumns;
$_allMemberAttributes{m80table} = {
          'name' => 'm80table',
          'description' => 'if a m80 table we can derive certain things about the table'
        }
;
$_allSetters{m80table} = \&setM80table;
$_allMemberAttributes{columns} = {
          'ref' => 'HASH',
          'name' => 'columns',
          'description' => 'Array of Column objects for this table'
        }
;
$_allSetters{columns} = \&setColumns;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my DB::Table $this = shift;

    print STDERR "in DB::Table::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of DB::Table" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object DB::Table. typo ?\n";
        }
    }


    Confess "cannot initialize object of type DB::Table without required member variable handle"
        unless exists $this->{handle};

    Confess "cannot initialize object of type DB::Table without required member variable name"
        unless exists $this->{name};

    $this->{prefixDateColumns} = "local_" unless defined $this->{prefixDateColumns};


    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {DB::Table::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::Table::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {DB::Table::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::Table::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 handle => DB::DBHandle*

Handle that created this table object

=cut

sub getHandle {

=pod

=head3 $Table->getHandle ()


getter for member handle

=cut

    my $this = shift;





    return $this->{handle};
}
sub setHandle {

=pod

=head3 $Table->setHandle (handle => DB::DBHandle*)

 - handle (DB::DBHandle)		 : Handle that created this table object

setter for member handle

=cut

    my $this = shift;


    my $handle = shift;
    Confess "argument 'handle' is required for DB::Table->setHandle()" unless defined $handle;
    eval {my $dummy = $handle->isa("DB::DBHandle");};Confess "$@\n" . Dumper($handle) if $@;
    if (defined $handle) { Confess "argument 'handle' of method DB::Table->setHandle() is required to be of reference type DB::DBHandle, but it looks to be of type " . ref ($handle)  unless $handle->isa("DB::DBHandle");}



    $this->{handle} = $handle;
    return $handle;
}



=pod

=head2 name => "any string"*

The name of this table

=cut

sub getName {

=pod

=head3 $Table->getName ()


getter for member name

=cut

    my $this = shift;





    return $this->{name};
}
sub setName {

=pod

=head3 $Table->setName (name => "any string"*)

 - name ("any string")		 : The name of this table

setter for member name

=cut

    my $this = shift;


    my $name = shift;
    Confess "argument 'name' is required for DB::Table->setName()" unless defined $name;



    $this->{name} = $name;
    return $name;
}



=pod

=head2 _field_cache => ARRAY

internal variable used to cache metadata for import statements

=cut

sub get_field_cache {

=pod

=head3 $Table->get_field_cache ()


getter for member _field_cache

=cut

    my $this = shift;





    return $this->{_field_cache};
}
sub set_field_cache {

=pod

=head3 $Table->set_field_cache (_field_cache => ARRAY)

 - _field_cache (ARRAY)		 : internal variable used to cache metadata for import statements

setter for member _field_cache

=cut

    my $this = shift;


    my $_field_cache = shift;
        if (defined $_field_cache) { Confess "argument '_field_cache' of method DB::Table->set_field_cache() is required to be of reference type ARRAY " unless ref($_field_cache) =~ /^ARRAY/;}



    $this->{_field_cache} = $_field_cache;
    return $_field_cache;
}



=pod

=head2 _field_cache_stmt => DBI::st

internal variable used to cache metadata for import statements

=cut

sub get_field_cache_stmt {

=pod

=head3 $Table->get_field_cache_stmt ()


getter for member _field_cache_stmt

=cut

    my $this = shift;





    return $this->{_field_cache_stmt};
}
sub set_field_cache_stmt {

=pod

=head3 $Table->set_field_cache_stmt (_field_cache_stmt => DBI::st)

 - _field_cache_stmt (DBI::st)		 : internal variable used to cache metadata for import statements

setter for member _field_cache_stmt

=cut

    my $this = shift;


    my $_field_cache_stmt = shift;
    eval {my $dummy = $_field_cache_stmt->isa("DBI::st");};Confess "$@\n" . Dumper($_field_cache_stmt) if $@;
    if (defined $_field_cache_stmt) { Confess "argument '_field_cache_stmt' of method DB::Table->set_field_cache_stmt() is required to be of reference type DBI::st, but it looks to be of type " . ref ($_field_cache_stmt)  unless $_field_cache_stmt->isa("DBI::st");}



    $this->{_field_cache_stmt} = $_field_cache_stmt;
    return $_field_cache_stmt;
}



=pod

=head2 primaryKeyName => "any string"

name of this tables primary key name

=cut

sub getPrimaryKeyName {

=pod

=head3 $Table->getPrimaryKeyName ()


getter for member primaryKeyName

=cut

    my $this = shift;





    return $this->{primaryKeyName};
}
sub setPrimaryKeyName {

=pod

=head3 $Table->setPrimaryKeyName (primaryKeyName => "any string")

 - primaryKeyName ("any string")		 : name of this tables primary key name

setter for member primaryKeyName

=cut

    my $this = shift;


    my $primaryKeyName = shift;



    $this->{primaryKeyName} = $primaryKeyName;
    return $primaryKeyName;
}



=pod

=head2 insertedDateColumnName => "any string"

name of the trigger driven column name for inserts

=cut

sub getInsertedDateColumnName {

=pod

=head3 $Table->getInsertedDateColumnName ()


getter for member insertedDateColumnName

=cut

    my $this = shift;





    return $this->{insertedDateColumnName};
}
sub setInsertedDateColumnName {

=pod

=head3 $Table->setInsertedDateColumnName (insertedDateColumnName => "any string")

 - insertedDateColumnName ("any string")		 : name of the trigger driven column name for inserts

setter for member insertedDateColumnName

=cut

    my $this = shift;


    my $insertedDateColumnName = shift;



    $this->{insertedDateColumnName} = $insertedDateColumnName;
    return $insertedDateColumnName;
}



=pod

=head2 updatedDateColumnName => "any string"

name of the trigger driven column name for updates

=cut

sub getUpdatedDateColumnName {

=pod

=head3 $Table->getUpdatedDateColumnName ()


getter for member updatedDateColumnName

=cut

    my $this = shift;





    return $this->{updatedDateColumnName};
}
sub setUpdatedDateColumnName {

=pod

=head3 $Table->setUpdatedDateColumnName (updatedDateColumnName => "any string")

 - updatedDateColumnName ("any string")		 : name of the trigger driven column name for updates

setter for member updatedDateColumnName

=cut

    my $this = shift;


    my $updatedDateColumnName = shift;



    $this->{updatedDateColumnName} = $updatedDateColumnName;
    return $updatedDateColumnName;
}



=pod

=head2 prefixDateColumns => "any string" (default: "local_")

use this prefix where deriving column names

=cut

sub getPrefixDateColumns {

=pod

=head3 $Table->getPrefixDateColumns ()


getter for member prefixDateColumns

=cut

    my $this = shift;





    return $this->{prefixDateColumns};
}
sub setPrefixDateColumns {

=pod

=head3 $Table->setPrefixDateColumns (prefixDateColumns => "any string")

 - prefixDateColumns ("any string")		 : use this prefix where deriving column names

setter for member prefixDateColumns

=cut

    my $this = shift;


    my $prefixDateColumns = shift;



    $this->{prefixDateColumns} = $prefixDateColumns;
    return $prefixDateColumns;
}



=pod

=head2 m80table => "any string"

if a m80 table we can derive certain things about the table

=cut

sub getM80table {

=pod

=head3 $Table->getM80table ()


getter for member m80table

=cut

    my $this = shift;





    return $this->{m80table};
}
sub setM80table {

=pod

=head3 $Table->setM80table (m80table => "any string")

 - m80table ("any string")		 : if a m80 table we can derive certain things about the table

setter for member m80table

=cut

    my $this = shift;


    my $m80table = shift;



    $this->{m80table} = $m80table;
    return $m80table;
}



=pod

=head2 columns => HASH

Array of Column objects for this table

=cut

sub getColumns {

=pod

=head3 $Table->getColumns ()


getter for member columns

=cut

    my $this = shift;





    return $this->{columns};
}
sub setColumns {

=pod

=head3 $Table->setColumns (columns => HASH)

 - columns (HASH)		 : Array of Column objects for this table

setter for member columns

=cut

    my $this = shift;


    my $columns = shift;
        if (defined $columns) { Confess "argument 'columns' of method DB::Table->setColumns() is required to be of reference type HASH " unless ref($columns) =~ /^HASH/;}



    $this->{columns} = $columns;
    return $columns;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $Table->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $Table->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from Table.pm.m80 by 
bweinraub on li298-104 (Linux li298-104 2.6.38-linode31 #1 SMP Mon Mar 21 21:22:33 UTC 2011 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut


#
# TODO:  This class should become an ISA of the DBI handle.  
#

sub _new {

=pod

=head3 $Table->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "DB::Table->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	tie my %columns, "Utils::ContextInsensitiveHash";

	my $stmt;
	eval {
	    $stmt = $this->getHandle()->getDbh()->prepare("select * from ".$this->getName() . " where 1 = 0");
	    $stmt->execute();
	}; 
	Confess "$@" if $@;

	$this->debugPrint (1, "loading metadata for table " . $this->getName());

	for (my $i = 0 ; $i < $stmt->{NUM_OF_FIELDS} ; $i++) {
	    my $column = $stmt->{NAME}->[$i];
	    $this->debugPrint(2, "found field $column");
	    my $ret = DB::FieldMetaData->new (name => $column,
					      type => $stmt->{TYPE}->[$i],
					      precision => $stmt->{PRECISION}->[$i],
					      handle => $this->getHandle(),
					      scale => ($stmt->{SCALE}->[$i] ?
							$stmt->{SCALE}->[$i] : 0));

	    $columns{$column} = $ret;
	}
	
	$this->setColumns(\%columns);
	$this->setM80table() 
	    if $this->getM80table();
    };
}

################################################################################

sub exists {
    
=pod

=head3 $Table->exists ()


validates that a column exists in this table

=cut

    my $this = shift;

    Confess "DB::Table->exists requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	my %columns = %{$this->getColumns()};
	
	foreach my $testColumn (@_) {
	    my $found = 0;
	    foreach my $columnName (sort (keys(%columns))) {
		if (lc ($columnName) eq $testColumn) {
		    $found = 1;
		    last;
		}
	    }
	    Confess "no such column $testColumn in table " . $this->getName()
		unless $found;
	}
    };
}

sub SetM80table {
   
=pod

=head3 $Table->SetM80table (prefixDateColumns => "any string")

 - prefixDateColumns ("any string")		 : use this prefix where deriving column names

rigs all the meta data associated with a m80 table

=cut

    my $this = shift;

    Confess "DB::Table->SetM80table requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $prefixDateColumns = $args{prefixDateColumns};



    do {
	$this->debugPrint(0, "setting m80table on " . $this->getName . " : $prefixDateColumns");
	$this->setPrefixDateColumns($prefixDateColumns);

	unless ($this->getInsertedDateColumnName()) {
	    $this->setInsertedDateColumnName($this->getPrefixDateColumns() . "inserted_dt");
	}
	unless ($this->getUpdatedDateColumnName()) {
	    $this->setUpdatedDateColumnName($this->getPrefixDateColumns() . "updated_dt");
	}

	$this->exists($this->getInsertedDateColumnName(),
		      $this->getUpdatedDateColumnName());
    };
}


################################################################################

sub executeBindStatement {
    
=pod

=head3 $Table->executeBindStatement (sourceTable => DB::Table, ignorePrimaryKey => "any string", ignoreModificationColumns => "any string", statement => "any string"*, key => "any string", rowNumber => "any string"*, data => HASH*)

 - sourceTable (DB::Table)		 : source table metadata
 - ignorePrimaryKey ("any string")		 : ignore the primary key of the table
 - ignoreModificationColumns ("any string")		 : ignore modification columns (if they exist).
 - statement ("any string")		 : prebuilt DBI statement object
 - key ("any string")		 : for update statements this is the natural key.  If you set this for an insert statement you may get an error.
 - rowNumber ("any string")		 : rowNumber to use for bind data
 - data (HASH)		 : data to process

insert a row from a row set based on a row number.  Returns the number of rows affected.

=cut

    my $this = shift;

    Confess "DB::Table->executeBindStatement requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $sourceTable = $args{sourceTable};
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::Table->executeBindStatement() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}
    my $ignorePrimaryKey = $args{ignorePrimaryKey};
    my $ignoreModificationColumns = $args{ignoreModificationColumns};
    my $statement = $args{statement};
    Confess "argument 'statement' is required for DB::Table->executeBindStatement()" unless exists $args{statement};
    my $key = $args{key};
    my $rowNumber = $args{rowNumber};
    Confess "argument 'rowNumber' is required for DB::Table->executeBindStatement()" unless exists $args{rowNumber};
    my $data = $args{data};
    Confess "argument 'data' is required for DB::Table->executeBindStatement()" unless exists $args{data};
        if (defined $data) { Confess "argument 'data' of method DB::Table->executeBindStatement() is required to be of reference type HASH " unless ref($data) =~ /^HASH/;}



    do {
	my %columns = %{$this->getColumns()};                                   # list of columns in this table

	my $handle = $this->getHandle();

	$this->debugPrint (2, "processing row number $rowNumber");
	my $bindNumber = 0;
	
	my @fieldCache = ();
	unless ($this->get_field_cache() and
		$this->get_field_cache_stmt() eq $statement) {
	    $this->debugPrint (1, "updating field cache");

#
# XXX - right now ; if the column name in the source table doesn\'t match the column name in the destination table
# this code can't connect the dots.  This is because when going from something like MySQL to Oracle, Oracle names have
# to be 30 characters or less, so in some cases the column names wont match up.
#
	    foreach my $columnName (sort (keys(%columns))) {		
		push (@fieldCache, $sourceTable->getField(data => $columnName))
		    unless $this->ignoreColumn(ignorePrimaryKey => $ignorePrimaryKey,
					       columnName => $columnName,
					       ignoreModificationColumns => $ignoreModificationColumns);
	    }

	    $this->set_field_cache(\@fieldCache);
	    $this->set_field_cache_stmt($statement);
	}                                                                       # performance enhancement to avoid looking up field meta data repeatedly.
# 	else {
# 	    $this->debugPrint (1, "using existing field cache");
	    
# 	}

	my $ndx = 0;
	@fieldCache = @{$this->get_field_cache()};
	    
	foreach my $columnName (sort (keys(%columns))) {
	    do {
		my $fieldMetaData = $fieldCache[$ndx];

		$bindNumber++;
		my $data = $handle->scrubBindData ( field => $fieldMetaData,
						    data => $data->{uc($columnName)}[$rowNumber] . 
						    $data->{lc($columnName)}[$rowNumber] ); #try hard to find the column .... upper or lower case

		$statement->bind_param($bindNumber, $data) ;
		$this->debugPrint (3, "bound \"$data\" to column $columnName (:p$bindNumber)");
		$ndx++;
	    } unless $this->ignoreColumn(ignorePrimaryKey => $ignorePrimaryKey,
					 columnName => $columnName,
					 ignoreModificationColumns => $ignoreModificationColumns);
	}
	eval {
	    $statement->bind_param(++$bindNumber,$key) if $key;                       # this means this in an update
	};
	Confess "error binding key to SQL statement.  Maybe you passed in an undeeded \$key argument to INSERT bind: $@" if $@;
	$this->debugPrint (1, "bound $bindNumber paramaters to SQL statement");

	my $rowsAffected;
	eval { $statement->execute(); $rowsAffected = $statement->rows; }; Confess "$@" if $@;
	$rowsAffected;
    };
}

sub Merge {
   
=pod

=head3 $Table->Merge (dateFormat => "any string", data => HASH*, keyMap => HASH, naturalKey => "any string"*, sourceTable => DB::Table*)

 - dateFormat ("any string")		 : can be used to specify the date format used in the input (default: "YYYY-MM-DD HH24:MI:SS")
 - data (HASH)		 : data to process
 - keyMap (HASH)		 : if a key map is provided, only those natural keys in the map will be executed on
 - naturalKey ("any string")		 : natural key of the data set
 - sourceTable (DB::Table)		 : source table metadata of type DB::Table->new()

merge data into this table based on a results set.  Matches on the defined natural key are updated, otherwise the row is inserted

=cut

    my $this = shift;

    Confess "DB::Table->Merge requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "YYYY-MM-DD HH24:MI:SS");
    my $data = $args{data};
    Confess "argument 'data' is required for DB::Table->Merge()" unless exists $args{data};
        if (defined $data) { Confess "argument 'data' of method DB::Table->Merge() is required to be of reference type HASH " unless ref($data) =~ /^HASH/;}
    my $keyMap = $args{keyMap};
        if (defined $keyMap) { Confess "argument 'keyMap' of method DB::Table->Merge() is required to be of reference type HASH " unless ref($keyMap) =~ /^HASH/;}
    my $naturalKey = $args{naturalKey};
    Confess "argument 'naturalKey' is required for DB::Table->Merge()" unless exists $args{naturalKey};
    my $sourceTable = $args{sourceTable};
    Confess "argument 'sourceTable' is required for DB::Table->Merge()" unless exists $args{sourceTable};
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::Table->Merge() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}



    do {
	my $handle = $this->getHandle();

	my $updateSql = $this->genUpdateSQL(dateFormat => $dateFormat,
					    sourceTable => $sourceTable,
					    ignorePrimaryKey => 1,
					    ignoreModificationColumns => 1,
					    naturalKey => $naturalKey);
	my $insertSql = $this->genInsertSQL(dateFormat => $dateFormat,
					    ignoreModificationColumns => 1,
					    ignorePrimaryKey => 1,
					    sourceTable => $sourceTable);

	my $dbh = $handle->getDbh();
	my $RaiseError = $dbh->{RaiseError};                                    # save so as to replace later
	my $AutoCommit = $dbh->{AutoCommit};                                    # save so as to replace later

	$dbh->{RaiseError} = 1;
	$dbh->{AutoCommit} = 0;                                                 # should perform better

	my $updateStmt = $dbh->prepare($updateSql);
	my $insertStmt = $dbh->prepare($insertSql);

	my $i;
	my $numUpdated = 0;
	my $numInserted = 0;
	for ( $i = 0; $i < $data->{rows} ; $i++) {
	    my $key = $data->{uc($naturalKey)}[$i] . $data->{lc($naturalKey)}[$i];  # I hate this ... there's got to be a better way
	    $this->debugPrint (2, "key data for $naturalKey is $key");

	    next if 
		($naturalKey && 
		 $keyMap && 
		 not $keyMap->{uc($data->{$naturalKey}[$i]) . lc($data->{$naturalKey}[$i])}); # skip if not in the key map

	    my $_numUpdated;
	    eval {
		$_numUpdated = $this->executeBindStatement(statement => $updateStmt,
							   rowNumber => $i,
							   key => $key,
							   ignorePrimaryKey => 1,
							   ignoreModificationColumns => 1,
							   sourceTable => $sourceTable,
							   data => $data);
	    };
	    Confess "$updateSql: $@" if $@;
	    if ($_numUpdated > 0) {
		$numUpdated++; 
	    } else {
		eval  {
		    $this->executeBindStatement(statement => $insertStmt,
						rowNumber => $i,
						ignorePrimaryKey => 1,
						ignoreModificationColumns => 1,
						sourceTable => $sourceTable,
						data => $data);
		}; 
		Confess "$insertSql: $@" if $@;
		$numInserted++;
	    }
	    $this->debugPrint (1, "wrote record $i");

	}
	$this->debugPrint(0, "updated $numUpdated, inserted $numInserted");

	$dbh->commit();
	$dbh->{RaiseError} = $RaiseError;                                       # restore old value for this
	$dbh->{AutoCommit} = $AutoCommit;                                       # restore old value for this
    };
}

################################################################################

sub Import {
   
=pod

=head3 $Table->Import (dateFormat => "any string", data => HASH*, keyMap => HASH, naturalKey => "any string", doUpdate => "any string", truncate => "any string", ignorePrimaryKey => "any string", ignoreModificationColumns => "any string", sourceTable => DB::Table*)

 - dateFormat ("any string")		 : can be used to specify the date format used in the input (default: "YYYY-MM-DD HH24:MI:SS")
 - data (HASH)		 : data to process
 - keyMap (HASH)		 : if a key map is provided, only those natural keys in the map will be executed on
 - naturalKey ("any string")		 : natural key of the data set
 - doUpdate ("any string")		 : update the data that matches the rows in the data set.  Requires a natural key defined on the table
 - truncate ("any string")		 : truncate this table if set
 - ignorePrimaryKey ("any string")		 : ignore the primary key of the table when updating values.  This is  implied by doUpdate
 - ignoreModificationColumns ("any string")		 : ignore modification columns (if they exist).
 - sourceTable (DB::Table)		 : source table metadata of type DB::Table->new()

import data into this table based on a results set

=cut

    my $this = shift;

    Confess "DB::Table->Import requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "YYYY-MM-DD HH24:MI:SS");
    my $data = $args{data};
    Confess "argument 'data' is required for DB::Table->Import()" unless exists $args{data};
        if (defined $data) { Confess "argument 'data' of method DB::Table->Import() is required to be of reference type HASH " unless ref($data) =~ /^HASH/;}
    my $keyMap = $args{keyMap};
        if (defined $keyMap) { Confess "argument 'keyMap' of method DB::Table->Import() is required to be of reference type HASH " unless ref($keyMap) =~ /^HASH/;}
    my $naturalKey = $args{naturalKey};
    my $doUpdate = $args{doUpdate};
    my $truncate = $args{truncate};
    my $ignorePrimaryKey = $args{ignorePrimaryKey};
    my $ignoreModificationColumns = $args{ignoreModificationColumns};
    my $sourceTable = $args{sourceTable};
    Confess "argument 'sourceTable' is required for DB::Table->Import()" unless exists $args{sourceTable};
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::Table->Import() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}



    do {
	my $startTime = [gettimeofday];

	do {
	    $ignorePrimaryKey = $ignoreModificationColumns = 1;
	} if $doUpdate;
	
	Confess "cannot truncate table when in update mode"
	    if $truncate and $doUpdate;

	Confess "natural key data required for update statements"
	    if $doUpdate and not defined $naturalKey;

	my $sql = ($doUpdate ? $this->genUpdateSQL(dateFormat => $dateFormat,
						   sourceTable => $sourceTable,
						   ignorePrimaryKey => $ignorePrimaryKey,
						   ignoreModificationColumns => $ignoreModificationColumns,
						   naturalKey => $naturalKey) 
		   : $this->genInsertSQL(dateFormat => $dateFormat,
					 sourceTable => $sourceTable));

	$this->debugPrint (1, ($doUpdate ? "update" : "insert") . " statement is $sql");

	my $handle = $this->getHandle();

	$handle->truncateTable(name => $this->getName()) if
	    $truncate && not $doUpdate;
	
	my $dbh = $handle->getDbh();
	my $RaiseError = $dbh->{RaiseError};                                    # save so as to replace later
	my $AutoCommit = $dbh->{AutoCommit};                                    # save so as to replace later

	$dbh->{RaiseError} = 1;
	$dbh->{AutoCommit} = 0;                                                 # should perform better
	
	my $stmt = $dbh->prepare($sql);
#	$this->debugPrint (4, "data is " .Dumper($data));

	my $i;
	for ( $i = 0; $i < $data->{rows} ; $i++) {
	    my $key = $data->{uc($naturalKey)}[$i] . $data->{lc($naturalKey)}[$i];
	    $this->debugPrint (2, "key data for $naturalKey is $key");

	    eval {
		$this->executeBindStatement(statement => $stmt,
					    rowNumber => $i,
					    key => $key,
					    ignorePrimaryKey => $ignorePrimaryKey,
					    ignoreModificationColumns => $ignoreModificationColumns,
					    sourceTable => $sourceTable,
					    data => $data) 
		    unless ($naturalKey && 
			    $keyMap && 
			    not $keyMap->{uc($data->{$naturalKey}[$i]) . lc($data->{$naturalKey}[$i])});
	    };
	    Confess "error in $sql: $@" if $@;
	    $this->debugPrint (1, "wrote record $i");

	}

	my $endTime = [gettimeofday];

	$this->debugPrint (0, ($doUpdate ? "updated" : "inserted") . 
			   " $i records to table " . $this->getName() . 
			   " in " . TV_INTERVAL(start => $startTime, end => $endTime));

	$this->debugPrint (0, "time per row is " . (tv_interval($startTime,$endTime)/$i))
	    if $i;
	
	$this->debugPrint (0, "rows/second is " . ($i/tv_interval($startTime,$endTime)));


	$dbh->commit();
	$dbh->{RaiseError} = $RaiseError;                                       # restore old value for this
	$dbh->{AutoCommit} = $AutoCommit;                                       # restore old value for this

    };
}

################################################################################

sub genInsertSQL {
   
=pod

=head3 $Table->genInsertSQL (dateFormat => "any string", ignorePrimaryKey => "any string", ignoreModificationColumns => "any string", sourceTable => DB::Table)

 - dateFormat ("any string")		 : can be used to specify the date format used in the input (default: "YYYY-MM-DD HH24:MI:SS")
 - ignorePrimaryKey ("any string")		 : ignore the primary key of the table
 - ignoreModificationColumns ("any string")		 : ignore modification columns (if they exist).
 - sourceTable (DB::Table)		 : truncate this table if set

generate a insert sql statement

=cut

    my $this = shift;

    Confess "DB::Table->genInsertSQL requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "YYYY-MM-DD HH24:MI:SS");
    my $ignorePrimaryKey = $args{ignorePrimaryKey};
    my $ignoreModificationColumns = $args{ignoreModificationColumns};
    my $sourceTable = $args{sourceTable};
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::Table->genInsertSQL() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}



    do {
	my %columns = %{$this->getColumns()};

	my $sql = "insert /*+ APPEND */ into " . $this->getName() . "(\n";
	my $handle = $this->getHandle();

	my $numColumns = 0;
	foreach my $columnName (sort (keys(%columns))) {
	    $sql .= ($numColumns++ ? ",\n" : "") . "\t$columnName"
		unless $this->ignoreColumn(ignorePrimaryKey => $ignorePrimaryKey,
					   columnName => $columnName,
					   ignoreModificationColumns => $ignoreModificationColumns);
	}	
	$sql .= "\n) values (\n";
	$numColumns=0;
	my $numBindParams = 0;
	foreach my $columnName (sort (keys(%columns))) {
	    if ($this->ignoreColumn(ignorePrimaryKey => $ignorePrimaryKey,
				    columnName => $columnName,
				    ignoreModificationColumns => $ignoreModificationColumns)) {
		$this->debugPrint(2, "ignoring column $columnName");
	    } else {
		$sql .= ($numColumns++ ? ",\n" : "") . "\t" . $handle->bindParam(data => $columns{$columnName},
										 sourceTable => $sourceTable,
										 dateFormat => $dateFormat);
		$numBindParams++;
		$this->debugPrint(2, "created bind param $numBindParams for column $columnName");
	    }
	    
	}
	$this->debugPrint (1, "created $numColumns bind columns");

	$sql . "\n)";
    };
}

################################################################################

sub ignoreColumn {
   
=pod

=head3 $Table->ignoreColumn (columnName => "any string"*, ignorePrimaryKey => "any string", ignoreModificationColumns => "any string")

 - columnName ("any string")		 : name of the column to evaluate
 - ignorePrimaryKey ("any string")		 : ignore the primary key of the table
 - ignoreModificationColumns ("any string")		 : ignore modification columns (if they exist).

returns true if this column should be ignored in inserts and updates

=cut

    my $this = shift;

    Confess "DB::Table->ignoreColumn requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $columnName = $args{columnName};
    Confess "argument 'columnName' is required for DB::Table->ignoreColumn()" unless exists $args{columnName};
    my $ignorePrimaryKey = $args{ignorePrimaryKey};
    my $ignoreModificationColumns = $args{ignoreModificationColumns};



    do {
	( ($ignorePrimaryKey and 
	   lc($columnName) eq lc($this->getPrimaryKeyName()))
	  or
	  ($ignoreModificationColumns and (
					   (lc($columnName) eq lc($this->getInsertedDateColumnName()))
					   or
					   (lc($columnName) eq lc($this->getUpdatedDateColumnName()))
					   ))
	  )
    };
}

################################################################################

sub genUpdateSQL {
   
=pod

=head3 $Table->genUpdateSQL (dateFormat => "any string", sourceTable => DB::Table, ignorePrimaryKey => "any string", ignoreModificationColumns => "any string", naturalKey => "any string"*)

 - dateFormat ("any string")		 : can be used to specify the date format used in the input (default: "YYYY-MM-DD HH24:MI:SS")
 - sourceTable (DB::Table)		 : truncate this table if set
 - ignorePrimaryKey ("any string")		 : ignore the primary key of the table
 - ignoreModificationColumns ("any string")		 : ignore modification columns (if they exist).
 - naturalKey ("any string")		 : natural key of the data set

generate a bind ready sql string for updating this table with all columns

=cut

    my $this = shift;

    Confess "DB::Table->genUpdateSQL requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "YYYY-MM-DD HH24:MI:SS");
    my $sourceTable = $args{sourceTable};
    eval {my $dummy = $sourceTable->isa("DB::Table");};Confess "$@\n" . Dumper($sourceTable) if $@;
    if (defined $sourceTable) { Confess "argument 'sourceTable' of method DB::Table->genUpdateSQL() is required to be of reference type DB::Table, but it looks to be of type " . ref ($sourceTable)  unless $sourceTable->isa("DB::Table");}
    my $ignorePrimaryKey = $args{ignorePrimaryKey};
    my $ignoreModificationColumns = $args{ignoreModificationColumns};
    my $naturalKey = $args{naturalKey};
    Confess "argument 'naturalKey' is required for DB::Table->genUpdateSQL()" unless exists $args{naturalKey};



    do {
	my %columns = %{$this->getColumns()};

 	my $sql = "update " . $this->getName() . " set \n";
	my $handle = $this->getHandle();

	my $numColumns =0;

	foreach my $columnName (sort (keys(%columns))) {
	    $sql .= ($numColumns++ ? ",\n" : "") . 
		"\t$columnName = " . $handle->bindParam(data => $columns{$columnName},
							sourceTable => $sourceTable,
							dateFormat => $dateFormat)
		unless $this->ignoreColumn(ignorePrimaryKey => $ignorePrimaryKey,
					   columnName => $columnName,
					   ignoreModificationColumns => $ignoreModificationColumns);
	}	
	$sql .= "\nwhere\t" . $naturalKey . " = ?\n";
	$sql;
    };
}

################################################################################

sub genSelectSQL {
   
=pod

=head3 $Table->genSelectSQL (dateFormat => "any string")

 - dateFormat ("any string")		 : can be used to specify the date format used in the input (default: "YYYY-MM-DD HH24:MI:SS")

generate a bind ready sql string for updating this table with all columns

=cut

    my $this = shift;

    Confess "DB::Table->genSelectSQL requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $dateFormat = ($args{dateFormat} ? $args{dateFormat} : "YYYY-MM-DD HH24:MI:SS");



    do {
	my %columns = %{$this->getColumns()};

 	my $sql = "select" ;
	my $numColumns = 0;
	my $handle = $this->getHandle();


	foreach my $columnName (sort (keys(%columns))) {
	    $sql .= ($numColumns++ ? ",\n" : "") . 
		"\t" . $handle->selectParam(data => $columns{$columnName},
					    dateFormat => $dateFormat);
	}	
	$sql .= "\nfrom\t" . $this->getName() . "\n";
	$sql;
    };
}

use Carp qw(cluck);

################################################################################

sub getField {
   
=pod

=head3 $Table->getField (data => "any string"*)

 - data ("any string")		 : column name to fetch

returns a field by name

=cut

    my $this = shift;

    Confess "DB::Table->getField requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::Table->getField()" unless exists $args{data};



    do {
	my %columns = %{$this->getColumns()};                                   # list of columns in this table
	$this->debugPrint (2, "fetching column $data");

#	cluck "I am here";

	$columns{$data} || $columns{lc($data)} || $columns{uc($data)};          # :(  - OK I need to write my own case insensitive hash class I think.
    };
}


################################################################################

sub modifyPrecision {
   
=pod

=head3 $Table->modifyPrecision (columnName => "any string", precision => "any string")

 - columnName ("any string")		 : name of the column to alter
 - precision ("any string")		 : new precision

modify the precision of a column

=cut

    my $this = shift;

    Confess "DB::Table->modifyPrecision requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $columnName = $args{columnName};
    my $precision = $args{precision};


    my $handle = $this->getHandle(); 
    my $name = $this->getName(); 

    do {
	$handle->setPrecision(@_, name => $name);
    };
}


################################################################################

sub getReferers {
   
=pod

=head3 $Table->getReferers ()


returns foreign key referers

=cut

    my $this = shift;

    Confess "DB::Table->getReferers requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;


    my $handle = $this->getHandle(); 
    my $name = $this->getName(); 

    do {
	$handle->getReferers(tableName => $name);
    };
}



################################################################################

sub getReferrals {
   
=pod

=head3 $Table->getReferrals ()


returns foreign key referrals

=cut

    my $this = shift;

    Confess "DB::Table->getReferrals requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;


    my $handle = $this->getHandle(); 
    my $name = $this->getName(); 

    do {
	$handle->getReferrals(tableName => $name);
    };
}

sub cloneSchema {
   
=pod

=head3 $Table->cloneSchema (from => "any string")

 - from ("any string")		 : name of the column to alter

take another table object, and replicate its schema

=cut

    my $this = shift;

    Confess "DB::Table->cloneSchema requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $from = $args{from};



    do {
	my %fromColumns = %{$from->getColumns()};
	my %toColumns = %{$this->getColumns()};

	my $handle = $this->getHandle();
	my $connectString = $this->getName() . "/" . $handle->getUser();

	my $newColumns;
	
	foreach my $columnName (sort (keys(%fromColumns))) {
	    $this->debugPrint(2, "examining $columnName");

	    my $toColumnName = $handle->validColumnName(data => $columnName);

	    if ($toColumns{$toColumnName}) {
		$this->debugPrint(2, "column $toColumnName exists in " . $connectString);
	    } else {
		$this->debugPrint(0, "column $toColumnName does not exist in " . $connectString);

		my $orig = $fromColumns{$columnName};
		$handle->cloneColumn(table =>, $this,
				     column => $orig);
		$newColumns = 1;
	    }
	    
	}
	$this->_new() if $newColumns; # rebuild table metadata
    };
}

1;
