


=pod

=head1 NAME - DB::SQLServerHandle

DB::SQLServerHandle description; stub description please expand

=head1 EXAMPLE


    my $DB::SQLServerHandle = $DB::SQLServerHandle->new();   # stub example .... expand


=cut

# This file was automatically generated from SQLServerHandle.pm.m80 by 
# bweinraub on li298-104 (Linux li298-104 2.6.38-linode31 #1 SMP Mon Mar 21 21:22:33 UTC 2011 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package DB::SQLServerHandle;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}


use base qw(DB::DBHandle);

=pod

=head1 INHERITANCE

DB::SQLServerHandle extends class DB::DBHandle ; refer to the documentation for that object for member variables and methods.

=cut

use fields qw( database interface debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item DB::SQLServerHandle->new()

initializes on object of type DB::SQLServerHandle

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{database} = {
          'name' => 'database',
          'description' => 'A SQL Server database to use'
        }
;
$_allSetters{database} = \&setDatabase;
$_allMemberAttributes{interface} = {
          'name' => 'interface',
          'description' => 'An interface from /etc/freetds.conf'
        }
;
$_allSetters{interface} = \&setInterface;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my DB::SQLServerHandle $this = shift;

    print STDERR "in DB::SQLServerHandle::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of DB::SQLServerHandle" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object DB::SQLServerHandle. typo ?\n";
        }
    }



    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {DB::SQLServerHandle::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::SQLServerHandle::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {DB::SQLServerHandle::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?DB::SQLServerHandle::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 database => "any string"

A SQL Server database to use

=cut

sub getDatabase {

=pod

=head3 $SQLServerHandle->getDatabase ()


getter for member database

=cut

    my $this = shift;





    return $this->{database};
}
sub setDatabase {

=pod

=head3 $SQLServerHandle->setDatabase (database => "any string")

 - database ("any string")		 : A SQL Server database to use

setter for member database

=cut

    my $this = shift;


    my $database = shift;



    $this->{database} = $database;
    return $database;
}



=pod

=head2 interface => "any string"

An interface from /etc/freetds.conf

=cut

sub getInterface {

=pod

=head3 $SQLServerHandle->getInterface ()


getter for member interface

=cut

    my $this = shift;





    return $this->{interface};
}
sub setInterface {

=pod

=head3 $SQLServerHandle->setInterface (interface => "any string")

 - interface ("any string")		 : An interface from /etc/freetds.conf

setter for member interface

=cut

    my $this = shift;


    my $interface = shift;



    $this->{interface} = $interface;
    return $interface;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $SQLServerHandle->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $SQLServerHandle->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from SQLServerHandle.pm.m80 by 
bweinraub on li298-104 (Linux li298-104 2.6.38-linode31 #1 SMP Mon Mar 21 21:22:33 UTC 2011 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $SQLServerHandle->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "DB::SQLServerHandle->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	if ($this->getNamespace()) {
	    $this->setInterface($ENV{$this->getNamespace() . "_interface"});
	    $this->setUser($ENV{$this->getNamespace() . "_user"});
	    $this->setPassword($ENV{$this->getNamespace() . "_password"});
	    $this->setDatabase($ENV{$this->getNamespace() . "_database"});
	}

	Confess "required member variable interface not set" unless $this->getInterface();
	Confess "required member variable database not set" unless $this->getDatabase();
	$this->setConnectString("dbi:Sybase:server=" . $this->getInterface());
	$this->connect();
	$this->getDbh()->do("use " . $this->getDatabase());
    };
}

sub getSmallDateFormat {
   
=pod

=head3 $SQLServerHandle->getSmallDateFormat ()


for mysql DATE fields (no time), this is the default date format

=cut

    my $this = shift;

    Confess "DB::SQLServerHandle->getSmallDateFormat requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    "Mon DD YYYY HH:MIAM";
}


sub DBIPrecisionToGenericPrecision {
   
=pod

=head3 $SQLServerHandle->DBIPrecisionToGenericPrecision (data => "any string"*)

 - data ("any string")		 : data to process

SQL Server "Length" doesn't conform to the standard used by Oracle or Mysql.  This is the actual storage size.  So we need to convert this to the bounding used by oracle (which is the number of digits to store).  Fun!  DBHandle contains a default method that just returns the passed in length

=cut

    my $this = shift;

    Confess "DB::SQLServerHandle->DBIPrecisionToGenericPrecision requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $data = $args{data};
    Confess "argument 'data' is required for DB::SQLServerHandle->DBIPrecisionToGenericPrecision()" unless exists $args{data};



    do {
	# 2^8 = 256 =~ 3 digits
	# 2^16 = 65536 =~ 5 digits
	# 2^24 = 16777216 =~ 8 digits
	# 2^32 = 4294967296 =~ 10 digits

#	my $ret = (($data * (2.5) + .9));
	my $ret = (($data * (2.5) + 1));  # the add 1 used to be ".9"; but this was failing in some instances.
	$ret =~ s/\..+?//g;
	$this->debugPrint (1, "calculating precision for length $data as $ret");
	$ret;
    };
}

=pod

=head1 INSTALLATION NOTES

=head2 freetds

SQLServerHandle uses DBD::Sybase for its DBD driver.

This requires the freetds package be installed on the box. 

When installing freetds, we suggest that freetds be built as follows:

./configure --prefix=/usr/local

It is then required at runtime that the following variables be set:

    export SYBASE=/usr/local
    export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH

or in the m80 repository:

    define_variable(SYBASE,/usr/local)
    append_variable(LD_LIBRARY_PATH,":/usr/local/lib")

=head2 Editing the interfaces file

To connect to a MS SQL database, this database needs to be described in an interface
file.

We recommend using the one in $SYBASE/freetds.conf ; although there are other options.  See
the freetds documentation for more information.  

=head3 Sample freetds.conf entry:

Use tds version of 7.0 for ms sql.

    [SolarWindsDev]
        host = 127.0.0.1
        port = 1433
        tds version = 7.0

=head2 Creating an m80 repository entry for a ms sql database

In an m80 environment file:
   
  PLEASE NOTE YOU MUST USE '<' INSTEAD of '[' in this example .... don't ask ;)

  [:  use M80Repository::SQLServer; :>
  [:= M80Repository::SQLServer->new(name => "M80ObjectName",
				    interface => "EntryFromFreeTDSFile",
				    user => "SQLServerUser",
				    database => "SQLServerDatabase",
				    password => "SQLServerPassword")->dump; :>
