


=pod

=head1 NAME - Crawler::RTWBS

Plug-in for DBCrawler; contains WBS specific postprocess routine for post RT crawling

=head1 EXAMPLE



  my $crawler = Crawler::CrawlerBase(recordsToCrawl => \@recordsToCrawl,
				     username => $username,
				     password => $password,
				     loginURL => $loginURL);

  my $RTWBS = $Crawler::RTWBS->new(crawler => $crawler);   
  $RTWBS->postProcess();


=cut

# This file was automatically generated from RTWBS.pm.m80 by 
# bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package Crawler::RTWBS;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use fields qw( crawler dbhandle debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item Crawler::RTWBS->new()

initializes on object of type Crawler::RTWBS

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{crawler} = {
          'required' => 1,
          'ref' => 'Crawler::CrawlerBase',
          'name' => 'crawler',
          'description' => 'Crawler object'
        }
;
$_allSetters{crawler} = \&setCrawler;
$_allMemberAttributes{dbhandle} = {
          'required' => 1,
          'ref' => 'DB::DBHandle',
          'name' => 'dbhandle',
          'description' => 'database handle'
        }
;
$_allSetters{dbhandle} = \&setDbhandle;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my Crawler::RTWBS $this = shift;

    print STDERR "in Crawler::RTWBS::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of Crawler::RTWBS" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object Crawler::RTWBS. typo ?\n";
        }
    }


    Confess "cannot initialize object of type Crawler::RTWBS without required member variable crawler"
        unless exists $this->{crawler};

    Confess "cannot initialize object of type Crawler::RTWBS without required member variable dbhandle"
        unless exists $this->{dbhandle};


    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {Crawler::RTWBS::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Crawler::RTWBS::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {Crawler::RTWBS::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Crawler::RTWBS::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 crawler => Crawler::CrawlerBase*

Crawler object

=cut

sub getCrawler {

=pod

=head3 $RTWBS->getCrawler ()


getter for member crawler

=cut

    my $this = shift;





    return $this->{crawler};
}
sub setCrawler {

=pod

=head3 $RTWBS->setCrawler (crawler => Crawler::CrawlerBase*)

 - crawler (Crawler::CrawlerBase)		 : Crawler object

setter for member crawler

=cut

    my $this = shift;


    my $crawler = shift;
    Confess "argument 'crawler' is required for Crawler::RTWBS->setCrawler()" unless defined $crawler;
    eval {my $dummy = $crawler->isa("Crawler::CrawlerBase");};Confess "$@\n" . Dumper($crawler) if $@;
    if (defined $crawler) { Confess "argument 'crawler' of method Crawler::RTWBS->setCrawler() is required to be of reference type Crawler::CrawlerBase, but it looks to be of type " . ref ($crawler)  unless $crawler->isa("Crawler::CrawlerBase");}



    $this->{crawler} = $crawler;
    return $crawler;
}



=pod

=head2 dbhandle => DB::DBHandle*

database handle

=cut

sub getDbhandle {

=pod

=head3 $RTWBS->getDbhandle ()


getter for member dbhandle

=cut

    my $this = shift;





    return $this->{dbhandle};
}
sub setDbhandle {

=pod

=head3 $RTWBS->setDbhandle (dbhandle => DB::DBHandle*)

 - dbhandle (DB::DBHandle)		 : database handle

setter for member dbhandle

=cut

    my $this = shift;


    my $dbhandle = shift;
    Confess "argument 'dbhandle' is required for Crawler::RTWBS->setDbhandle()" unless defined $dbhandle;
    eval {my $dummy = $dbhandle->isa("DB::DBHandle");};Confess "$@\n" . Dumper($dbhandle) if $@;
    if (defined $dbhandle) { Confess "argument 'dbhandle' of method Crawler::RTWBS->setDbhandle() is required to be of reference type DB::DBHandle, but it looks to be of type " . ref ($dbhandle)  unless $dbhandle->isa("DB::DBHandle");}



    $this->{dbhandle} = $dbhandle;
    return $dbhandle;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $RTWBS->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $RTWBS->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from RTWBS.pm.m80 by 
bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $RTWBS->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "Crawler::RTWBS->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



}


################################################################################

sub postProcess {
   
=pod

=head3 $RTWBS->postProcess ()


after a record has beeen recrawled, regenerate sugar circuit, account, and contact maps

=cut

    my $this = shift;

    Confess "Crawler::RTWBS->postProcess requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



   do {

       my $dbhandle = $this->getDbhandle();

       my $dbh = $dbhandle->getDbh();
       my $RaiseError = $dbh->{RaiseError};                                    # save so as to replace later
       my $AutoCommit = $dbh->{AutoCommit};                                    # save so as to replace later

       $dbh->{RaiseError} = 1;
       $dbh->{AutoCommit} = 0;                                                 # should perform better

       my %circuits = %{$dbhandle->getData(sql => "select id, name, carrier_circuit_id_c, carrier_circuit_idno2_c from sugar_circuit where deleted = 0", lc => 1)};
       my %accounts = %{$dbhandle->getData(sql => "select id, name from sugar_account where deleted = 0", lc => 1)};
       my %contacts = %{$dbhandle->getData(sql => "select sugar_contact_id id, first_name, last_name, account_name from sugar_contact_v where deleted = 0", lc => 1)};

       my $crawler = $this->getCrawler();

       foreach my $crawlerRequest (@{$crawler->getRecordsToCrawl()}) {
	   my $file = $crawlerRequest->getFile();

	   my $rtid = $file;
	   $rtid =~ s/.+?([0-9]+)\.html/$1/;
	   $this->debugPrint(0, "processing ticket $rtid");

	   Confess "bad crawlerRequest: " . Dumper($file)
	       unless $file;

	   $this->debugPrint(1, "reading $file");
	   open DATA, "< $file" or
	       do  {
		   carp "can\'t open $file : $!";
		   next; 
	       };

	   my $data;
	   while (<DATA>) {
	       $data .= $_;
	   }

	   $dbhandle->execute (sql => "delete from rt_circuit where rtticket_id = $rtid");

	   for (my $idx = 0; $idx  < $circuits{rows}; $idx++) {
	       my $id = $circuits{id}[$idx];
	       my $name = $circuits{name}[$idx];
	       next if $name =~ /test/;
	       my $carrier_circuit_id_c = $circuits{carrier_circuit_id_c}[$idx];
	       my $carrier_circuit_idno2_c = $circuits{carrier_circuit_idno2_c}[$idx];

	       Confess "fatal error , no name in circuit data"
		   unless $name;

	       my $_name = $name;
	       my $_carrier_circuit_idno2_c = $carrier_circuit_idno2_c;
	       my $_carrier_circuit_id_c = $carrier_circuit_id_c;

	       $_name =~ s/([\/\(\)])/\\$1/g;
	       $_carrier_circuit_id_c =~ s/([\/\(\)])/\\$1/g;
	       $_carrier_circuit_idno2_c =~ s/([\/\(\)])/\\$1/g;

	       eval {
		   if ($data =~ /$_name/i ||
		       ($carrier_circuit_id_c and 
			$data =~ /$_carrier_circuit_id_c/i and
			$carrier_circuit_id_c !~ /WBS Connect/) ||
		       ($carrier_circuit_idno2_c and
			$data =~ /$_carrier_circuit_idno2_c/i)) {
		       $this->debugPrint(0, "YES: $rtid matches $name - $carrier_circuit_id_c  - $carrier_circuit_idno2_c");
		       $dbhandle->execute (sql => "insert into rt_circuit (rtticket_id, sugar_circuit_id) values ($rtid, '$id')");
		   } else {
		       $this->debugPrint(1, "NO: $rtid matches $name");	    
		   }
	       };
	       Confess "\$name: $name ; \$carrier_circuit_id_c : $carrier_circuit_id_c ; \$carrier_circuit_idno2_c : $carrier_circuit_idno2_c : $@"
		   if $@;
	   }
	   $dbhandle->execute (sql => "delete from rt_account where rtticket_id = $rtid");

	   for (my $idx = 0; $idx  < $accounts{rows}; $idx++) {

	       my $name = $accounts{name}[$idx];
	       my $id = $accounts{id}[$idx];

	       if ($name) {
		   if ($data =~ /$name/) {
		       $this->debugPrint(0, "YES: $rtid matches account $name");
		       $dbhandle->execute (sql => "insert into rt_account (rtticket_id, sugar_account_id) values ($rtid, '$id')");
		   } else {
		       $this->debugPrint(1, "NO: $rtid matches $name");	    
		   }
	       }
	   }

	   $dbhandle->execute (sql => "delete from rt_contact where rtticket_id = $rtid");

	   for (my $idx = 0; $idx  < $contacts{rows}; $idx++) {
	       my $id = $contacts{id}[$idx];
	       my $account_name = $contacts{account_name}[$idx];
	       my $first_name = $contacts{first_name}[$idx];
	       my $last_name = $contacts{last_name}[$idx];

	       eval {
		   $first_name =~ s/\s//g;
		   $last_name =~ s/\s//g;
	       };
	       Confess "$first_name $last_name: $@" if $@;

	       if ($first_name and $last_name
		   and $first_name !~ /\?/ and $last_name !~ /\?/) {
		   eval {
		       if ($data =~ /$first_name\s+$last_name/i) {
			   $this->debugPrint(0, "YES: $rtid matches contact $first_name $last_name ($account_name)");
			   $dbhandle->execute (sql => "insert into rt_contact (rtticket_id, sugar_contact_id) values ($rtid, '$id')");
		       } else {
			   $this->debugPrint(1, "NO: $rtid matches $first_name $last_name");	    
		       }
		   };
		   Confess "$@: $first_name $last_name" if $@;
	       }
	   }
	   close DATA;

	   $dbh->commit();
        }

       $dbh->{RaiseError} = $RaiseError;                                       # restore old value for this
       $dbh->{AutoCommit} = $AutoCommit;                                       # restore old value for this
   };

}


