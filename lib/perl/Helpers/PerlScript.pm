

=pod

=head1 NAME - Helpers::PerlScript

Helper for generating PerlScripts

=head1 EXAMPLE




my $ps = Helpers::PerlScript->new( name => 'DirCleaner.pl' , 
                                   description => 'Cleans up task related directories',
                                   include => [DB::DBHandleFactory],
                                   getopts => [
 					       { tag => 'array=s@',
                                                 required => 't',
                                                 description => 'array of values ... ends up in the $main::directories variable',},
 					       { tag => 'scalar',
                                                 required => 't',
                                                 description => 'just a scalar ... ends up in $main::scalar',},
					       ],



=cut

# This file was automatically generated from PerlScript.pm.m80 by 
# bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package Helpers::PerlScript;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use Helpers::shellHelpers;
use fields qw( name description include getopts suppressRequiredVariableCheck date isRemoteScript debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item Helpers::PerlScript->new()

initializes on object of type Helpers::PerlScript

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{name} = {
          'name' => 'name',
          'description' => 'The name of this PerlScript - ends up in the POD for this script'
        }
;
$_allSetters{name} = \&setName;
$_allMemberAttributes{description} = {
          'name' => 'description',
          'description' => 'The description of this PerlScript - ends up in the POD for this script'
        }
;
$_allSetters{description} = \&setDescription;
$_allMemberAttributes{include} = {
          'ref' => 'ARRAY',
          'name' => 'include',
          'description' => 'An array ref listing all the libs that this library depends on'
        }
;
$_allSetters{include} = \&setInclude;
$_allMemberAttributes{getopts} = {
          'ref' => 'ARRAY',
          'name' => 'getopts',
          'description' => 'An array of hashes containing "tag", "variable", "default", "nomy" and "required". 

{ tag => "debug+", variable => "$debug", nomy => "t" } and { tag => "help", variable => "\\$help" } are provied by default. 

The tag is a Getopt::Long description of a commandline argument. The variable is the name of the variable that the commandline info should be saved into. nomy if set will not include a "my" on the front of the variable declaration (for scoping). The default sets the default value for that variable. And required defines whether the variable is required or not.'
        }
;
$_allSetters{getopts} = \&setGetopts;
$_allMemberAttributes{suppressRequiredVariableCheck} = {
          'name' => 'suppressRequiredVariableCheck',
          'description' => 'If set to true, then the getopts fn will not try to generate a requirement statement.'
        }
;
$_allSetters{suppressRequiredVariableCheck} = \&setSuppressRequiredVariableCheck;
$_allMemberAttributes{date} = {
          'name' => 'date',
          'description' => 'the date that this compiler was run'
        }
;
$_allSetters{date} = \&setDate;
$_allMemberAttributes{isRemoteScript} = {
          'name' => 'isRemoteScript',
          'description' => 'If this is set, then some additional functions (remote_docmd, remote_docmdi) are included into the generated perlscript.'
        }
;
$_allSetters{isRemoteScript} = \&setIsRemoteScript;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my Helpers::PerlScript $this = shift;

    print STDERR "in Helpers::PerlScript::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of Helpers::PerlScript" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object Helpers::PerlScript. typo ?\n";
        }
    }



    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {Helpers::PerlScript::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Helpers::PerlScript::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {Helpers::PerlScript::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Helpers::PerlScript::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 name => "any string"

The name of this PerlScript - ends up in the POD for this script

=cut

sub getName {

=pod

=head3 $PerlScript->getName ()


getter for member name

=cut

    my $this = shift;





    return $this->{name};
}
sub setName {

=pod

=head3 $PerlScript->setName (name => "any string")

 - name ("any string")		 : The name of this PerlScript - ends up in the POD for this script

setter for member name

=cut

    my $this = shift;


    my $name = shift;



    $this->{name} = $name;
    return $name;
}



=pod

=head2 description => "any string"

The description of this PerlScript - ends up in the POD for this script

=cut

sub getDescription {

=pod

=head3 $PerlScript->getDescription ()


getter for member description

=cut

    my $this = shift;





    return $this->{description};
}
sub setDescription {

=pod

=head3 $PerlScript->setDescription (description => "any string")

 - description ("any string")		 : The description of this PerlScript - ends up in the POD for this script

setter for member description

=cut

    my $this = shift;


    my $description = shift;



    $this->{description} = $description;
    return $description;
}



=pod

=head2 include => ARRAY

An array ref listing all the libs that this library depends on

=cut

sub getInclude {

=pod

=head3 $PerlScript->getInclude ()


getter for member include

=cut

    my $this = shift;





    return $this->{include};
}
sub setInclude {

=pod

=head3 $PerlScript->setInclude (include => ARRAY)

 - include (ARRAY)		 : An array ref listing all the libs that this library depends on

setter for member include

=cut

    my $this = shift;


    my $include = shift;
        if (defined $include) { Confess "argument 'include' of method Helpers::PerlScript->setInclude() is required to be of reference type ARRAY " unless ref($include) =~ /^ARRAY/;}



    $this->{include} = $include;
    return $include;
}



=pod

=head2 getopts => ARRAY

An array of hashes containing "tag", "variable", "default", "nomy" and "required". 

{ tag => "debug+", variable => "$debug", nomy => "t" } and { tag => "help", variable => "\$help" } are provied by default. 

The tag is a Getopt::Long description of a commandline argument. The variable is the name of the variable that the commandline info should be saved into. nomy if set will not include a "my" on the front of the variable declaration (for scoping). The default sets the default value for that variable. And required defines whether the variable is required or not.

=cut

sub getGetopts {

=pod

=head3 $PerlScript->getGetopts ()


getter for member getopts

=cut

    my $this = shift;





    return $this->{getopts};
}
sub setGetopts {

=pod

=head3 $PerlScript->setGetopts (getopts => ARRAY)

 - getopts (ARRAY)		 : An array of hashes containing "tag", "variable", "default", "nomy" and "required". 

{ tag => "debug+", variable => "$debug", nomy => "t" } and { tag => "help", variable => "\$help" } are provied by default. 

The tag is a Getopt::Long description of a commandline argument. The variable is the name of the variable that the commandline info should be saved into. nomy if set will not include a "my" on the front of the variable declaration (for scoping). The default sets the default value for that variable. And required defines whether the variable is required or not.

setter for member getopts

=cut

    my $this = shift;


    my $getopts = shift;
        if (defined $getopts) { Confess "argument 'getopts' of method Helpers::PerlScript->setGetopts() is required to be of reference type ARRAY " unless ref($getopts) =~ /^ARRAY/;}



    $this->{getopts} = $getopts;
    return $getopts;
}



=pod

=head2 suppressRequiredVariableCheck => "any string"

If set to true, then the getopts fn will not try to generate a requirement statement.

=cut

sub getSuppressRequiredVariableCheck {

=pod

=head3 $PerlScript->getSuppressRequiredVariableCheck ()


getter for member suppressRequiredVariableCheck

=cut

    my $this = shift;





    return $this->{suppressRequiredVariableCheck};
}
sub setSuppressRequiredVariableCheck {

=pod

=head3 $PerlScript->setSuppressRequiredVariableCheck (suppressRequiredVariableCheck => "any string")

 - suppressRequiredVariableCheck ("any string")		 : If set to true, then the getopts fn will not try to generate a requirement statement.

setter for member suppressRequiredVariableCheck

=cut

    my $this = shift;


    my $suppressRequiredVariableCheck = shift;



    $this->{suppressRequiredVariableCheck} = $suppressRequiredVariableCheck;
    return $suppressRequiredVariableCheck;
}



=pod

=head2 date => "any string"

the date that this compiler was run

=cut

sub getDate {

=pod

=head3 $PerlScript->getDate ()


getter for member date

=cut

    my $this = shift;





    return $this->{date};
}
sub setDate {

=pod

=head3 $PerlScript->setDate (date => "any string")

 - date ("any string")		 : the date that this compiler was run

setter for member date

=cut

    my $this = shift;


    my $date = shift;



    $this->{date} = $date;
    return $date;
}



=pod

=head2 isRemoteScript => "any string"

If this is set, then some additional functions (remote_docmd, remote_docmdi) are included into the generated perlscript.

=cut

sub getIsRemoteScript {

=pod

=head3 $PerlScript->getIsRemoteScript ()


getter for member isRemoteScript

=cut

    my $this = shift;





    return $this->{isRemoteScript};
}
sub setIsRemoteScript {

=pod

=head3 $PerlScript->setIsRemoteScript (isRemoteScript => "any string")

 - isRemoteScript ("any string")		 : If this is set, then some additional functions (remote_docmd, remote_docmdi) are included into the generated perlscript.

setter for member isRemoteScript

=cut

    my $this = shift;


    my $isRemoteScript = shift;



    $this->{isRemoteScript} = $isRemoteScript;
    return $isRemoteScript;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $PerlScript->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $PerlScript->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from PerlScript.pm.m80 by 
bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



require Exporter;
@Helpers::PerlScript::ISA = qw(Exporter);
@Helpers::PerlScript::EXPORT = qw(_envVar);

sub tagOrName {
    my $href = shift;

    $href->{tag} . $href->{name};
}

sub _new {
    my ($this) = @_;
    # default $debug and $help options


    unless ($this->getName()) {
	my $name = $ENV{M80_PATH_FILE};
	$name =~ s/\.m80$//;
	$this->setName($name);
    }
    push @{$this->{getopts}}, ({ tag => "trace", 
                                 variable => '$trace', 
                                 default => 0,
                                 nomy => 't',
                                 description => 'The $trace command line flag turns on trace functionality'}, 
                               { tag => "debug+", 
                                 variable => '$debug', 
                                 default => 0,
                                 nomy => 't',
                                 description => 'The $debug command line flag is additive and can be used with the &debugPrint subroutine'}, 
                               { tag => "help", 
                                 variable => '$help', 
                                 default => 0,
                                 description => 'The help command line flag will print the help message'}) 
	if $this->{getopts};
#    print STDERR "options: " , Dumper($this->getGetopts());

    $this->setDate( scalar localtime );

}

sub dump {
    
=pod

=head3 $PerlScript->dump ()


function used to dump the actual PerlScript generated code

=cut

    my $this = shift;

    Confess "Helpers::PerlScript->dump requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    my $ret = $this->_header();
    $ret .= Helpers::shellHelpers::printmsg();
    $ret .= Helpers::shellHelpers::docmdi();
    $ret .= Helpers::shellHelpers::docmd();
    if ($this->getIsRemoteScript) {
        $ret .= _remote_docmd();
        $ret .= _remote_docmdi();
    }
    $ret .= _cleanup();
    $ret .= _debugprint();
    $ret .= _Confess();
    $ret .= $this->_getopts();
    return $ret;
}

sub pod {
    
=pod

=head3 $PerlScript->pod ()


function used to dump the actual PerlScript generated poddocs

=cut

    my $this = shift;

    Confess "Helpers::PerlScript->pod requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    return $this->_pod();
}


sub _header {
    
=pod

=head3 $PerlScript->_header ()


INTERNAL function used to dump the PerlScript generated header

=cut

    my $this = shift;

    Confess "Helpers::PerlScript->_header requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    my $ret = '#!/usr/bin/perl

use Carp;
use Getopt::Long;
use Data::Dumper;
use Pod::Usage;
use File::Basename;

sub print_usage {
    if (scalar @_ > 0) {
        print STDERR "@_\n";
        exit(1);
    } else {
        pod2usage({ -exitval => 1, 
                    -verbose => ($debug ? $debug : 1),
                    -output  => \*STDERR});
    }
}

';
    my $raIncludes = $this->getInclude();
    for my $include ( @$raIncludes ) {
        $ret .= "use $include;\n";
    }

    return $ret;
}

sub _validateOptions {
    
=pod

=head3 $PerlScript->_validateOptions ()


INTERNAL function used to confirm that the "getopts" data has all the correct information

=cut

    my $this = shift;

    Confess "Helpers::PerlScript->_validateOptions requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    my $raGetopts = $this->getGetopts();
    my $errorMessage = '';

    for my $getopt ( @$raGetopts ) {
        unless ($getopt->{description}) {
            $errorMessage .= ", " if $errorMessage;
            $errorMessage .= "'" . tagOrName($getopt) . "'";
        }
    }
    if ($errorMessage) {
        Confess "The following options are defined, but do NOT have a description field: $errorMessage\n";
    }
}


sub _getopts {
    
=pod

=head3 $PerlScript->_getopts ()


INTERNAL function used to dump the PerlScript generated getopts

=cut

    my $this = shift;

    Confess "Helpers::PerlScript->_getopts requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




	if ($this->getGetopts()) {
	    $this->_validateOptions();
	    my ($varString, $getOptsString, $requiredString);

	    my $raGetopts = $this->getGetopts();

#
# TODO: not all Getopt::Long constructs are supported.  For instance something like "arg=s" => \@variable not implemented.
#


	    for my $getopt ( @$raGetopts ) {
		Confess "tag field not defined for " . Dumper($getopt)
		    unless tagOrName($getopt);
		unless ( $getopt->{variable} ) {
		    $getopt->{variable} = '$' . tagOrName($getopt) ;
		    $getopt->{variable} =~ s/(:|=)[a-z]//g;
		    $getopt->{variable} =~ s/\@//;
		}
		    
		my $var = $getopt->{variable};
		$var =~ s/^\$//;
		
		# variable representation
		if ($getopt->{nomy}) {
		    $varString .= $getopt->{variable};
		} else {
		    $varString .= 'my ' . $getopt->{variable};
		}

		if (exists $getopt->{default}) {
		    $varString .= ' = ' . '"' . $getopt->{default} . "\";\n";
		} else {
		    $varString .= ";\n";
		}
		$varString .= "$getopt->{variable} = \$ENV{$var} if \$ENV{$var};\n"; # slurp out of the environment if it exists

		# GetOptions Representation
		$getOptsString .= "\t'" . tagOrName($getopt) . "'\t=> \\$getopt->{variable},\n";

		# requirements
		unless ( $this->getSuppressRequiredVariableCheck ) {
		    if ($getopt->{required}) {
			$requiredString .= "unless ($getopt->{variable}) { Warn \"$var is required\" ; print_usage() ; } \n";
		    }
		}
	    }

	    my $ret;
	    $ret .= "$varString\nGetOptions( $getOptsString );\n\n";
	    $ret .= "print_usage() if \$help;\n";
	    $ret .= $requiredString if $requiredString;
	    
	    return $ret;
	}
}


sub _pod {
    
=pod

=head3 $PerlScript->_pod ()


INTERNAL function returns the canned pod for a script that uses this generator

=cut

    my $this = shift;

    Confess "Helpers::PerlScript->_pod requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    my $pod = "
\=pod

\=head1 NAME

";

    $pod .= $this->getName();
    $pod .= "    

\=head1 SYNOPSIS

";

    $pod .= $this->getDescription();

    my $raGetopts = $this->getGetopts();
    if ($raGetopts && scalar @$raGetopts) {
        $pod .= "

\=head1 ARGUMENTS

\=over 4

";
        for my $getopt ( @$raGetopts ) {
            my $tag = "'" . tagOrName($getopt) . "'";
            $tag = "[REQUIRED] $tag" if ($getopt->{required});
            $pod .= $this->_pod_item( marker => $tag,
                                      text   => $getopt->{description} );
        }
        
    $pod .= "

\=back

";
    }

    my $date = $this->getDate();
    my $uname = `uname -a`;
    $pod .= "

\=head1 PERLSCRIPT GENERATED SCRIPTS

This script was generated with the Helpers::PerlScript pre-compiler.

This file was automatically generated from the file: $ENV{M80PATH_FILE} by
$ENV{USER} on $ENV{HOSTNAME} ($uname) on $date.

The following functions are included by default. The functions all have 
prototypes that make the parens optional.

\=over 4

\=item printmsg (\@)

Will print a formatted message to STDERR.

\=item docmdi (\@)

Will run a system command and ignore the return code

\=item docmd (\@)

Will run a system command and exit with the return code of the child process, if it is non-zero

\=item debugPrint (\$\@)

Use it like C<debugPrint 1, 'Some info message'> or C<debugPrint 2, 'Some trace message'> and
it will print out a little more information than the printmsg command.

\=back

\=cut

# ## This is autogenerated documentation
";

    
    return $pod;
}

sub _pod_item {
    
=pod

=head3 $PerlScript->_pod_item (marker => "any string", text => "any string"*)

 - marker ("any string")		 : the value that should follow the "=item" text. Defaults to *
 - text ("any string")		 : the text that is the body of the "=item"

INTERNAL function returns a pod item block

=cut

    my $this = shift;

    Confess "Helpers::PerlScript->_pod_item requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $marker = $args{marker};
    my $text = $args{text};
    Confess "argument 'text' is required for Helpers::PerlScript->_pod_item()" unless exists $args{text};


    

    return "
=item $marker

$text

";
}


sub _debugprint () {
    my $o =<<'EOF';
sub debugPrint ($@) { 
    my $level = shift;
    if ($debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}
EOF

}

sub _cleanup () {
    my $o =<<'EOF';
sub cleanup ($@) { 
    my $exit_code = shift;
    printmsg @_ if scalar @_;
    printmsg "exiting with exit code = $exit_code";
    exit $exit_code;
}
EOF

}

sub _Confess () {
    my $o =<<'EOF';
use Term::ANSIColor qw(:constants);
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, "@_", RESET }
EOF
}

sub _remote_docmd () {
    my $o =<<'EOF';
sub remote_docmd (@) { 
    docmd "ssh -o StrictHostKeyChecking=no -o PreferredAuthentications=publickey $user\@$host '@_'";
}
EOF

}

sub _remote_docmdi () {
    my $o =<<'EOF';
sub remote_docmdi (@) { 
    docmdi "ssh -o StrictHostKeyChecking=no -o PreferredAuthentications=publickey $user\@$host '@_'";
}
EOF

}

sub _envVar {
    my $var = shift;
    my $h = {
	tag => $var,
	variable => '$' . $var,
	required => 't',
	description => $_[0],
	};
    $h;
}

sub mdimport {
    shift;
    my $o;
    while (@_) {
	my $var = shift;
	$o .= "
my \$$var = \$ENV{$var};
debugPrint(1, \"$var is \$$var\");
";
    }
    $o;
}

=pod

=head1 Handling of Environment Variables

The PerlScript default behaviour is to look in the process environment for a match to any getopt() variable.

=cut
