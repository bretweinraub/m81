package moduleHelpers;

use File::Basename;
use Data::Dumper;
use Carp;
use Exporter;
use Env;

use Term::ANSIColor qw(:constants);
sub Confess {confess BOLD, RED, @_, RESET}

@ISA = qw( Exporter );
@EXPORT = qw( _chainActions chainActions eventDispatch);

use vars qw( $VERSION );

$VERSION = '0.01';

require "options.pl";

sub moduleName {$_= basename(`pwd`); chomp; return $_}

#
# =pod
#
# =item 
#
# n - actionname
#
# =item
#
# c - command to execute (optional)
#
# C - generate callback 
#

sub _actionHeader {
    my $ret;
    my $arg = &_dn_options;

    return;
    $ret .= qq(  <!--);$ret .= "\n";
    $ret .= qq(    -- ACTION: $arg->{n});$ret .= "\n";
    $ret .= qq(    --);$ret .= "\n";
    $ret .= qq(    -- ONSUCCESS: $arg->{t});$ret .= "\n";
    $ret .= qq(    --);$ret .= "\n";
    $ret .= qq(    -->);$ret .= "\n";$ret .= "\n";
    return $ret;
}

sub _scoped_module {
    my ($s) = @_;
    unless ($s =~ /^__/) {
        $s = "q($SCOPED_MODULE-$s)" if $SCOPED_MODULE;
    }
    return $s;
}

sub simpleAction {
    my $ret;
    my $arg = &_dn_options;

#    $ret .= _actionHeader(@_);

    $arg->{m} .= ';' if $arg->{m} && $arg->{m} !~ /;$/;

    $ret .= "<!-- warning found duplicate action name $arg->{n} --> \n"
	if ($allActions{$arg->{n}});

    $allActions{$arg->{n}} = 1;

    return if $arg->{s};

    if ($arg->{p}) {
	$ret .= parentAction (%{$arg});
    } else {
	$ret .=qq(  <action name="$arg->{n}");
	do {
	    $ret .= "\n";
	    $ret .=qq(	  $arg->{extras});
	} if $arg->{extras};

        $arg->{c} = $arg->{n} . '.sh' if ! $arg->{c} && $SCOPED_MODULE;

	do {
	    $ret .= "\n";
	    $ret .=qq(	  command="$arg->{c}");
	} if $arg->{c};

	$ret .=qq(>);$ret .= "\n";
	do {
	    $ret .= "\n";
	    $ret .=qq(	  $arg->{xmlextras});
	} if $arg->{xmlextras};

	$ret .=qq(    <transitionMap>);$ret .= "\n";

        if ($arg->{dependency}) {
            for my $dep (@{ $arg->{dependency} }) {
		$ret .= qq[      <transition type="returnCode" value="^0\$"\n];
		if ($dep =~ /hook\.([\w_-]+).([\w+_-]+)]/) {
		    $ret .= qq[                  code="\$thistask->transitionTo(nextaction => \$thistask->fetchHook($1, nextAction) , callback => $thistask->getProperty(actionname))">\n];
		} else {
		    $ret .= qq[                  code="\$thistask->transitionTo(nextaction => q($dep)];
                    $ret .= qq[, callback => \$thistask->getProperty(actionname))">\n];
		    $ret .= qq[         <scope field="\$(history.$dep.succeeded)" value="^\$"/>\n];
		}
		$ret .= qq[      </transition>\n];
            }
        }

	my %assigned= ();
	if ($arg->{transitions}) {
	    foreach my $rc (keys (%{$arg->{transitions}})) {
		my $val = _scoped_module($arg->{transitions}->{$rc});
		print STDERR "simpleAction:: processing transition $rc -> $val\n";
		unless ($assigned{"$rc"}) {
		    $ret .=qq[      <transition type="returnCode" value="$rc" code="\$thistask->transitionTo(nextaction => $val];
                    $ret .= qq[, actionmapper => q($arg->{m})] if $arg->{m};
                    $ret .= qq[, pop => true] if $arg->{pop} && $rc eq '0';
                    $ret .=qq(\)"/>);$ret .= "\n";
		    $assigned{$rc} = 1;
		}
	    }
	} 
	unless ($assigned{'0'}) {
            my $val = _scoped_module($arg->{t});
	    $ret .=qq[      <transition type="returnCode" value="^0\$" code="\$thistask->transitionTo(nextaction => $val];
            $ret .= qq[, actionmapper => q($arg->{m})] if $arg->{m};
            $ret .= qq[, pop => true] if $arg->{pop};
            $ret .=qq(\)"/>);$ret .= "\n";
	}
	unless ($assigned{'\\d+'}) {
	    $ret .=qq(      <transition type="returnCode" value="\\d+" code="\$thistask->transitionTo(q(__FAILED__))"/>);$ret .= "\n";
	}

	$ret .=qq(    </transitionMap>);$ret .= "\n";
	$ret .=qq(  </action> );$ret .= "\n";$ret .= "\n";
    }
    return $ret;
}

sub externalReturnAction {
    my $ret;
    my $arg = &_dn_options;

    foreach $taskname (@{$arg->{T}}) {
	if (defined ($arg->{t})) {
	    $ret .= "  <!-- $arg->{comment} callback handler ($arg->{n}) for task $taskname to next action ($arg->{t}) -->\n";
	    $ret .= simpleAction (n => "post-$taskname-" . $arg->{n},
				  t => $arg->{t},
				  c => q(exit 0),
				  m => $arg->{m});
	}
    }
    return $ret;
}

sub childTasks {
    my $ret;
    my $arg = &_dn_options;
    my @actions = $arg->{a} ? @{$arg->{a}} : @{$arg->{actions}};

    map { 
	my $parental = assigner ($_, "p", "parent");
	my $name = assigner ($_, "n", "name");
	if ($parental) {
	    $ret .= "  <!-- autogenerated task block for $name -->\n";
#	    print Dumper ($_);
	    $ret .= qq(  <task name="$name"/>\n);
	    $ret .= childTasks(a => $_->{chain}->{a} || $_->{chain}->{actions})
		if $_->{chain};
	    
	}
    } (@actions);
    return $ret;
}

sub parentActionName {
    my $arg = &_dn_options;
    $arg->{p} ? $arg->{n} . '_parent' : $arg->{n}
};

sub parentAction {
    my $ret;
    my $arg = &_dn_options;

    $ret .= "  <!-- use parent/child formulation for action $arg->{n} -->\n";
    my $actionname = $arg->{n};
    $ret .=qq(  <action name="$actionname");
    do {
	$ret .= "\n";
	$ret .=qq(	  command="$arg->{c}");
    } if $arg->{c};
    do {
	$ret .= "\n";
	$ret .=qq(	  $arg->{extras});
    } if $arg->{extras};
    $ret .=qq(>);$ret .= "\n";

    do {
	$ret .= "\n";
	$ret .=qq(	  $arg->{xmlextras});
    } if $arg->{xmlextras};
    $ret .=qq(    <transitionMap>);$ret .= "\n";
    my %assigned = ();
    if ($arg->{transitions}) {
	foreach my $rc (keys (%{$arg->{transitions}})) {
	    my $val = _scoped_module($arg->{transitions}->{$rc});
	    print STDERR "parentAction:: processing transition for code $rc \n";
	    my $ttype;
	    unless ($assigned{"$rc"}) {
		$ttype = ($rc =~ /[A-Z]/) ? "parent" : "returnCode";
		$ret .=qq[      <transition type="$ttype" value="$rc" code="\$thistask->transitionTo($val];
                    $ret .= qq[, q($arg->{m})] if $arg->{m};
                    $ret .=qq(\)"/>);$ret .= "\n";
		$assigned{"$rc"} = 1;
	    }
	}
    } 

    unless ($assigned{ALLSUCCESS}) {
        my $val = _scoped_module($arg->{t});
	$ret .=qq[      <transition type="parent" value="ALLSUCCESS" code="\$thistask->transitionTo(nextaction => $val];
    $ret .=qq(, actionmapper => q($arg->{m})) if $arg->{m};
    $ret .= qq[, pop => true] if $arg->{pop};
    $ret .=qq(\)"/>);$ret .= "\n";
    }
    unless ($assigned{ANYFAIL}) {
	$ret .=qq[      <transition type="parent" value="ANYFAIL" code="\$thistask->transitionTo(__FAILED__];
    $ret .=qq(, q($arg->{m})) if $arg->{m};
    $ret .=qq(\)"/>);$ret .= "\n";
    }
    unless ($assigned{q[0]}) {
	$ret .=qq[      <transition type="returnCode" value="^0\$" code="\$thistask->transitionTo(__WAITING__];
        $ret .= qq[, q($arg->{m})] if $arg->{m};
        $ret .=qq(\)"/>);$ret .= "\n";
    }
    unless ($assigned{'\\d+'}) {
	$ret .=qq(      <transition type="returnCode" value="\\d+" code="\$thistask->transitionTo(q(__FAILED__))"/>);$ret .= "\n";
    }



    $ret .=qq(    </transitionMap>);$ret .= "\n";
    $ret .=qq(  </action> );$ret .= "\n";$ret .= "\n";
    return $ret;
}

# experimental moduleHelpers code.

sub validate {
    while ($#_ > -1) {
	my $action = $_[0];
	do { 
	    carp "undefined action name";
	    return 0;
	} unless $action->{name} || $action->{n};
	shift;
    }
}

sub HasAValue {
    my ($arg) = @_;

    return 1 if ($arg) ;
    return 0;
}

sub assigner {
    my $action = shift;

    foreach (@_) {
	return $action->{$_} if $action->{$_};
    }
}

sub _chainActions {
    my $ret;
    my $arg = &_dn_options;

    my $mapper = assigner($arg, "m", "mapper", "map");

    my @actions = $arg->{a} ? @{$arg->{a}} : @{$arg->{actions}};

    my $scoped = $arg->{scoped};

    %allActions = ();

    Confess "no data argument received in _chainActions" unless exists($arg->{data});
    Confess "no error text argument received in _chainActions" unless exists($arg->{error});

    while ($#actions > -1) {
	$thisaction = $actions[0];
	$nextaction = $actions[1];

	my $extras = assigner ($thisaction, "extras");
	my $xmlextras = assigner ($thisaction, "xmlextras");

	my $name = $thisaction->{n} || $thisaction->{name};
	my $target = $thisaction->{t} || $thisaction->{target};
	my $external = $thisaction->{e} || $thisaction->{external};
	my $parental = $thisaction->{p} || $thisaction->{parent};
	my $command = $thisaction->{c} || $thisaction->{command};
	my $Callback = $thisaction->{C} || $thisaction->{Callback};
	my $Preserve_action_name = $thisaction->{Preserve_action_name} || $thisaction->{P};
	my $SuppressParentExitBlock = $thisaction->{SuppressParentExitBlock} || $thisaction->{S};
	my $suppress = $thisaction->{s} || $thisaction->{suppressGeneration};
	my $transitions = $thisaction->{T} ?  $thisaction->{T} : $thisaction->{Transitions};
	my $thismapper = assigner ($thisaction, "m", "mapper");
        
        my $dependencies = $thisaction->{d} || $thisaction->{dependencies};
        my $pop = $thisaction->{pop};
	my $external = assigner ($thisaction, "e", "external");

	my $nextactionname = $nextaction->{n} || $nextaction->{name};
	my $nextparental = assigner ($nextaction, "p", "parent", "Parent", "P");

	# validation.

	if ($#actions eq 0 and ((not HasAValue($target) and 
				 not HasAValue($external))
				and
				( (not HasAValue($Callback))
				  or
				  (HasAValue($Callback) and HasAValue($transitions->[0])))))
	{
	    ${$arg->{error}} = "unterminated chain detected, use t|target => \"NEXTACTIONNAME\" or e|external => \"true\" (look near action $lastActionRead)";
            if (HasAValue($transitions->[0]) and not HasAValue($Callback)) {
                ${$arg->{error}} .= "\nSpecify a Callback for actions that have transistions, but no 'next steps'.";
            }
	    print "Bad action appears to be:\n";
	    print Dumper($thisaction);

	    return 0;
	}

	if ($#actions ne 0 and HasAValue($target)) {
	    ${$arg->{error}} .= 't|target => "ANYVALUE" only valid in last action of a chain' . "\n";
	    return 0;
	}
	    
	validate($thisaction);

	# construct current block.

	$thisactionname = ((HasAValue($parental) and not 
			    HasAValue($Preserve_action_name))                   # is a parent and not set up to restrict name munging
			   ? $name . "_parent" : $name);

        # calculate the next target name
#
        $target = parentActionName (n => $nextactionname, p => $nextparental) unless $target;

        # construct dependency blocks
        if ($dependencies) {
	    $ret .= "  <!-- dependency chain ($thisactionname ~ dependency_$thisactionname) -->\n";            
	    $ret .= simpleAction ( n => $thisactionname,
				   t => 'dependency_' . $thisactionname,
				   c => 'exit 0',
				   s => $suppress,
                                   dependency => $dependencies,
				   m => $thismapper ? $thismapper : $mapper,
                                   pop => $pop,
                                   );
            $command = "$thisactionname.sh" unless $command;
            $thisactionname = 'dependency_' . $thisactionname;
            undef $dependencies;
            
        }


	
	# construct next action block
	
	if (not HasAValue($external) and
	    not HasAValue($Callback) and
	    not HasAValue($suppress)) {


	    $ret .= "  <!-- simple chain ($thisactionname ~ $target) -->\n";

	    $ret .= simpleAction ( n => $thisactionname,
				   t => $target,
				   c => $command,
				   s => $suppress,
				   extras => $extras,
				   xmlextras => $xmlextras,
				   transitions => $thisaction->{transitions},
				   p => $parental,
				   m => $thismapper ? $thismapper : $mapper,
                                   pop => $pop,
                                   );
	} elsif ($Callback) {
	    $ret .= "  <!-- callback chain ($thisactionname) -->\n";

	    $ret .= simpleAction ( n => $thisactionname,
				   m => $thismapper ? $thismapper : $mapper,
				   c => $command,
				   extras => $extras,
				   xmlextras => $xmlextras,
				   p => $parental,
				   transitions => $thisaction->{transitions},
				   t => q[q(post-) . $thistask->getProperty(taskname) . q(-) . $thistask->getProperty(actionname)],
				   s => $suppress,
                                   pop => $pop,
                                   ); 
					   
			   
	    $ret .= externalReturnAction (m => $thismapper ? $thismapper : $mapper,
					  n => $thisactionname,
					  p => $parental,
					  transitions => $thisaction->{transitions},
					  t => $target || parentActionName (n => $nextactionname,
									    p => $nextparental),
					  T => $transitions,
					  comment => "local"
					  );
	} elsif ($external) {

	    if (not HasAValue($transitions->[0])) {
		${$arg->{error}} .= 'define T|Transitions => "[task1, ... taskn]" when creating an external task' . "\n";
		return 0;
	    }
	    
	    $ret .= externalReturnAction (m => $thismapper ? $thismapper : $mapper,
					  c => $command,
					  n => $thisactionname,
					  transitions => $thisaction->{transitions},
					  p => $parental,
					  t => parentActionName(n => $nextactionname, p => $nextparental),
					  T => $transitions,
					  comment => "external");
	} 

	if ($parental and not HasAValue($SuppressParentExitBlock)) {
	    if ($thisaction->{chain}->{a}) {
		$ret .= chainActions(a => $thisaction->{chain}->{a},
				     m => $thisaction->{chain}->{m});
	    } else {
		$ret .= chainActions(a => [{n => $thisaction->{n},
					    t => __SUCCESS__},
					   ]);
	    }
	}

	$lastActionRead=$name;
	shift (@actions);
    }
    ${$arg->{data}} = $ret;
    1;
}

sub chainActions {
    my ($data, $error);
    my $rc = _chainActions (@_, data => \$data, error => \$error);
    Confess "No data returned from _chainActions: ($error)" unless $data;
    Confess "$error" unless $rc;
    return $data;
}

sub parallelKey {
    my $name = shift;
    my $o =<<EOF;
    <task name="$name" 
        startAction="$name"
        maxParallelism="1"
        parallelismKey="\$(task.parallelKeyNamespace)" />

EOF
    return $o;
}

sub parallelKeys {
    my $o = '';
    for my $name (@_) {
        $o .= parallelKey($name);
    }
    return $o;
}

sub eventDispatch {
    my %args = @_;
#    print STDERR "eventDispatch: %args\n";
    my $eventname = $args{eventName};
    my $supportAOP = $args{supportAOP};                                         # generate pre- and post- blocks
    my $adapter = $args{adapter} || "XMLEventDispatcher.pl";
    $type = $args{interfaceType};
    $type ||= $SCOPED_MODULE;
    my $additionalMapperObjects = $args{additionalMapperObjects};

    # put a '-a' on $additionalMapperObjects
    my $additionalMapperText = '';
    for my $o (split /(\s|,)/, $additionalMapperObjects) {
        $additionalMapperText .= " -a $o";
    }

    my %o;

    my $controllerPath;                                                         # Path to find controller bits; need to account for DEV=t flag.
    $controllerPath = $ENV{DEV} ? '$(env.CONTROLLER_deploy_PATH)' : '$(env.CONTROLLER_DEPLOY_DIR)';

    if ($supportAOP) {
	%o = (a => [{n => $eventname, 
		     c => 'exit 0',},
		    {n => "pre-$eventname",
		     c => "$adapter -taskname pre-$eventname -e $eventname -i $type -scopedActionList $controllerPath/_AllScopedActions.pl",
		     S => 1,
		     p => true},
		    {n => "_$eventname",
		     c => "$adapter -e $eventname -i $type -scopedActionList $controllerPath/_AllScopedActions.pl",
		     S => 1,
		     p => true},
		    {n => "post-$eventname",
		     c => "$adapter -taskname post-$eventname -e $eventname -i $type -scopedActionList $controllerPath/_AllScopedActions.pl",
		     t => '__SUCCESS__',
		     pop => true,
		     S => 1,
		     p => true},],
	      scoped => 1);
    } else {
	%o = (a => [{n => $eventname, # . 'OnAll' . $moduleHelpers::SCOPED_MODULE,
		     p => true,
		     Preserve_action_name => true, # dont munge the action name
		     SuppressParentExitBlock => true,
		     c => "$adapter -e $eventname -i $type -scopedActionList $controllerPath/_AllScopedActions.pl",
		     pop => true,
		     t => __SUCCESS__}]);
    }
    return %o;
}

sub interfaceModule {
    my %args = @_;
    my (@events) = @{ $args{events} };
    my $supportAOP = $args{supportAOP};                                         # generate pre- and post- blocks
    my $adapter = $args{adapter} ? $args{adapter} : "XMLEventDispatcher.pl";
    
    my %event_map = ();
    for my $event (@events) { 
        if (ref $event eq 'HASH') { # complex event information:

            #
            # require Interface Documentation!
            #
            unless (! $moduleHelpers::docsRequired || $event->{description} && $MODULE_DESCRIPTION) {
            Confess <<EOE;
INTERFACE DOCUMENTATION REQUIRED

Specify documentation for both the module and the interfaces, particularily
'$event->{eventName}' event in the '$SCOPED_MODULE' Interface definition.

This will probably look something like:



my \$moduleHelpers::SCOPED_MODULE = 'ModuleName';

my \$moduleHelpers::MODULE_DESCRIPTION = 'A Description of that this module is/does';

my \@events = ( {eventName => "initialize",
                description => 'Prodvide a description of this interface here!' },);

print moduleHelpers::interfaceModule( events => \\\@events );

EOE

            }
            my %tmp = eventDispatch(%$event,
				    supportAOP => $supportAOP,
				    adapter => $adapter);
            $event_map{ $event } = \%tmp;
        } else {
	    Confess "non hash event arguments to interfaceModule() are no longer supported; convert to hashes";

#             my %tmp = eventDispatch(eventName => $event,
# 				    adapter => $adapter);
#             $event_map{ $event } = \%tmp;
        }
    }

    #
    # side effect - create docs
    createInterfaceDocs(@_);

    my $ret = "<tasks>\n";
    for my $event (@events) {
        $ret .= childTasks(%{ $event_map{$event} } );
    } 
    $ret .= "</tasks>\n";

    $ret .= "<actions>\n";
    for my $event (@events) {
        $ret .= chainActions(%{ $event_map{$event} });
    }
    $ret .= "</actions>\n";
    
    return $ret;
}

=pod

=over 4

=item generateUXF

=back

This routine will generate a UMLET description of the entities in module.xml.

=cut

sub generateUXF {

    my $uxfFile = $M80PATH_FILE;
    $uxfFile =~ s/\.m80$//;

    $uxfFile .= ".uxf";

    open UXFFILE, "> $uxfFile"
	or Confess "failed to open file $uxfFile";

    my $ret = "";

    if (ref ($_[0]) =~ /HASH/) {

	$ret .= '

  <element><type>com.umlet.element.base.Class</type>
    <coordinates>
      <x>1090</x>
      <y>230</y>
      <w>210</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>' . $SCOPED_MODULE . '
--';
	foreach $href (@_) {
	    my $interfacePoint = $href->{a}[0]->{n};
	    $ret .= "
/+$interfacePoint()/";
	    my @actions =@{$href->{a}};
	    for (my $i = 1 ; $i <= $#actions ; $i++) {
		$ret .= "
-&gt; $actions[$i]{n}()";
	    }
	}
	$ret .= '
    </panel_attributes>
    <additional_attributes>
    </additional_attributes>
  </element>

';
    } else {
#
# This block is for interface modules
#
	my @events = @{$_[0]};
	$ret .= '

  <element><type>com.umlet.element.base.Class</type>
    <coordinates>
      <x>1090</x>
      <y>230</y>
      <w>210</w>
      <h>110</h>
    </coordinates>
    <panel_attributes>&lt;&lt;' . $SCOPED_MODULE . '&lt;&lt;
--';
	foreach my $event (@events) {
	    my $interfacePoint;
	    if (ref($event) =~ /HASH/) {
		$interfacePoint = $event->{eventName};
	    } else {
		$interfacePoint = $event;
	    }
	    $ret .= "
/+$interfacePoint()/";
	}
	$ret .= '
    </panel_attributes>
    <additional_attributes>
    </additional_attributes>
  </element>

';


    }

#    return $ret;
    print UXFFILE $ret;
    close UXFFILE;
    return "<!-- UXF description left in $uxfFile --> ";

}

sub buildUXFfromActions {
    my $ret = "";
    my %args = @_;
    my $href = $args{href};
    my $depth = $args{depth};
    my $suppress = $args{suppress};
    my $skipFirstAction = $args{skipFirstAction};

    
    print Dumper($href);

    $ret .= '&gt;' unless $suppress;

    my $chainName = $href->{a}[0]->{n};

    my @actions = @{$href->{a}};

    for (my $i = 0 ; $i <= $#actions ; $i++) {
	my $thisAction = $actions[$i];
	$ret .= $thisAction->{n} . "\n" unless $skipFirstAction;

	if ($thisAction->{d}) {
	    my @depends = @{$thisAction->{d}};

	    $ret .= '&gt;';

	    foreach $dep (@depends) {
		if (exists $allChains{$dep}) {
		    $ret .= "$dep\n";
		    $ret .= buildUXFfromActions(href => $allChains{$dep},depth => $depth+1, skipFirstAction => true) ;
		} else {
		    $ret .= "$dep\n";
		}
	    }

	    $ret .= '&lt;';
	}
	
	if ($thisAction->{chain}) {
	    $ret .= buildUXFfromActions(href => $thisAction->{chain}, depth => $depth+1) ;
	} 
    }

    $ret .= '&lt;' unless $suppress;

    return $ret;
}

    

sub generateUXFProcessDoc 
{
    my $uxfFile = $M80PATH_FILE;
    $uxfFile =~ s/\.m80$//;

    $uxfFile .= ".uxf";

    open UXFFILE, "> $uxfFile"
	or Confess "failed to open file $uxfFile";

    my $ret = "";

    %allChains = ();

    my $num = -1;

    foreach $href (@_) {
	my $chainName = $href->{a}[0]->{n};
	$allChains{$chainName} = $href;
    }

    $ret .= '<?xml version="1.0" encoding="UTF-8"?><umlet_diagram>'; 
    foreach $href (@_) {
	my $chainName = $href->{a}[0]->{n};
	$allChains{$chainName} = $href;
	$num++;

	$ret .= '<element><type>com.umlet.element.custom.PackageAggregationHierarchy</type><coordinates><x>90</x><y>' . sprintf ("%d", $num * 100 + 20) . '</y><w>660</w><h>100</h></coordinates><panel_attributes>';
	
	$ret .= buildUXFfromActions (href => $href,depth => 0, suppress => 1);
	$ret .= '</panel_attributes><additional_attributes></additional_attributes></element>
';
    }

    $ret .= '</umlet_diagram>
';

    print UXFFILE $ret;
    close UXFFILE;
    return "<!-- UXF description left in $uxfFile --> ";
    
}

sub createInterfaceDocs {
    my %args = @_;
    my (@events) = @{ $args{events} };
    my $supportAOP = $args{supportAOP};                                         # generate pre- and post- blocks
    my $adapter = $args{adapter} ? $args{adapter} : "XMLEventDispatcher.pl";

    return unless $SCOPED_MODULE;
    $MODULE_DESCRIPTION ||= "No module documentation provided!";

    my $podFile = $SCOPED_MODULE . '.pod';
    open POD, "> $podFile" or Confess "failed to open file $podFile";

    my $ret = "
=pod

=head1 INTERFACE NAME

$SCOPED_MODULE

=head2 DESCRIPTION

$MODULE_DESCRIPTION

=head1 INTERFACE DEFINITION

";
    
    for my $event (@events) { 
        $event->{description} ||= "No description provided!";
        $ret .= "
=head2 $event->{eventName}

$event->{description}

";
    }

    $ret .= "
=cut

";

    print POD $ret;
    close POD;
}

sub createSimpleModule {
    my ($module, $name) = @_;
    my %module = %{$module};

    print '
<!-- begin module.xml for $name  -->
<tasks>
';
    for $m (values %module) {
        print moduleHelpers::childTasks(%$m);
    }

    print '
</tasks>

<actions>
';
    for $m (values %module) {
        print moduleHelpers::chainActions(%$m);
    }

    print '
</actions>
<!-- end module.xml for $name -->
';
}

1;
