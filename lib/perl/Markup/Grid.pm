



=pod

=head1 NAME - Markup::Grid

Markup Grid for creation of tabular reports based upon SQL statements

=head1 EXAMPLE

No example(s) have been documented for this object.

=cut

# This file was automatically generated from Grid.pm.m80 by 
# bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package Markup::Grid;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use DB::RowSet;
use fields qw( sql dbh title rowSet debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item Markup::Grid->new()

initializes on object of type Markup::Grid

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{sql} = {
          'required' => 1,
          'name' => 'sql',
          'description' => 'sql query to render into a grid'
        }
;
$_allSetters{sql} = \&setSql;
$_allMemberAttributes{dbh} = {
          'required' => 1,
          'ref' => 'DBI::db',
          'name' => 'dbh',
          'description' => 'the DBI handle for the database'
        }
;
$_allSetters{dbh} = \&setDbh;
$_allMemberAttributes{title} = {
          'name' => 'title',
          'description' => 'title of the grid'
        }
;
$_allSetters{title} = \&setTitle;
$_allMemberAttributes{rowSet} = {
          'ref' => 'DB::RowSet',
          'name' => 'rowSet',
          'description' => 'results of an executed query'
        }
;
$_allSetters{rowSet} = \&setRowSet;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my Markup::Grid $this = shift;

    print STDERR "in Markup::Grid::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of Markup::Grid" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object Markup::Grid. typo ?\n";
        }
    }


    Confess "cannot initialize object of type Markup::Grid without required member variable sql"
        unless exists $this->{sql};

    Confess "cannot initialize object of type Markup::Grid without required member variable dbh"
        unless exists $this->{dbh};


    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {Markup::Grid::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Markup::Grid::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {Markup::Grid::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?Markup::Grid::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 sql => "any string"*

sql query to render into a grid

=cut

sub getSql {

=pod

=head3 $Grid->getSql ()


getter for member sql

=cut

    my $this = shift;





    return $this->{sql};
}
sub setSql {

=pod

=head3 $Grid->setSql (sql => "any string"*)

 - sql ("any string")		 : sql query to render into a grid

setter for member sql

=cut

    my $this = shift;


    my $sql = shift;
    Confess "argument 'sql' is required for Markup::Grid->setSql()" unless defined $sql;



    $this->{sql} = $sql;
    return $sql;
}



=pod

=head2 dbh => DBI::db*

the DBI handle for the database

=cut

sub getDbh {

=pod

=head3 $Grid->getDbh ()


getter for member dbh

=cut

    my $this = shift;





    return $this->{dbh};
}
sub setDbh {

=pod

=head3 $Grid->setDbh (dbh => DBI::db*)

 - dbh (DBI::db)		 : the DBI handle for the database

setter for member dbh

=cut

    my $this = shift;


    my $dbh = shift;
    Confess "argument 'dbh' is required for Markup::Grid->setDbh()" unless defined $dbh;
    eval {my $dummy = $dbh->isa("DBI::db");};Confess "$@\n" . Dumper($dbh) if $@;
    if (defined $dbh) { Confess "argument 'dbh' of method Markup::Grid->setDbh() is required to be of reference type DBI::db, but it looks to be of type " . ref ($dbh)  unless $dbh->isa("DBI::db");}



    $this->{dbh} = $dbh;
    return $dbh;
}



=pod

=head2 title => "any string"

title of the grid

=cut

sub getTitle {

=pod

=head3 $Grid->getTitle ()


getter for member title

=cut

    my $this = shift;





    return $this->{title};
}
sub setTitle {

=pod

=head3 $Grid->setTitle (title => "any string")

 - title ("any string")		 : title of the grid

setter for member title

=cut

    my $this = shift;


    my $title = shift;



    $this->{title} = $title;
    return $title;
}



=pod

=head2 rowSet => DB::RowSet

results of an executed query

=cut

sub getRowSet {

=pod

=head3 $Grid->getRowSet ()


getter for member rowSet

=cut

    my $this = shift;





    return $this->{rowSet};
}
sub setRowSet {

=pod

=head3 $Grid->setRowSet (rowSet => DB::RowSet)

 - rowSet (DB::RowSet)		 : results of an executed query

setter for member rowSet

=cut

    my $this = shift;


    my $rowSet = shift;
    eval {my $dummy = $rowSet->isa("DB::RowSet");};Confess "$@\n" . Dumper($rowSet) if $@;
    if (defined $rowSet) { Confess "argument 'rowSet' of method Markup::Grid->setRowSet() is required to be of reference type DB::RowSet, but it looks to be of type " . ref ($rowSet)  unless $rowSet->isa("DB::RowSet");}



    $this->{rowSet} = $rowSet;
    return $rowSet;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $Grid->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $Grid->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from Grid.pm.m80 by 
bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut




my %markupFunctions = (tableHeader => \&tableHeader,
		       headerCell => \&headerCell,
		       rowFooter => \&rowFooter,
		       rowHeader => \&rowHeader,
		       tableItem => \&tableItem,
		       tableFooter => \&tableFooter,
		       );


sub _new {

=pod

=head3 $Grid->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "Markup::Grid->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    $this->setRowSet(DB::RowSet->new(dbh => $this->getDbh(),
				     sql => $this->getSql()));
}

sub render {

=pod

=head3 $Grid->render (markup => "(html|wiki)"*, formatData => "any string")

 - markup ("(html|wiki)")		 : rendering format
 - formatData ("any string")		 : rendering information on how to represent specific fields

renders a grid in a markup format

=cut

    my $this = shift;

    Confess "Markup::Grid->render requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $markup = $args{markup};
    Confess "argument 'markup' is required for Markup::Grid->render()" unless exists $args{markup};
        if (defined $markup) { Confess "argument 'markup' of method Markup::Grid->render() failed format validation of '(html|wiki)'" unless $markup =~ /(html|wiki)/;}
    my $formatData = $args{formatData};




    my $ret;

    my ($title,$headerSize) = split (/:/,$this->getTitle());

    $ret .= "<h$headerSize>$title</h$headerSize><br>\n" if $title;

    $ret .= $this->markup(results => $this->getRowSet()->getResults(),
			  title => $this->getSql(),
			  format => $formatData);

    $ret;
}


sub markup {
    
=pod

=head3 $Grid->markup (results => HASH*, title => "any string", markupFunctions => HASH, format => ARRAY)

 - results (HASH)		 : SQL results as returnd from DB::RowSet->getResults()
 - title ("any string")		 : title for markup object
 - markupFunctions (HASH)		 : hash representation of overried rendering functions
 - format (ARRAY)		 : custom formatting information for cell data

routine for converting a SQL result set to markup

=cut

    my $this = shift;

    Confess "Markup::Grid->markup requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $results = $args{results};
    Confess "argument 'results' is required for Markup::Grid->markup()" unless exists $args{results};
        if (defined $results) { Confess "argument 'results' of method Markup::Grid->markup() is required to be of reference type HASH " unless ref($results) =~ /^HASH/;}
    my $title = $args{title};
    my $markupFunctions = $args{markupFunctions};
        if (defined $markupFunctions) { Confess "argument 'markupFunctions' of method Markup::Grid->markup() is required to be of reference type HASH " unless ref($markupFunctions) =~ /^HASH/;}
    my $format = $args{format};
        if (defined $format) { Confess "argument 'format' of method Markup::Grid->markup() is required to be of reference type ARRAY " unless ref($format) =~ /^ARRAY/;}




    my %results = %{$results};
    my @fields = @{$results{_fields}};
    my $rows = $results{rows};
    my $ret;

    my %_markupFunctions = ($markupFunctions ? %{$markupFunctions} : %markupFunctions);

    $ret .= &{$_markupFunctions{tableHeader}}(title => $title);

    $ret .= &{$_markupFunctions{rowHeader}};

    foreach my $_x (@fields) {
	my $tmp = $_x;
	$tmp =~ s/_/ /g;
	$ret .= &{$_markupFunctions{headerCell}}(celldata => $tmp);
    }

    $ret .= &{$_markupFunctions{rowFooter}}();
    
    for (my $i = 0 ; $i < $rows ; $i++) {
	$ret .= &{$_markupFunctions{rowHeader}}(cursorPos => $i);
	foreach my $f (@fields) {
	    $ret .= &{$_markupFunctions{tableItem}}(cursorPos => $i,
						    celldata => $results{$f}[$i],
						    rowset => \%results,
						    field => $f,
						    format => $format);
	}
	$ret .= &{$_markupFunctions{rowFooter}}();
    }

    $ret .= &{$_markupFunctions{tableFooter}}();
    $ret;
}


sub tableHeader {
    my %data = @_;
    my $title = $data{title};

    $title =~ s/\'//g; 
    return "
<table border='1' width='90%' align='center' summary='$title'>
";
}

sub headerCell {
    my %data = @_;

    return "
    <td>
      <b>$data{celldata}</b>
    </td>
";
}

sub rowFooter {
    my %data = @_;

    return "
  </tr>
";

}

sub tableFooter {
    my %data = @_;

    return "
</table>
";
}


sub rowHeader {
    my %data = @_;

    return "
  <tr>
";
}

sub tableItem {
    my %data = @_;

    my $format = $data{format};
    my $field = $data{field};
    my $celldata = $data{celldata};
    my $cursorPos = $data{cursorPos};
    my $rowset = $data{rowset};

# alternating bg color
    my $bg = ((($cursorPos % 2) > 0)  ? 'bgcolor="#DFEFEF"' : " ") ;

    foreach my $_format (@{$format}) {
	if ($field =~ $_format->{field}) {
	    if ($_format->{type} =~ /func/) {
		$celldata = &{$_format->{function}}(celldata => $celldata, 
						    cursorPos => $cursorPos, 
						    field => $field,
						    rowset => $rowset);
	    } else { # sprintf
		$celldata = sprintf ($_format->{format}, $celldata);
		last;
	    }
	}
    }

    "
    <td $bg>
      $celldata
    </td>
";
}
