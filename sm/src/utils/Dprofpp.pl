#!/usr/bin/perl

use Carp;
use Getopt::Long;
use Data::Dumper;
use Pod::Usage;
use File::Basename;

sub print_usage {
    if (scalar @_ > 0) {
        print STDERR "@_\n";
        exit(1);
    } else {
        pod2usage({ -exitval => 1, 
                    -verbose => ($debug ? $debug : 1),
                    -output  => \*STDERR});
    }
}

use ProfilerNode;
use List::Object;
use Data::Dumper;
use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

sub docmdi {    
    printmsg "@_";
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - ignoring\n";
        }
    }
    $rc;
}
use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}
sub cleanup ($@) { 
    my $exit_code = shift;
    printmsg @_ if scalar @_;
    printmsg "exiting with exit code = $exit_code";
    exit $exit_code;
}
sub debugPrint ($@) { 
    my $level = shift;
    if ($debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}
use Term::ANSIColor qw(:constants);
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, "@_", RESET }
my $method;
$method = $ENV{method} if $ENV{method};
$trace = "0";
$trace = $ENV{trace} if $ENV{trace};
$debug = "0";
$debug = $ENV{debug} if $ENV{debug};
my $help = "0";
$help = $ENV{help} if $ENV{help};

GetOptions( 	'method:s'	=> \$method,
	'trace'	=> \$trace,
	'debug+'	=> \$debug,
	'help'	=> \$help,
 );

print_usage() if $help;

=pod

=head1 NAME

Dprofpp.pl    

=head1 SYNOPSIS

Formatter for dprofpp output

=head1 ARGUMENTS

=over 4


=item 'method:s'

method to debug


=item 'trace'

The $trace command line flag turns on trace functionality


=item 'debug+'

The $debug command line flag is additive and can be used with the &debugPrint subroutine


=item 'help'

The help command line flag will print the help message



=back



=head1 PERLSCRIPT GENERATED SCRIPTS

This script was generated with the Helpers::PerlScript pre-compiler.

This file was automatically generated from the file: Dprofpp.pl.m80 by
bret on  (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux
) on Wed Feb 17 01:08:41 2010.

The following functions are included by default. The functions all have 
prototypes that make the parens optional.

=over 4

=item printmsg (@)

Will print a formatted message to STDERR.

=item docmdi (@)

Will run a system command and ignore the return code

=item docmd (@)

Will run a system command and exit with the return code of the child process, if it is non-zero

=item debugPrint ($@)

Use it like C<debugPrint 1, 'Some info message'> or C<debugPrint 2, 'Some trace message'> and
it will print out a little more information than the printmsg command.

=back

=cut

# ## This is autogenerated documentation

 
#print_usage() unless .... some condition;

sub render 
{
    my $ThisNode = shift;
    print $ThisNode->getIndentString() . $ThisNode->getMethod() . " (" . $ThisNode->getIterations() . " x " . $ThisNode->getTimePerIteration() . "s = " . $ThisNode->getTime() . "s) [". ($ThisNode->getParent() ? $ThisNode->getParent()->getMethod() : "" ) . "]\n";
    my $list = $ThisNode->getChildren();


#     if ($method && $ThisNode->getMethod() =~ /$method/) {
# 	foreach $obj (@{$list->{_array}}) {
# 	    print $obj->getMethod() . "\t";
# 	}
# 	print;
#     }


    $list->sort_by('getTimeInSeconds');

#     if ($method && $ThisNode->getMethod() =~ /$method/) {
# 	foreach $obj (@{$list->{_array}}) {
# 	    print $obj->getMethod() . "\t";
# 	}
# 	print;
#     }

    $list->reverse();
    my $count = $list->count();
    for (my $i = 0; $i < $count ; $i++) {
	render ($list->get($i));
    }
}

eval {
    while (<STDIN>) {
	push (@lines, $_);
    }

    my $RootNode = ProfilerNode->new(indent => -1,
				     indentString => "",
				     method => "main",
				     iterations => 1);

    my $CurNode = $RootNode;

    my $lineno=1;

    foreach $line (@lines) {
	$_=$line;
	/(\s*)([\w:]+) x (\d+)\s+(\d+\.\d+)s/;

	my $ThisNode = ProfilerNode->new( indent => length($1),
					  indentString => "$1",
					  method => $2,
					  iterations => $3,
					  time => $4);

	if ($CurNode->getIndent() eq $ThisNode->getIndent()) {                      # a peer of the current node
	    setParent(child => $ThisNode,
		      parent => $CurNode->getParent(), 
		      descr => "peer", 
		      lineno => $lineno);
	} elsif ($CurNode->getIndent() < $ThisNode->getIndent()) {                 # a child of the previous node

	    setParent(child => $ThisNode,
		      parent => $CurNode, 
		      descr => "indent", 
		      lineno => $lineno);

	} else {
	    my $SearchNode = $CurNode;
	    do {
		$SearchNode = $SearchNode->getParent();

		Confess "line $lineno: logic error failed to find parent node for $line" unless $SearchNode;
		
		if ( $SearchNode->getIndent() < $ThisNode->getIndent()) {
		    setParent(child => $ThisNode,
			      parent => $SearchNode, 
			      descr => "scan back", 
			      lineno => $lineno);

		} 
	    } until $ThisNode->getParent();
	}
	$CurNode = $ThisNode;
	$lineno++;
    }


    render($RootNode);

};
Confess "line $lineno: $@" if $@;

sub setParent {
    my %args = @_;

    $child = $args{child};
    $parent = $args{parent};
    $descr = $args{descr};
    $lineno = $args{lineno};

    $child->setParent($parent);
    $parent->addChild(node => $child);

    if ($debug) {
	print "line $lineno: node " . $child->getMethod() . " assigned to parent " . $parent->getMethod() . "($descr) : [ " . $child->getIndent() . " " . $parent->getIndent() . " ]\n";
    }
}

cleanup 0; # "
