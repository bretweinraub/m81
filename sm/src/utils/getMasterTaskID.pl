#!/usr/bin/perl

use Carp;
use Getopt::Long;
use Data::Dumper;
use Pod::Usage;
use File::Basename;

sub print_usage {
    if (scalar @_ > 0) {
        print STDERR "@_\n";
        exit(1);
    } else {
        pod2usage({ -exitval => 1, 
                    -verbose => ($debug ? $debug : 1),
                    -output  => \*STDERR});
    }
}

use dbutil;
use Data::Dumper;
use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

sub docmdi {    
    printmsg "@_";
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - ignoring\n";
        }
    }
    $rc;
}
use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}
sub cleanup ($@) { 
    my $exit_code = shift;
    printmsg @_ if scalar @_;
    printmsg "exiting with exit code = $exit_code";
    exit $exit_code;
}
sub debugPrint ($@) { 
    my $level = shift;
    if ($debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}
use Term::ANSIColor qw(:constants);
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, "@_", RESET }
my $task_id;
$task_id = $ENV{task_id} if $ENV{task_id};
my $taskname;
$taskname = $ENV{taskname} if $ENV{taskname};
$trace = "0";
$trace = $ENV{trace} if $ENV{trace};
$debug = "0";
$debug = $ENV{debug} if $ENV{debug};
my $help = "0";
$help = $ENV{help} if $ENV{help};

GetOptions( 	'task_id:i'	=> \$task_id,
	'taskname:s'	=> \$taskname,
	'trace'	=> \$trace,
	'debug+'	=> \$debug,
	'help'	=> \$help,
 );

print_usage() if $help;

=pod

=head1 NAME

getMasterTaskID.pl.m80.pl    

=head1 SYNOPSIS

given a task_id, return the master_task_id that corresponds.

=head1 ARGUMENTS

=over 4


=item 'task_id:i'

The task_id that is used as the root for deriving the master_task_id.


=item 'taskname:s'

The taskname used to derive the task_id to derive the root for deriving the master_task_id.


=item 'trace'

The $trace command line flag turns on trace functionality


=item 'debug+'

The $debug command line flag is additive and can be used with the &debugPrint subroutine


=item 'help'

The help command line flag will print the help message



=back



=head1 PERLSCRIPT GENERATED SCRIPTS

This script was generated with the Helpers::PerlScript pre-compiler.

This file was automatically generated from the file: getMasterTaskID.pl.m80 by
bret on localhost.localdomain (Linux localhost.localdomain 2.6.9-78.0.1.EL #1 Tue Aug 5 10:49:42 EDT 2008 i686 i686 i386 GNU/Linux
) on Fri Aug 14 10:15:40 2009.

The following functions are included by default. The functions all have 
prototypes that make the parens optional.

=over 4

=item printmsg (@)

Will print a formatted message to STDERR.

=item docmdi (@)

Will run a system command and ignore the return code

=item docmd (@)

Will run a system command and exit with the return code of the child process, if it is non-zero

=item debugPrint ($@)

Use it like C<debugPrint 1, 'Some info message'> or C<debugPrint 2, 'Some trace message'> and
it will print out a little more information than the printmsg command.

=back

=cut

# ## This is autogenerated documentation

require "dbConnect.pl";
 
print_usage() unless $task_id || $taskname;

my $my_task_id = ''; my $sql = ''; my $no_drill_down = 0;
if ($task_id) {
    $sql = "select count(task_id) cnt from task where task_id = $task_id and parent_task_id is null";
    dbutil::loadSQL ($dbh, $sql, \%tasks, $debug);
    $no_drill_down = $tasks{'CNT'}->[0];
} elsif ($taskname) {
    $sql = "select count(task_id) cnt from task where taskname = '$taskname' and status not in ('queued','canceled')";
    $no_drill_down = 0;
}
    
unless ($no_drill_down) {
    
    debugPrint(1, "Found a CNT in the db, looking up the master_task_id");
    if ($task_id) {    
        $sql = " select 	task_id 
	 from 	task  
         start with 
		task.task_id = 	$task_id
	 connect by 
		task.task_id = prior task.parent_task_id 
";
#          where parent_task_id is null
    } elsif ($taskname) {
        $sql = " select 	task_id 
	 from 	task  
         start with 
		task.task_id = (select max(task_id) from task where taskname = '$taskname' and status not in ('queued','canceled'))
	 connect by 
		task.task_id = prior task.parent_task_id 
";
    }
        
    dbutil::loadSQL ($dbh, $sql, \%s, $debug);
    $task_ids = $s{TASK_ID};
    $my_task_id = $task_ids->[ @$task_ids - 1 ];
} else {
    $my_task_id = $task_id;
}
print "$my_task_id\n";

cleanup 0; # "
