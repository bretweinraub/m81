#!/usr/bin/perl

=pod

=head1 NAME

dumpContext.pl

=head1 SYNOPSIS

Small tool to output the actual context of a task (after all parent/child inheritence and mapper applications).

=head1 OPTIONS AND ARGUMENTS

=over 4

=item -task_id [task_id]

Starting in v3.0 -task_id is deprecated.  Use -action-id instead.  -task_id is not export filtered and never will be.
If you think something isn't working correctly with this option, that's probably because its not.  Use -action_id.

=item -verbose {dump sql}

=item -mapper [additional mapper]

This option is not supported when specifying the action id

=item -filter {only mapper matches are dumped out}

=item -action-id [action-id]

Starting in v3.0 this is the preferred method.  Specifying the action-id will get you the correct context for an
action.  It includes the m80 environment and is correctly mapped and filtered.  USE IT.

=item -debug [debugLevel]

Sets a state-machine like debug level.  Identical log messages to those generated by the state machine are created.

=back

=head1 SAMPLE OUTPUT

       # mapper is s/thistest_//;s/usbodell2650_2_//;
       export matchedInstaller_download_user="bt"
       export bassist_TYPE="host"
       # mapper applied (usbodell2650_2_test_root_unix => test_root_unix)
       export test_root_unix="/usr/local/portalperf/loadtest"
       export downloadServer_host="bassist"
       # mapper applied (thistest_TYPE => TYPE)
       export TYPE="perftest"
       # mapper applied (usbodell2650_2_ipaddress => ipaddress)
       export ipaddress="172.17.161.102"
       export adminserver_os="linux"



=head1 EXAMPLES

dumpContext.pl -task_id 851

Sometimes when developing it can be very useful to load the context into your current shell:

eval $(dumpContext.pl -task 881)

=head1 PREREQUISITES

If you use m80 to set your environment for connection to the ChainDB database, then m80 --execute is probably
required.


=cut 

use ChainDB;
use task;
use Getopt::Long;
use File::Basename;
use lib dirname($0);
use debug;
use ContextExporter;
use Data::Dumper;

my $argMapper;

GetOptions("task_id:i", \$task_id,
	   "action_id:i", \$action_id,
	   "mapper:s", \$argMapper,
	   "filter", \$filter,
	   "debug:i" => \my $debugLevel,
	   "verbose", \$verbose);


$debug = debug::new ('level' => ($debugLevel) ? $debugLevel : 0,
		     prefix => '# ');

if ($task_id) {                                                                 # ye olde dumpc() from before context filters.
    my $ChainDB = ChainDB::new (verbose => $verbose);
    my %context = %{$ChainDB->loadTaskContext($task_id)};
    
    my $parent_task_id = $ChainDB->fetchParentTaskId($task_id);
    
    my $mapper = $argMapper ? $argMapper : task::_getMapper (task_id => $task_id, ChainDB => $ChainDB);
    
    my $splitText=";";		# assigning to a variable will hopefully fix emacs colorization
    
    if ($mapper) {
	for $lmapper (split /$splitText/, $mapper) { 
	    print "# mapper is $lmapper\n";
	    map {
		my $data = $_;
		my $matchref;
		{
		    $mapped = task::applyMapper (mapper => $lmapper, data => $data, matchref => \$matchref);
		    print "export $mapped=\'$context{$data}\'\n" unless ($filter and not $matchref);
		    print "export $data=\'$context{$data}\' # also exporting unmapped version\n" if ($mapped ne $data) ;
		    }
	    } (keys(%context));
	}
    } else {
	map {
	    my $data = $_;
	    print "export $data=\'$context{$data}\'\n";

	} (keys(%context));
    }

    print "export parent_task_id=\'$parent_task_id\'\n" if $parent_task_id;
} elsif ($action_id) { #########################################################################################################################################
    my $ChainDB = ChainDB::new (verbose => $verbose);
    
    $ChainDB->loadSQL ("select task_id, export_filter from action where action_id = $action_id", \my %action, $verbose);

    my $task_id = $action{TASK_ID}[0];
    my $export_filter = $action{EXPORT_FILTER}[0];

    

    my %unifiedContext = (%ENV, %{$ChainDB->loadTaskContext($task_id)});
    my $mapper = task::_getMapper (task_id => $task_id, ChainDB => $ChainDB);

    print "# task mapper derived as $mapper\n";

    my @exportData = split(/\|/,$export_filter);                                # convert back the format exportContext() expects ... sort of a hack

    ContextExporter::exportContext ( mapper => $mapper, 
				     debug => $debug,
				     unifiedContext => \%unifiedContext,
				     task_id => $task_id,
				     exportData => \@exportData);

    my $env_size = 0;
    foreach $key (keys(%ENV)) {
	print "export $key=\'$ENV{$key}\'\n";                                   # dump the mapped filter environment to STDOUT
	$env_size += length($key) + length($ENV{$key});
    }

    print "# subshell environment size is: $env_size \n";
} else { ######################################################################################################################################################
    print STDERR basename($0) . ": please use -task_id or -action_id\n";
    exit 1;
}

exit 0;
    




