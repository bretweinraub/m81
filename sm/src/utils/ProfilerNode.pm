


=pod

=head1 NAME - ProfilerNode

A node in the tree generated by dprofpp -S

=head1 EXAMPLE


    my $ProfilerNode = $ProfilerNode->new();   # stub example .... expand


=cut

# This file was automatically generated from ProfilerNode.pm.m80 by 
# bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)
# DO NOT EDIT THIS FILE 


package ProfilerNode;

use Carp;
use Data::Dumper;
use Term::ANSIColor qw(:constants);
use strict;
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, @_, RESET }

use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

use List::Object;
use fields qw( indent indentString parent elements children method iterations time debug );

=pod

=head1 CONSTRUCTOR

=over 4

=item ProfilerNode->new()

initializes on object of type ProfilerNode

=back

=cut


# %_allSetters - an array of all setters for all members of the class
my %_allSetters = ();

my %_allMemberAttributes = ();

BEGIN {
# $_allMembers{_TYPE} = 1; # - WHAT IS THIS FOR?
$_allMemberAttributes{indent} = {
          'required' => 1,
          'name' => 'indent',
          'type' => 'string',
          'description' => 'Depth of this node'
        }
;
$_allSetters{indent} = \&setIndent;
$_allMemberAttributes{indentString} = {
          'required' => 1,
          'name' => 'indentString',
          'type' => 'string',
          'description' => 'Actual indentation text'
        }
;
$_allSetters{indentString} = \&setIndentString;
$_allMemberAttributes{parent} = {
          'ref' => 'ProfilerNode',
          'name' => 'parent',
          'description' => 'Parent of this node'
        }
;
$_allSetters{parent} = \&setParent;
$_allMemberAttributes{elements} = {
          'ref' => 'ARRAY',
          'name' => 'elements',
          'description' => 'Array of UXFElement objects in this document'
        }
;
$_allSetters{elements} = \&setElements;
$_allMemberAttributes{children} = {
          'ref' => 'List::Object',
          'name' => 'children',
          'description' => 'Order List of all the children of this node'
        }
;
$_allSetters{children} = \&setChildren;
$_allMemberAttributes{method} = {
          'required' => 1,
          'name' => 'method',
          'description' => 'The method for this node'
        }
;
$_allSetters{method} = \&setMethod;
$_allMemberAttributes{iterations} = {
          'required' => 1,
          'name' => 'iterations',
          'description' => 'Number of times that this method was called at this node of the tree'
        }
;
$_allSetters{iterations} = \&setIterations;
$_allMemberAttributes{time} = {
          'name' => 'time',
          'type' => 'float',
          'description' => 'Amount of time spent at this node of the tree as represented by a float'
        }
;
$_allSetters{time} = \&setTime;
$_allMemberAttributes{debug} = {
          'name' => 'debug',
          'description' => 'debug allows an object to specify its debugPrint level'
        }
;
$_allSetters{debug} = \&setDebug;


}

#
# TODO ... needs to merge in the parents attributes; the commented out block is close.
#
sub getReflectionAPI { 
#     my $this = shift; 
#     my %unified = (%{$this->SUPER::getReflectionAPI()}, %_allMemberAttributes);
#     \%unified;
    \%_allMemberAttributes;
}

#
# For some (currently) mysterious reason on perl 5.8.8 on the Linux kernel 2.6.18-8.1.14.el5 there
# is no data in the %_allMemberAttributes.  Therefore here is another way to get a list of member data
# out of the class.
#

sub getMembers {
    my $this = shift;
    my @ret = keys(%{$this});
    \@ret;
}
    
sub new {
    my ProfilerNode $this = shift;

    print STDERR "in ProfilerNode::new(" . join (",", @_) . ")\n" if $ENV{DEBUG};
    Confess "Missing the value for an argument (even nulls) on creation of ProfilerNode" if scalar @_ % 2 != 0;

    my %args = @_;

    unless (ref $this) {
	$this = fields::new($this);
    }

    #
    # This next block tries to set any of the values that you passed into this
    # constructor. You might have said new X( arg1 => 123, arg2 => 456); It is going
    # to take that and try to call setArg1(123), setArg2(123). I.e. it is going
    # to derive the setter for your named argument (by upper casing the first letter
    # of your argument name) and then if it finds that the object can call the
    # setter (i.e. it is defined in this class or any parent class) it will call it.
    #
    # If the setter cannot be found - then assume that this is a bad argument
    # that was passed to the function and die with that information.
    #
    foreach my $key (keys(%args)) {

        my $setterName = $key;                              # workspace for determining the name of the setter
        $setterName =~ s/^(\w)/uc($1)/e;                    # uc the first char of the argument name. I.e. arg1 => Arg1.
        $setterName = "set" . $setterName;                  # prepend "set" to the uppercased argument name.

        if (my $fn = $this->UNIVERSAL::can($setterName)) {  # test that the object can call this function
            $fn->($this,$args{$key});                       # and call it
        } else {                                            # else fail with an error. 
            Confess "Field named \"$key\" is not defined in object ProfilerNode. typo ?\n";
        }
    }


    Confess "cannot initialize object of type ProfilerNode without required member variable indent"
        unless exists $this->{indent};

    Confess "cannot initialize object of type ProfilerNode without required member variable indentString"
        unless exists $this->{indentString};

    Confess "cannot initialize object of type ProfilerNode without required member variable method"
        unless exists $this->{method};

    Confess "cannot initialize object of type ProfilerNode without required member variable iterations"
        unless exists $this->{iterations};


    #### __new is the magic "pre-constructor".  You can intercept a call to the parent
    #### constructor by defining a __new() procedure in your class.

    eval {ProfilerNode::__new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?ProfilerNode::__new/;

    #### Now call the parent constructor, if any.

    eval {$this->SUPER::new(%args)};

    croak $@ if $@
	and $@ !~ /^Can\'t locate object method/;

    ####
    #### Typically this following contains your "real" constructor"
    #### so if you are debugging this next call my be a good candidate to step into.
    ####

    eval {ProfilerNode::_new($this,%args);};

    croak $@ if $@
	and $@ !~ /^Undefined subroutine.+?ProfilerNode::_new/;

    $this;
}

###  END GENERATED CODE

=pod

=head1 MEMBERS AND MEMBER ACCESS METHODS

=cut



=pod

=head2 indent => "any string"*

Depth of this node

=cut

sub getIndent {

=pod

=head3 $ProfilerNode->getIndent ()


getter for member indent

=cut

    my $this = shift;





    return $this->{indent};
}
sub setIndent {

=pod

=head3 $ProfilerNode->setIndent (indent => "any string"*)

 - indent ("any string")		 : Depth of this node

setter for member indent

=cut

    my $this = shift;


    my $indent = shift;
    Confess "argument 'indent' is required for ProfilerNode->setIndent()" unless defined $indent;



    $this->{indent} = $indent;
    return $indent;
}



=pod

=head2 indentString => "any string"*

Actual indentation text

=cut

sub getIndentString {

=pod

=head3 $ProfilerNode->getIndentString ()


getter for member indentString

=cut

    my $this = shift;





    return $this->{indentString};
}
sub setIndentString {

=pod

=head3 $ProfilerNode->setIndentString (indentString => "any string"*)

 - indentString ("any string")		 : Actual indentation text

setter for member indentString

=cut

    my $this = shift;


    my $indentString = shift;
    Confess "argument 'indentString' is required for ProfilerNode->setIndentString()" unless defined $indentString;



    $this->{indentString} = $indentString;
    return $indentString;
}



=pod

=head2 parent => ProfilerNode

Parent of this node

=cut

sub getParent {

=pod

=head3 $ProfilerNode->getParent ()


getter for member parent

=cut

    my $this = shift;





    return $this->{parent};
}
sub setParent {

=pod

=head3 $ProfilerNode->setParent (parent => ProfilerNode)

 - parent (ProfilerNode)		 : Parent of this node

setter for member parent

=cut

    my $this = shift;


    my $parent = shift;
    eval {my $dummy = $parent->isa("ProfilerNode");};Confess "$@\n" . Dumper($parent) if $@;
    if (defined $parent) { Confess "argument 'parent' of method ProfilerNode->setParent() is required to be of reference type ProfilerNode, but it looks to be of type " . ref ($parent)  unless $parent->isa("ProfilerNode");}



    $this->{parent} = $parent;
    return $parent;
}



=pod

=head2 elements => ARRAY

Array of UXFElement objects in this document

=cut

sub getElements {

=pod

=head3 $ProfilerNode->getElements ()


getter for member elements

=cut

    my $this = shift;





    return $this->{elements};
}
sub setElements {

=pod

=head3 $ProfilerNode->setElements (elements => ARRAY)

 - elements (ARRAY)		 : Array of UXFElement objects in this document

setter for member elements

=cut

    my $this = shift;


    my $elements = shift;
        if (defined $elements) { Confess "argument 'elements' of method ProfilerNode->setElements() is required to be of reference type ARRAY " unless ref($elements) =~ /^ARRAY/;}



    $this->{elements} = $elements;
    return $elements;
}



=pod

=head2 children => List::Object

Order List of all the children of this node

=cut

sub getChildren {

=pod

=head3 $ProfilerNode->getChildren ()


getter for member children

=cut

    my $this = shift;





    return $this->{children};
}
sub setChildren {

=pod

=head3 $ProfilerNode->setChildren (children => List::Object)

 - children (List::Object)		 : Order List of all the children of this node

setter for member children

=cut

    my $this = shift;


    my $children = shift;
    eval {my $dummy = $children->isa("List::Object");};Confess "$@\n" . Dumper($children) if $@;
    if (defined $children) { Confess "argument 'children' of method ProfilerNode->setChildren() is required to be of reference type List::Object, but it looks to be of type " . ref ($children)  unless $children->isa("List::Object");}



    $this->{children} = $children;
    return $children;
}



=pod

=head2 method => "any string"*

The method for this node

=cut

sub getMethod {

=pod

=head3 $ProfilerNode->getMethod ()


getter for member method

=cut

    my $this = shift;





    return $this->{method};
}
sub setMethod {

=pod

=head3 $ProfilerNode->setMethod (method => "any string"*)

 - method ("any string")		 : The method for this node

setter for member method

=cut

    my $this = shift;


    my $method = shift;
    Confess "argument 'method' is required for ProfilerNode->setMethod()" unless defined $method;



    $this->{method} = $method;
    return $method;
}



=pod

=head2 iterations => "any string"*

Number of times that this method was called at this node of the tree

=cut

sub getIterations {

=pod

=head3 $ProfilerNode->getIterations ()


getter for member iterations

=cut

    my $this = shift;





    return $this->{iterations};
}
sub setIterations {

=pod

=head3 $ProfilerNode->setIterations (iterations => "any string"*)

 - iterations ("any string")		 : Number of times that this method was called at this node of the tree

setter for member iterations

=cut

    my $this = shift;


    my $iterations = shift;
    Confess "argument 'iterations' is required for ProfilerNode->setIterations()" unless defined $iterations;



    $this->{iterations} = $iterations;
    return $iterations;
}



=pod

=head2 time => "any string"

Amount of time spent at this node of the tree as represented by a float

=cut

sub getTime {

=pod

=head3 $ProfilerNode->getTime ()


getter for member time

=cut

    my $this = shift;





    return $this->{time};
}
sub setTime {

=pod

=head3 $ProfilerNode->setTime (time => "any string")

 - time ("any string")		 : Amount of time spent at this node of the tree as represented by a float

setter for member time

=cut

    my $this = shift;


    my $time = shift;



    $this->{time} = $time;
    return $time;
}



=pod

=head2 debug => "any string"

debug allows an object to specify its debugPrint level

=cut

sub getDebug {

=pod

=head3 $ProfilerNode->getDebug ()


getter for member debug

=cut

    my $this = shift;





    return $this->{debug};
}
sub setDebug {

=pod

=head3 $ProfilerNode->setDebug (debug => "any string")

 - debug ("any string")		 : debug allows an object to specify its debugPrint level

setter for member debug

=cut

    my $this = shift;


    my $debug = shift;



    $this->{debug} = $debug;
    return $debug;
}



=pod

=head1 GENERALIZED OBJECT METHODS 

=cut



=pod

=over 4

=item _require (member1,member2,...,memberN)

will iterate over arguments and validate there is a non null value for each of the listed object members

=back

=cut


sub _require
{
    my $this = shift;
    map { 
	Confess "required member variable $_ not set" unless $this->getProperty($_);
    } (@_);
}

sub debugPrint { 
    my $this = shift;
    my $level = shift;
    Confess 'you\'ve called debugPrint - convert this call to $this->debugPrint()'
	unless ref($this);
    if ($this->{debug} >= $level || $main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

sub debugPrint_s {   # static version of debug print
    my $level = shift;
    if ($main::debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}

use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}

1;

=pod

=head1 NOTES ON THIS DOCUMENTATION

In method signatures a * denotes a required option.

This file was automatically generated from ProfilerNode.pm.m80 by 
bret on ubuntu (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux)


=head1 OBJECT METHODS

=cut



sub _new {

=pod

=head3 $ProfilerNode->_new ()


callback constructor, do not call directly use new() instead

=cut

    my $this = shift;

    Confess "ProfilerNode->_new requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;



    do {
	$this->setChildren(List::Object->new(type => "ProfilerNode"));
    };
}

sub addChild {
    
=pod

=head3 $ProfilerNode->addChild (node => ProfilerNode*)

 - node (ProfilerNode)		 : ProfilerNode object to add as a child

add a child to this node

=cut

    my $this = shift;

    Confess "ProfilerNode->addChild requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;
    my $node = $args{node};
    Confess "argument 'node' is required for ProfilerNode->addChild()" unless exists $args{node};
    eval {my $dummy = $node->isa("ProfilerNode");};Confess "$@\n" . Dumper($node) if $@;
    if (defined $node) { Confess "argument 'node' of method ProfilerNode->addChild() is required to be of reference type ProfilerNode, but it looks to be of type " . ref ($node)  unless $node->isa("ProfilerNode");}



       
    do {      
	$this->getChildren()->add($node);
    };
}

sub getTimeInSeconds {
    
=pod

=head3 $ProfilerNode->getTimeInSeconds ()


return the time of the method in seconds

=cut

    my $this = shift;

    Confess "ProfilerNode->getTimeInSeconds requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    do {
	my $time = $this->getTime();
	return abs ($time * 100);
    }
}

sub getTimePerIteration {
    
=pod

=head3 $ProfilerNode->getTimePerIteration ()


return the time of each iteration in seconds

=cut

    my $this = shift;

    Confess "ProfilerNode->getTimePerIteration requires named arguments, or maybe a non-static method is being called in a static context " if scalar @_ && scalar @_ % 2 != 0;
    my %args = @_;




    do {
	my $ret = sprintf ("%f", $this->getTime() / $this->getIterations());
	return $ret;
    }
}

	    

