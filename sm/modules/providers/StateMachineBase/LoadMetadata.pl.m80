<: #-*- perl -*-

# $m80path = [{ command => embedperl, chmod => '+x' }]
use Helpers::PerlScript;

my $ps = Helpers::PerlScript->new( name => 'LoadMetadata.pl' , 
                                   description => 'Flattens, Filters, And Preprocesses Metadata Collections into State Machine Task Context',
                                   include => ['Utils::FunctionalProgramming',
					       DB::DBHandleFactory,
					       'File::Basename',
					       'StateMachine::SMUtil',
					       'Utils::ISAutil',],
				   getopts => [{ tag => 'filter:s',
                                                 description => 'a filter for the export statements generated by this program',},
                                               { tag => 'force',
                                                 description => 'force loadcollections to run even if its run before (useful for debugging)',},
					       { tag => 'master',
						 description => 'use master_task_id instead of task_id for manipulating the task context',},
					       { tag => 'noappend',
						 description => 'don\'t append /objects to the m81perlLib_DEPLOY_DIR path',},
					       { tag => "exclude:s",
						 description => "exclude any libs from generation that match this tag"},
					       { tag => "prepend:s",
						 default => 'Metadata::Object::',
						 description => "module path to prepend to generated scripts"},
					       { tag => "task_id:i",
						 required => 1,
						 description => "task_id to associate with this context data"},],

				   );
print $ps->dump(); print $ps->pod();
:>

$ENV{task_id} = $task_id;                                                   # export it just in case it came in from the command line

sub allObjectsToFile {
    my $tmpfile = "$AUTOMATOR_STAGE_DIR/loadAndAlterCollections.tpl";
    my $pmdir = "$m81perlLib" . ($noappend ? "" : "/objects");
    my @tmparray = (\@allObjects);
    my $dumper = Data::Dumper->new(\@tmparray);
    $dumper->Purity(1);
    $dumper->Varname("AllObjects");

    open (F, ">$tmpfile");
    print F "#!/usr/bin/perl\n";
    print F "use Metadata::Object;\n";
    
    opendir(D, "$pmdir") || Confess "unable to open dir $pmdir: $!";
    my @perlModules = grep { /\.pm$/ } readdir(D);
    closedir(D);
    foreach (@perlModules) {
        s/.+?objects\///;
        s/\.pm//;
        chomp;

        print F "use $prepend$_;\n" 
	    unless $exclude && /$exclude/;
    }
    print F $dumper->Dump();
    print F <<'EOF';
@allObjects = @{$AllObjects1};    
dumpObjects(@allObjects);
dumpObjectTypes(@allObjects);

1;
EOF
    close (F);
    return $tmpfile;
}


sub mixedpath {
    my ($path) = @_;
    $path =~ s,\\(\S),/$1,g;
    unless ($path =~ s,\/cygdrive/(\w)/,$1:/,i) {
        $path = "/$path" unless $path =~ /^\//;
        $path = "C:/Cygwin$path";
    }
    return $path;
}

sub unixpath {
    my ($path) = @_;
    $path =~ s,\\(\S),/$1,g;
    $path =~ s,^(\w):/,/cygdrive/$1/,i;
    return $path;
}

    if ($master) {
	$task_id = $ENV{master_task_id};
	$ENV{task_id} = $task_id;
    }

    my $loadCollectionsCompleted = $ENV{loadCollectionsCompleted};

# exit if I have already been run
if (defined $loadCollectionsCompleted and not defined $force) {
    printmsg "looks like loadCollections has already run: loadCollectionsCompleted=$loadCollectionsCompleted and force=$force";
    exit 0;
}

$m81perlLib=($ENV{DEV} ? $ENV{m81perlLib_deploy_PATH} : $ENV{m81perlLib_DEPLOY_DIR}) . "/Metadata/Object";
debugPrint (0, "m81perlLib derived as $m81perlLib");

$AUTOMATOR_STAGE_DIR=$ENV{AUTOMATOR_STAGE_DIR};
Confess "cannot derive m81perlLib from environment" 
    unless $m81perlLib;

Confess "cannot derive AUTOMATOR_STAGE_DIR from environment" 
    unless $AUTOMATOR_STAGE_DIR;

#
# backup scripts if they us the "_collections" syntax.
#
printmsg "collections is $collections";
printmsg "_collections is $_collections";


my $dbhandle = DB::DBHandleFactory::newDBHandle();

unless ($collections) {
    if ($_collections) {
	$archiveDir="$AUTOMATOR_STAGE_DIR/collections";
	docmd ("mkdir -p $archiveDir");
	my $new;
	foreach $coll (split (/,/,$_collections)) {
	    docmd("cp -p $coll $archiveDir");
	    $new .= "," if $new;
	    $new .= "$archiveDir/" . basename($coll);
	}
	StateMachine::SMUtil::createContext(dbhandle => $dbhandle,
					    tag => "collections",
					    value => "$new",
					    verbose => 1,
					    task_id => $task_id);
	$collections = $new;
    }
}

printmsg ("About to load your file ... if this is the last message you see, then one or more of your collection(s) is bad and you will need to debug it");
require "Metadata/LoadCollections.pl";
printmsg("Loading your collection succesfully");

# once all the conversions are complete, we need to flatten and load in the db.
my $dumpedfile = allObjectsToFile(); #(@allObjects);
docmd("chmod +x $dumpedfile");
my $rc = docmd( "$dumpedfile > $dumpedfile.stdout" );

#
# Process the filter
#
if ($filter) {
    require "$filter" or confess "could not load filter file $filter";
    open (DATA, "< $dumpedfile.stdout") or confess "could not open $dumpedfile.stdout";
    open (FILTER, "> $dumpedfile.stdout.filtered") or confess "could not open $dumpedfile.stdout.filtered";

    while (<DATA>) {
	my $ret = filter($_);
	if ($ret) {
	    print FILTER $ret;
	} else {
	    print STDERR "$_ suppressed by $filter\n";
	}
    }
    
    close (DATA);
    close (FILTER);
    docmd("cat $dumpedfile.stdout.filtered | sort -u | time shell2context.pl -nodelete -verbose");
} else {
    docmd("cat $dumpedfile.stdout | sort -u | time shell2context.pl -nodelete -verbose");
}

printmsg("$dumpedfile exited with $rc");
StateMachine::SMUtil::createContext(dbhandle => $dbhandle,
				    tag => "loadCollectionsCompleted",
				    value => "1",
				    verbose => 1,
				    task_id => $task_id);
exit 0;

