#!/usr/bin/perl

use Carp;
use Getopt::Long;
use Data::Dumper;
use Pod::Usage;
use File::Basename;

sub print_usage {
    if (scalar @_ > 0) {
        print STDERR "@_\n";
        exit(1);
    } else {
        pod2usage({ -exitval => 1, 
                    -verbose => ($debug ? $debug : 1),
                    -output  => \*STDERR});
    }
}

use File::Basename;
use Env;
use File::Basename;

sub printmsg (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_.\n" ;
}

sub printmsgn (@) { 
    my $date = localtime;
    print STDERR $date . ":" . basename($0) . ":($$): @_\n" ;
}

sub docmdi {    
    printmsg "@_";
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - ignoring\n";
        }
    }
    $rc;
}
use Carp;

sub docmdq (@) {    
    system(@_);

    my $rc;
    if ($? == -1) {
        $rc = -1; printmsg "failed to execute: $!";
	exit -1;
    }
    elsif ($? & 127) {
        $rc = $? & 127;
        printmsg "child process died with signal $rc, ", ($? & 128) ? 'with' : 'without', " coredump";
	exit $rc;
    }
    else {
        $rc = $? >> 8;
        if ($rc) {
            printmsg "child process exited with value $rc - Exiting!";
            exit $rc;
        }
    }
}

sub docmd (@) {    
    printmsg "@_" ;
    docmdq(@_);
}
sub cleanup ($@) { 
    my $exit_code = shift;
    printmsg @_ if scalar @_;
    printmsg "exiting with exit code = $exit_code";
    exit $exit_code;
}
sub debugPrint ($@) { 
    my $level = shift;
    if ($debug >= $level) {
        my ($caller) = (caller(1))[3];
        $caller = "[$caller]:" if $caller;
        my $date = localtime;
        print STDERR $caller . $date . ":" . basename($0) . ":($$): @_.\n" ;
    }
}
use Term::ANSIColor qw(:constants);
sub Confess (@) {confess BOLD, RED, @_, RESET}
sub Warn (@) { warn YELLOW, BOLD, ON_BLACK, "@_", RESET }

=pod

=head1 NAME

New.pl    

=head1 SYNOPSIS

Front Door For Template Expansion Tools

=head1 PERLSCRIPT GENERATED SCRIPTS

This script was generated with the Helpers::PerlScript pre-compiler.

This file was automatically generated from the file: New.pl.m80 by
bret on  (Linux ubuntu 2.6.31-19-generic-pae #56-Ubuntu SMP Thu Jan 28 02:29:51 UTC 2010 i686 GNU/Linux
) on Wed Feb 17 01:17:14 2010.

The following functions are included by default. The functions all have 
prototypes that make the parens optional.

=over 4

=item printmsg (@)

Will print a formatted message to STDERR.

=item docmdi (@)

Will run a system command and ignore the return code

=item docmd (@)

Will run a system command and exit with the return code of the child process, if it is non-zero

=item debugPrint ($@)

Use it like C<debugPrint 1, 'Some info message'> or C<debugPrint 2, 'Some trace message'> and
it will print out a little more information than the printmsg command.

=back

=cut

# ## This is autogenerated documentation

 
BEGIN {
    $NewHomeDirectory = dirname($0) . "/../New";

    $ENV{PATH} .= ":$NewHomeDirectory:$NewHomeDirectory/utils";
    $ENV{NEW} .= $NewHomeDirectory;
}

my $requestedNewEntity = shift;

my $secondArg=$ARGV[0];                                                         # Generate a usage statement if this is "-h"

printmsg BOLD . BLUE . "Requested new entity is $requestedNewEntity" . RESET;

eval {
    require "$NewHomeDirectory/manifest.pl";
};

Confess "$@" if $@;

my @matches = ();                                                                                                    

#
# Build List of Matching Newables
#
foreach $Newable (@Newables) {                                        # iterate over list from manifest
    push (@matches,$Newable)                                          # Add to matched List if there is regexp match
	if $Newable->getName() =~ m/$requestedNewEntity/ ;  
}                                                                     

# No Match
if ($#matches == -1) {
    printmsgn RED . "Nothing matched $requestedNewEntity, maybe you meant one of these:\n" . RESET;
    map { print $_->getName() . "\n"; } ( sort { $a->getName() cmp ($b->getName()) } @Newables); print "\n";
    Confess "Nothing matched $requestedNewEntity";
} elsif ($#matches > 0) {                                             # multiple matches                         
    printmsgn RED . "Multiple entities matched $requestedNewEntity, maybe you meant one of these:\n" . RESET;
    foreach (sort { $a->getName() cmp ($b->getName()) } @matches) {
	my $obj=$_;
	my $len = length($obj->getName());
	my $tabs = abs((32 - $len) / 8);
	print $obj->getName();
	foreach (my $i = 0 ; $i < $tabs ; $i++) {
	    print "\t";
	}
	print ":\t" . $obj->getDescription() . "\n";
    } (); print "\n";
    Confess "Multiples matched $requestedNewEntity";
}

my $Selected = $matches[0];

printmsg BOLD . BLUE . "Checking options for matched entity " . $Selected->getName() . RESET;

if ($secondArg =~ /-h/) {
    printmsgn "Getopts are (tag marks the command line argument ... see " . BOLD . 'perldoc Getopt::Long' . RESET . " for more information:";
    foreach $getopts (@{$Selected->getGetopts()}) {
	my ($arg) = split (/:/, $getopts->{tag});
	print GREEN . "-" . $arg . "\t:\t". BLUE . $getopts->{description} . RESET . "\n";
    }
    cleanup 0;
}

eval $Selected->getGetoptsStatement(@ARGV);                                         
eval $Selected->getCallSignature();                                                                                                                                                                                                        
=pod

=head1 CALL SIGNATURE

Typically you would use the shell function "New()".  See also B<portalPerfFunc.sh> for documentation of that function.

=head1 MANIFEST FILE FORMAT

The manifest for the new function can be found at: B<$TOP/New/manifest.pl>.  It should have a reasonably self
explanatory format, as in:

    use Newable;
    
    @Newables =
        (
         new Newable (name => "Interface Module",
                      callSignature => 'docmd("m80 --execute expandTemplate.sh -m $module -t $TOP/templates/interfaceModule.tmpl.m80")',
    		      getopts => [{tag => 'module:s',
    			           variable => '$module',
    			           nomy => 1,
    			           description => 'Name of the new interface module'}]),
         );
    
    1;


So as is indicated above add a new "Newable" entity to the Newables array will add your template (regardless of how you implemented it)
to the "New()" function.

=head1 ARGUMENTS CHECKING

New.pl does limited arguments checking for the script.  It uses the B<_getopts> method of the B<Helpers::PerlScript> to implement this.
See the documentation for that class for more information.

A simplistic usage message for any B<Newable> can be generated as follows:

  New.pl <NewableName> -h

or from the shell function New():

  New <NewableName> -h

=head1 SEE ALSO

B<portalPerfFunc.sh>
B<Newable.pm>
B<PerlScript.pm>

=cut

cleanup 0; 
